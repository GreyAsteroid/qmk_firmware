   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"usb_device_udd.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.udd_ep_get_job,"ax",%progbits
  18              		.align	1
  19              		.arch armv7e-m
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	udd_ep_get_job:
  26              	.LVL0:
  27              	.LFB144:
  28              		.file 1 "tmk_core/protocol/arm_atsam/usb/usb_device_udd.c"
   1:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
   2:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \file
   3:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   4:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief USB Device wrapper layer for compliance with common driver UDD
   5:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   6:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Copyright (C) 2014-2016 Atmel Corporation. All rights reserved.
   7:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
   8:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \asf_license_start
   9:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  10:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \page License
  11:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  12:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Redistribution and use in source and binary forms, with or without
  13:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * modification, are permitted provided that the following conditions are met:
  14:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  15:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    this list of conditions and the following disclaimer.
  17:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  18:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    and/or other materials provided with the distribution.
  21:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  22:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    from this software without specific prior written permission.
  24:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  25:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * 4. This software may only be redistributed and used in connection with an
  26:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *    Atmel microcontroller product.
  27:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  28:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * POSSIBILITY OF SUCH DAMAGE.
  39:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  40:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \asf_license_stop
  41:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  42:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  43:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /*
  44:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
  45:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  46:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "samd51j18a.h"
  47:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include <string.h>
  48:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include <stdlib.h>
  49:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  50:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Get USB device configuration
  51:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "conf_usb.h"
  52:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "udd.h"
  53:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "usb.h"
  54:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #include "status_codes.h"
  55:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  56:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
  57:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \ingroup usb_device_group
  58:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \defgroup usb_device_udd_group USB Device Driver Implement (UDD)
  59:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * USB low-level driver for USB device mode
  60:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
  61:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  62:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Check USB device configuration
  63:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_HS_SUPPORT
  64:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    error The High speed mode is not supported on this part, please remove USB_DEVICE_HS_SUPPORT i
  65:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  66:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  67:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** // Note: This driver is adapted for SAMD51
  68:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  69:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_REMOTEWAKEUP_LPM_ENABLE
  70:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_REMOTEWAKEUP_LPM_ENABLE()
  71:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  72:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_REMOTEWAKEUP_LPM_DISABLE
  73:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_REMOTEWAKEUP_LPM_DISABLE()
  74:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  75:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef UDC_SUSPEND_LPM_EVENT
  76:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define UDC_SUSPEND_LPM_EVENT()
  77:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  78:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  79:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /* for debug text */
  80:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEBUG
  81:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define dbg_print printf
  82:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #else
  83:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #    define dbg_print(...)
  84:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
  85:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  86:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Maximum size of a transfer in multi-packet mode */
  87:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define UDD_ENDPOINT_MAX_TRANS ((8 * 1024) - 1)
  88:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  89:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** USB software device instance structure */
  90:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** struct usb_module usb_device;
  91:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  92:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
  93:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Clock management
  94:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
  95:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
  96:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
  97:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
  98:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define UDD_CLOCK_GEN 0
  99:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 100:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static inline void udd_wait_clock_ready(void) {}
 101:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 102:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 103:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Power management
 104:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 105:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 106:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 107:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #define udd_sleep_mode(arg)
 108:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 109:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 110:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 111:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Control endpoint low level management routine.
 112:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 113:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * This function performs control endpoint management.
 114:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * It handles the SETUP/DATA/HANDSHAKE phases of a control transaction.
 115:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 116:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 117:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 118:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 119:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 120:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Buffer to store the data received on control endpoint (SETUP/OUT endpoint 0)
 121:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 122:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Used to avoid a RAM buffer overflow in case of the payload buffer
 123:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * is smaller than control endpoint size
 124:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 125:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4)
 126:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint8_t udd_ctrl_buffer[USB_DEVICE_EP_CTRL_SIZE];
 127:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 128:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Bit definitions about endpoint control state machine for udd_ep_control_state */
 129:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** typedef enum {
 130:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_SETUP                  = 0,  //!< Wait a SETUP packet
 131:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_DATA_OUT               = 1,  //!< Wait a OUT data packet
 132:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_DATA_IN                = 2,  //!< Wait a IN data packet
 133:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP  = 3,  //!< Wait a IN ZLP packet
 134:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP = 4,  //!< Wait a OUT ZLP packet
 135:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDD_EPCTRL_STALL_REQ              = 5,  //!< STALL enabled on IN & OUT packet
 136:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** } udd_ctrl_ep_state_t;
 137:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 138:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Global variable to give and record information of the set up request management */
 139:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** udd_ctrl_request_t udd_g_ctrlreq;
 140:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 141:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** State of the endpoint control management */
 142:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ctrl_ep_state_t udd_ep_control_state;
 143:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 144:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Total number of data received/sent during data packet phase with previous payload buffers */
 145:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static uint16_t udd_ctrl_prev_payload_nb_trans;
 146:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 147:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Number of data received/sent to/from udd_g_ctrlreq.payload buffer */
 148:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static uint16_t udd_ctrl_payload_nb_trans;
 149:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 150:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 151:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 152:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 153:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \name Management of bulk/interrupt/isochronous endpoints
 154:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 155:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * The UDD manages the data transfer on endpoints:
 156:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Start data transfer on endpoint with USB Device DMA
 157:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Send a ZLP packet if requested
 158:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * - Call callback registered to signal end of transfer
 159:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * The transfer abort and stall feature are supported.
 160:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 161:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * @{
 162:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 163:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 164:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 165:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Buffer to store the data received on bulk/interrupt endpoints
 166:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 167:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * Used to avoid a RAM buffer overflow in case of the user buffer
 168:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * is smaller than endpoint size
 169:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *
 170:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \warning The protected interrupt endpoint size is 512 bytes maximum.
 171:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \warning The isochronous and endpoint is not protected by this system and
 172:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  *          the user must always use a buffer corresponding at endpoint size.
 173:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 174:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 175:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #if (defined USB_DEVICE_LOW_SPEED)
 176:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][8];
 177:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #elif (defined USB_DEVICE_HS_SUPPORT)
 178:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][512];
 179:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #else
 180:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** UDC_BSS(4) uint8_t udd_ep_out_cache_buffer[USB_DEVICE_MAX_EP][64];
 181:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 182:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 183:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Structure definition about job registered on an endpoint */
 184:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** typedef struct {
 185:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     union {
 186:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         //! Callback to call at the end of transfer
 187:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_callback_trans_t call_trans;
 188:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         //! Callback to call when the endpoint halt is cleared
 189:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_callback_halt_cleared_t call_nohalt;
 190:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     };
 191:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Buffer located in internal RAM to send or fill during job
 192:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t *buf;
 193:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Size of buffer to send or fill
 194:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     iram_size_t buf_size;
 195:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Total number of data transferred on endpoint
 196:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     iram_size_t nb_trans;
 197:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! Endpoint size
 198:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t ep_size;
 199:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! A job is registered on this endpoint
 200:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t busy : 1;
 201:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! A short packet is requested for this job on endpoint IN
 202:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t b_shortpacket : 1;
 203:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //! The cache buffer is currently used on endpoint OUT
 204:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t b_use_out_cache_buffer : 1;
 205:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** } udd_ep_job_t;
 206:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 207:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** Array to register a job on bulk/interrupt/isochronous endpoint */
 208:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ep_job_t udd_ep_job[2 * USB_DEVICE_MAX_EP];
 209:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 210:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /** @} */
 211:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 212:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 213:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Get the detailed job by endpoint number
 214:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] ep  Endpoint Address
 215:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \retval    pointer to an udd_ep_job_t structure instance
 216:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 217:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static udd_ep_job_t *udd_ep_get_job(udd_ep_id_t ep) {
  29              		.loc 1 217 53 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
 218:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((ep == 0) || (ep == 0x80)) {
  34              		.loc 1 218 5 view .LVU1
  35              		.loc 1 218 8 is_stmt 0 view .LVU2
  36 0000 10F07F03 		ands	r3, r0, #127
 219:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return NULL;
 220:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 221:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return &udd_ep_job[(2 * (ep & USB_EP_ADDR_MASK) + ((ep & USB_EP_DIR_IN) ? 1 : 0)) - 2];
  37              		.loc 1 221 9 is_stmt 1 view .LVU3
  38              		.loc 1 221 57 is_stmt 0 view .LVU4
  39 0004 1FBF     		itttt	ne
  40 0006 00F00F03 		andne	r3, r0, #15
  41 000a C009     		lsrne	r0, r0, #7
  42              	.LVL1:
  43              		.loc 1 221 57 view .LVU5
  44 000c 00EB4300 		addne	r0, r0, r3, lsl #1
  45              		.loc 1 221 16 view .LVU6
  46 0010 034A     		ldrne	r2, .L4
  47              		.loc 1 221 91 view .LVU7
  48 0012 1DBF     		ittte	ne
  49 0014 0238     		subne	r0, r0, #2
  50              		.loc 1 221 16 view .LVU8
  51 0016 1423     		movne	r3, #20
  52 0018 03FB0020 		mlane	r0, r3, r0, r2
 219:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return NULL;
  53              		.loc 1 219 16 view .LVU9
  54 001c 1846     		moveq	r0, r3
 222:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 223:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
  55              		.loc 1 223 1 view .LVU10
  56 001e 7047     		bx	lr
  57              	.L5:
  58              		.align	2
  59              	.L4:
  60 0020 00000000 		.word	.LANCHOR0
  61              		.cfi_endproc
  62              	.LFE144:
  64              		.section	.text.udd_ep_transfer_process,"ax",%progbits
  65              		.align	1
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  69              		.fpu fpv4-sp-d16
  71              	udd_ep_transfer_process:
  72              	.LVL2:
  73              	.LFB147:
 224:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 225:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 226:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint IN process, continue to send packets or zero length packet
 227:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 228:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 229:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_trans_in_next(void *pointer) {
 230:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 231:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 232:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 233:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 234:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 235:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 236:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 237:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 238:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 239:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 240:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_size = ptr_job->ep_size;
 241:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 242:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_trans = ep_callback_para->sent_bytes;
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans += nb_trans;
 244:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 245:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Need to send other data */
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans != ptr_job->buf_size) {
 247:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 248:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 249:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum
 250:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * transfer size of UDD_ENDPOINT_MAX_TRANS Bytes */
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ep_size);
 252:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 253:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Need ZLP, if requested and last packet is not a short packet */
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = ptr_job->b_shortpacket && (0 == (next_trans % ep_size));
 255:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 256:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 257:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 258:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 259:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Need to send a ZLP after all data transfer */
 260:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->b_shortpacket) {
 261:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = false;
 262:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Start new transfer */
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 264:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 265:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 266:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 267:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 268:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 270:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 271:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 272:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 273:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 274:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 275:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint OUT process, continue to receive packets or zero length packet
 276:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 277:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 278:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_trans_out_next(void *pointer) {
 279:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 280:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 281:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 282:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 283:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 284:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 285:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 286:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 287:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 288:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 289:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_size = ptr_job->ep_size;
 290:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 291:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_trans = ep_callback_para->received_bytes;
 292:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 293:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Can be necessary to copy data receive from cache buffer to user buffer */
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->b_use_out_cache_buffer) {
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 296:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 297:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 298:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans += nb_trans;
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 301:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 302:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 303:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 304:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* If all previous data requested are received and user buffer not full
 305:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****      * then need to receive other data */
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((nb_trans == ep_callback_para->out_buffer_size) && (ptr_job->nb_trans != ptr_job->buf_size)
 307:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 308:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 309:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum transfer size
 310:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * of UDD_ENDPOINT_MAX_TRANS Bytes */
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ep_size);
 312:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans -= next_trans % ep_size;
 314:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 315:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 316:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (next_trans < ep_size) {
 317:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Use the cache buffer for Bulk or Interrupt size endpoint */
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_use_out_cache_buffer = true;
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 320:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_tran
 322:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 323:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 324:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 325:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 326:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 327:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 330:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 331:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 332:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 333:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 334:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint Transfer Complete callback function, to do the next transfer depends on the 
 335:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 336:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 337:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 338:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ep_transfer_process(struct usb_module *module_inst, void *pointer) {
  74              		.loc 1 338 84 is_stmt 1 view -0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
 339:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
  78              		.loc 1 339 5 view .LVU12
 340:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
  79              		.loc 1 340 5 view .LVU13
 338:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
  80              		.loc 1 338 84 is_stmt 0 view .LVU14
  81 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  82              		.cfi_def_cfa_offset 32
  83              		.cfi_offset 4, -32
  84              		.cfi_offset 5, -28
  85              		.cfi_offset 6, -24
  86              		.cfi_offset 7, -20
  87              		.cfi_offset 8, -16
  88              		.cfi_offset 9, -12
  89              		.cfi_offset 10, -8
  90              		.cfi_offset 14, -4
  91              		.loc 1 340 45 view .LVU15
  92 0004 8F79     		ldrb	r7, [r1, #6]	@ zero_extendqisi2
  93              	.LVL3:
 341:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 342:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep & USB_EP_DIR_IN) {
  94              		.loc 1 342 5 is_stmt 1 view .LVU16
  95 0006 3846     		mov	r0, r7
  96              	.LVL4:
 338:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
  97              		.loc 1 338 84 is_stmt 0 view .LVU17
  98 0008 8846     		mov	r8, r1
  99 000a FFF7FEFF 		bl	udd_ep_get_job
 100              	.LVL5:
 101              		.loc 1 342 8 view .LVU18
 102 000e 3A06     		lsls	r2, r7, #24
 103 0010 0446     		mov	r4, r0
 104 0012 068A     		ldrh	r6, [r0, #16]
 105 0014 90F812C0 		ldrb	ip, [r0, #18]	@ zero_extendqisi2
 106 0018 07F00F05 		and	r5, r7, #15
 107 001c D0E90230 		ldrd	r3, r0, [r0, #8]
 108 0020 3BD5     		bpl	.L7
 343:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_trans_in_next(pointer);
 109              		.loc 1 343 9 is_stmt 1 view .LVU19
 110              	.LVL6:
 111              	.LBB64:
 112              	.LBI64:
 229:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 113              		.loc 1 229 13 view .LVU20
 114              	.LBB65:
 230:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 115              		.loc 1 230 5 view .LVU21
 231:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 116              		.loc 1 231 5 view .LVU22
 232:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 117              		.loc 1 232 5 view .LVU23
 233:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 118              		.loc 1 233 5 view .LVU24
 234:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 119              		.loc 1 234 5 view .LVU25
 235:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 120              		.loc 1 235 5 view .LVU26
 237:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 121              		.loc 1 237 5 view .LVU27
 238:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 122              		.loc 1 238 5 view .LVU28
 240:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 123              		.loc 1 240 5 view .LVU29
 242:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans += nb_trans;
 124              		.loc 1 242 5 view .LVU30
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 125              		.loc 1 243 5 view .LVU31
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 126              		.loc 1 243 23 is_stmt 0 view .LVU32
 127 0022 4988     		ldrh	r1, [r1, #2]
 128              	.LVL7:
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 129              		.loc 1 243 23 view .LVU33
 130 0024 0144     		add	r1, r1, r0
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 131              		.loc 1 246 8 view .LVU34
 132 0026 9942     		cmp	r1, r3
 243:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 133              		.loc 1 243 23 view .LVU35
 134 0028 E160     		str	r1, [r4, #12]
 135              	.LVL8:
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 136              		.loc 1 246 5 is_stmt 1 view .LVU36
 137 002a 0CF00200 		and	r0, ip, #2
 246:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 138              		.loc 1 246 8 is_stmt 0 view .LVU37
 139 002e 21D0     		beq	.L8
 247:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 140              		.loc 1 247 9 is_stmt 1 view .LVU38
 247:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 141              		.loc 1 247 20 is_stmt 0 view .LVU39
 142 0030 5B1A     		subs	r3, r3, r1
 143 0032 9BB2     		uxth	r3, r3
 144              	.LVL9:
 248:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum
 145              		.loc 1 248 9 is_stmt 1 view .LVU40
 248:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum
 146              		.loc 1 248 12 is_stmt 0 view .LVU41
 147 0034 B3F5005F 		cmp	r3, #8192
 148 0038 07D3     		bcc	.L9
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 149              		.loc 1 251 13 is_stmt 1 view .LVU42
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 150              		.loc 1 251 75 is_stmt 0 view .LVU43
 151 003a 41F6FF73 		movw	r3, #8191
 152              	.LVL10:
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 153              		.loc 1 251 75 view .LVU44
 154 003e B3FBF6F2 		udiv	r2, r3, r6
 155 0042 06FB1232 		mls	r2, r6, r2, r3
 251:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 156              		.loc 1 251 24 view .LVU45
 157 0046 9B1A     		subs	r3, r3, r2
 158 0048 9BB2     		uxth	r3, r3
 159              	.LVL11:
 160              	.L9:
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 161              		.loc 1 254 9 is_stmt 1 view .LVU46
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 162              		.loc 1 254 57 is_stmt 0 view .LVU47
 163 004a 38B1     		cbz	r0, .L10
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 164              		.loc 1 254 63 view .LVU48
 165 004c B3FBF6F0 		udiv	r0, r3, r6
 166 0050 06FB1030 		mls	r0, r6, r0, r3
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 167              		.loc 1 254 57 view .LVU49
 168 0054 80B2     		uxth	r0, r0
 169 0056 B0FA80F0 		clz	r0, r0
 170 005a 4009     		lsrs	r0, r0, #5
 171              	.L10:
 254:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->buf[ptr_job->nb_trans],
 172              		.loc 1 254 32 view .LVU50
 173 005c A27C     		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 174 005e 60F34102 		bfi	r2, r0, #1, #1
 175 0062 A274     		strb	r2, [r4, #18]
 255:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 176              		.loc 1 255 9 is_stmt 1 view .LVU51
 177 0064 6268     		ldr	r2, [r4, #4]
 178              	.LVL12:
 179              	.L28:
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 180              		.loc 1 263 9 is_stmt 0 view .LVU52
 181 0066 3248     		ldr	r0, .L31
 182 0068 0A44     		add	r2, r2, r1
 183 006a 2946     		mov	r1, r5
 184              	.LBE65:
 185              	.LBE64:
 344:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 345:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_trans_out_next(pointer);
 346:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 347:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 186              		.loc 1 347 1 view .LVU53
 187 006c BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 188              		.cfi_remember_state
 189              		.cfi_restore 14
 190              		.cfi_restore 10
 191              		.cfi_restore 9
 192              		.cfi_restore 8
 193              		.cfi_restore 7
 194              		.cfi_restore 6
 195              		.cfi_restore 5
 196              		.cfi_restore 4
 197              		.cfi_def_cfa_offset 0
 198              	.LVL13:
 199              	.LBB67:
 200              	.LBB66:
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 201              		.loc 1 263 9 view .LVU54
 202 0070 FFF7FEBF 		b	usb_device_endpoint_write_buffer_job
 203              	.LVL14:
 204              	.L8:
 205              		.cfi_restore_state
 260:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = false;
 206              		.loc 1 260 5 is_stmt 1 view .LVU55
 260:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->b_shortpacket = false;
 207              		.loc 1 260 8 is_stmt 0 view .LVU56
 208 0074 30B1     		cbz	r0, .L11
 261:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Start new transfer */
 209              		.loc 1 261 9 is_stmt 1 view .LVU57
 261:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Start new transfer */
 210              		.loc 1 261 32 is_stmt 0 view .LVU58
 211 0076 6FF3410C 		bfc	ip, #1, #1
 212 007a 84F812C0 		strb	ip, [r4, #18]
 263:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 213              		.loc 1 263 9 is_stmt 1 view .LVU59
 214 007e 6268     		ldr	r2, [r4, #4]
 215 0080 0023     		movs	r3, #0
 216 0082 F0E7     		b	.L28
 217              	.L11:
 268:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 218              		.loc 1 268 5 view .LVU60
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 219              		.loc 1 269 24 is_stmt 0 view .LVU61
 220 0084 2368     		ldr	r3, [r4]
 268:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 221              		.loc 1 268 19 view .LVU62
 222 0086 60F3000C 		bfi	ip, r0, #0, #1
 223 008a 84F812C0 		strb	ip, [r4, #18]
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 224              		.loc 1 269 5 is_stmt 1 view .LVU63
 269:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 225              		.loc 1 269 8 is_stmt 0 view .LVU64
 226 008e 002B     		cmp	r3, #0
 227 0090 4CD0     		beq	.L6
 270:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 228              		.loc 1 270 9 is_stmt 1 view .LVU65
 229 0092 3A46     		mov	r2, r7
 230              	.LVL15:
 231              	.L29:
 270:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 232              		.loc 1 270 9 is_stmt 0 view .LVU66
 233              	.LBE66:
 234              	.LBE67:
 235              		.loc 1 347 1 view .LVU67
 236 0094 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 237              		.cfi_remember_state
 238              		.cfi_restore 14
 239              		.cfi_restore 10
 240              		.cfi_restore 9
 241              		.cfi_restore 8
 242              		.cfi_restore 7
 243              		.cfi_restore 6
 244              		.cfi_restore 5
 245              		.cfi_restore 4
 246              		.cfi_def_cfa_offset 0
 247              	.LVL16:
 248              	.LBB68:
 249              	.LBB69:
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 250              		.loc 1 329 9 view .LVU68
 251 0098 1847     		bx	r3	@ indirect register sibling call
 252              	.LVL17:
 253              	.L7:
 254              		.cfi_restore_state
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 255              		.loc 1 329 9 view .LVU69
 256              	.LBE69:
 257              	.LBE68:
 345:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 258              		.loc 1 345 9 is_stmt 1 view .LVU70
 259              	.LBB72:
 260              	.LBI68:
 278:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 261              		.loc 1 278 13 view .LVU71
 262              	.LBB70:
 279:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep               = ep_callback_para->endpoint_address;
 263              		.loc 1 279 5 view .LVU72
 280:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                ep_size, nb_trans;
 264              		.loc 1 280 5 view .LVU73
 281:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t                                next_trans;
 265              		.loc 1 281 5 view .LVU74
 282:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t                             ep_num;
 266              		.loc 1 282 5 view .LVU75
 283:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *                          ptr_job;
 267              		.loc 1 283 5 view .LVU76
 284:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 268              		.loc 1 284 5 view .LVU77
 286:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num  = ep & USB_EP_ADDR_MASK;
 269              		.loc 1 286 5 view .LVU78
 287:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 270              		.loc 1 287 5 view .LVU79
 289:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Update number of data transferred */
 271              		.loc 1 289 5 view .LVU80
 291:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 272              		.loc 1 291 5 view .LVU81
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 273              		.loc 1 294 8 is_stmt 0 view .LVU82
 274 009a 1CF0040F 		tst	ip, #4
 291:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 275              		.loc 1 291 14 view .LVU83
 276 009e B1F80090 		ldrh	r9, [r1]
 277              	.LVL18:
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 278              		.loc 1 294 5 is_stmt 1 view .LVU84
 294:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         memcpy(&ptr_job->buf[ptr_job->nb_trans], udd_ep_out_cache_buffer[ep_num - 1], ptr_job->buf_
 279              		.loc 1 294 8 is_stmt 0 view .LVU85
 280 00a2 0BD0     		beq	.L14
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 281              		.loc 1 295 9 is_stmt 1 view .LVU86
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 282              		.loc 1 295 105 is_stmt 0 view .LVU87
 283 00a4 B3FBF6F2 		udiv	r2, r3, r6
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 284              		.loc 1 295 9 view .LVU88
 285 00a8 06FB1232 		mls	r2, r6, r2, r3
 286 00ac 214B     		ldr	r3, .L31+4
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 287              		.loc 1 295 81 view .LVU89
 288 00ae 691E     		subs	r1, r5, #1
 289              	.LVL19:
 295:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 290              		.loc 1 295 9 view .LVU90
 291 00b0 03EB8111 		add	r1, r3, r1, lsl #6
 292 00b4 6368     		ldr	r3, [r4, #4]
 293 00b6 1844     		add	r0, r0, r3
 294 00b8 FFF7FEFF 		bl	memcpy
 295              	.LVL20:
 296              	.L14:
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 297              		.loc 1 299 5 is_stmt 1 view .LVU91
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 298              		.loc 1 299 23 is_stmt 0 view .LVU92
 299 00bc E268     		ldr	r2, [r4, #12]
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 300              		.loc 1 300 36 view .LVU93
 301 00be A168     		ldr	r1, [r4, #8]
 299:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->nb_trans > ptr_job->buf_size) {
 302              		.loc 1 299 23 view .LVU94
 303 00c0 4A44     		add	r2, r2, r9
 300:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->nb_trans = ptr_job->buf_size;
 304              		.loc 1 300 5 is_stmt 1 view .LVU95
 301:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 305              		.loc 1 301 27 is_stmt 0 view .LVU96
 306 00c2 8A42     		cmp	r2, r1
 307 00c4 28BF     		it	cs
 308 00c6 0A46     		movcs	r2, r1
 309 00c8 E260     		str	r2, [r4, #12]
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 310              		.loc 1 306 5 is_stmt 1 view .LVU97
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 311              		.loc 1 306 8 is_stmt 0 view .LVU98
 312 00ca B8F80430 		ldrh	r3, [r8, #4]
 313 00ce 4B45     		cmp	r3, r9
 314 00d0 22D1     		bne	.L16
 306:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         next_trans = ptr_job->buf_size - ptr_job->nb_trans;
 315              		.loc 1 306 57 view .LVU99
 316 00d2 9142     		cmp	r1, r2
 317 00d4 20D0     		beq	.L16
 307:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 318              		.loc 1 307 9 is_stmt 1 view .LVU100
 307:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 319              		.loc 1 307 20 is_stmt 0 view .LVU101
 320 00d6 891A     		subs	r1, r1, r2
 321 00d8 89B2     		uxth	r1, r1
 322              	.LVL21:
 308:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum transfer size
 323              		.loc 1 308 9 is_stmt 1 view .LVU102
 308:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* The USB hardware support a maximum transfer size
 324              		.loc 1 308 12 is_stmt 0 view .LVU103
 325 00da B1F5005F 		cmp	r1, #8192
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 326              		.loc 1 311 13 is_stmt 1 view .LVU104
 311:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 327              		.loc 1 311 75 is_stmt 0 view .LVU105
 328 00de 28BF     		it	cs
 329 00e0 41F6FF71 		movwcs	r1, #8191
 330              	.LVL22:
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 331              		.loc 1 313 13 is_stmt 1 view .LVU106
 313:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 332              		.loc 1 313 24 is_stmt 0 view .LVU107
 333 00e4 B1FBF6F3 		udiv	r3, r1, r6
 334 00e8 06FB1313 		mls	r3, r6, r3, r1
 335 00ec C91A     		subs	r1, r1, r3
 336 00ee 8BB2     		uxth	r3, r1
 337              	.LVL23:
 316:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Use the cache buffer for Bulk or Interrupt size endpoint */
 338              		.loc 1 316 9 is_stmt 1 view .LVU108
 316:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Use the cache buffer for Bulk or Interrupt size endpoint */
 339              		.loc 1 316 12 is_stmt 0 view .LVU109
 340 00f0 B342     		cmp	r3, r6
 341 00f2 0ED2     		bcs	.L19
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 342              		.loc 1 318 13 is_stmt 1 view .LVU110
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 343              		.loc 1 318 45 is_stmt 0 view .LVU111
 344 00f4 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 345              	.LVL24:
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 346              		.loc 1 319 13 view .LVU112
 347 00f6 0F4A     		ldr	r2, .L31+4
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 348              		.loc 1 318 45 view .LVU113
 349 00f8 43F00403 		orr	r3, r3, #4
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 350              		.loc 1 319 101 view .LVU114
 351 00fc 691E     		subs	r1, r5, #1
 352              	.LVL25:
 318:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_ep_out_cache_buffer[ep_num
 353              		.loc 1 318 45 view .LVU115
 354 00fe A374     		strb	r3, [r4, #18]
 319:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 355              		.loc 1 319 13 is_stmt 1 view .LVU116
 356 0100 02EB8112 		add	r2, r2, r1, lsl #6
 357 0104 3346     		mov	r3, r6
 358              	.L30:
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 359              		.loc 1 321 13 is_stmt 0 view .LVU117
 360 0106 2946     		mov	r1, r5
 361 0108 0948     		ldr	r0, .L31
 362              	.LBE70:
 363              	.LBE72:
 364              		.loc 1 347 1 view .LVU118
 365 010a BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 366              		.cfi_remember_state
 367              		.cfi_restore 14
 368              		.cfi_restore 10
 369              		.cfi_restore 9
 370              		.cfi_restore 8
 371              		.cfi_restore 7
 372              		.cfi_restore 6
 373              		.cfi_restore 5
 374              		.cfi_restore 4
 375              		.cfi_def_cfa_offset 0
 376              	.LVL26:
 377              	.LBB73:
 378              	.LBB71:
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 379              		.loc 1 321 13 view .LVU119
 380 010e FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 381              	.LVL27:
 382              	.L19:
 383              		.cfi_restore_state
 321:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 384              		.loc 1 321 13 is_stmt 1 view .LVU120
 385 0112 6068     		ldr	r0, [r4, #4]
 386 0114 0244     		add	r2, r2, r0
 387 0116 F6E7     		b	.L30
 388              	.LVL28:
 389              	.L16:
 327:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 390              		.loc 1 327 5 view .LVU121
 327:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 391              		.loc 1 327 19 is_stmt 0 view .LVU122
 392 0118 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 393 011a 6FF30003 		bfc	r3, #0, #1
 394 011e A374     		strb	r3, [r4, #18]
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 395              		.loc 1 328 5 is_stmt 1 view .LVU123
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 396              		.loc 1 328 24 is_stmt 0 view .LVU124
 397 0120 2368     		ldr	r3, [r4]
 328:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_OK, ptr_job->nb_trans, ep);
 398              		.loc 1 328 8 view .LVU125
 399 0122 1BB1     		cbz	r3, .L6
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 400              		.loc 1 329 9 is_stmt 1 view .LVU126
 401 0124 3A46     		mov	r2, r7
 402 0126 E168     		ldr	r1, [r4, #12]
 403 0128 0020     		movs	r0, #0
 404 012a B3E7     		b	.L29
 405              	.LVL29:
 406              	.L6:
 329:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 407              		.loc 1 329 9 is_stmt 0 view .LVU127
 408              	.LBE71:
 409              	.LBE73:
 410              		.loc 1 347 1 view .LVU128
 411 012c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 412              	.LVL30:
 413              	.L32:
 414              		.loc 1 347 1 view .LVU129
 415              		.align	2
 416              	.L31:
 417 0130 00000000 		.word	usb_device
 418 0134 00000000 		.word	udd_ep_out_cache_buffer
 419              		.cfi_endproc
 420              	.LFE147:
 422              		.section	.text.udd_ctrl_stall_data,"ax",%progbits
 423              		.align	1
 424              		.syntax unified
 425              		.thumb
 426              		.thumb_func
 427              		.fpu fpv4-sp-d16
 429              	udd_ctrl_stall_data:
 430              	.LFB158:
 348:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_ep_abort(udd_ep_id_t ep) {
 350:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 351:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_abort_job(&usb_device, ep);
 353:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 354:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Job complete then call callback */
 355:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!ptr_job->busy) {
 357:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 358:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 359:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = false;
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 361:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_trans(UDD_EP_TRANSFER_ABORT, ptr_job->nb_trans, ep);
 363:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 365:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_is_high_speed(void) { return false; }
 367:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint16_t udd_get_frame_number(void) { return usb_device_get_frame_number(&usb_device); }
 369:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint16_t udd_get_micro_frame_number(void) { return usb_device_get_micro_frame_number(&usb_device); 
 371:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_ep_free(udd_ep_id_t ep) {
 373:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 375:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 376:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 377:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_abort(ep);
 378:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 379:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_address = ep;
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_type    = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 382:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 383:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_disable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 384:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 385:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes, uint16_t MaxEndpointSize) {
 387:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 389:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 390:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_address = ep;
 391:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (MaxEndpointSize <= 8) {
 393:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 394:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 16) {
 395:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_16_BYTE;
 396:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 32) {
 397:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_32_BYTE;
 398:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 64) {
 399:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_64_BYTE;
 400:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 128) {
 401:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_128_BYTE;
 402:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 256) {
 403:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_256_BYTE;
 404:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 512) {
 405:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_512_BYTE;
 406:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 1023) {
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
 408:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 409:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 410:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job = udd_ep_get_job(ep);
 412:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 413:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 414:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     bmAttributes = bmAttributes & USB_EP_TYPE_MASK;
 415:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 416:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Check endpoint type */
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_EP_TYPE_ISOCHRONOUS == bmAttributes) {
 418:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 419:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_BULK == bmAttributes) {
 420:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
 421:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
 423:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 424:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 425:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 426:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 427:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 428:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (STATUS_OK != usb_device_endpoint_set_config(&usb_device, &config_ep)) {
 430:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 431:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 432:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, 
 433:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 434:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 435:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 436:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 437:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 438:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_is_halted(udd_ep_id_t ep) { return usb_device_endpoint_is_halted(&usb_device, ep); }
 440:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_set_halt(udd_ep_id_t ep) {
 442:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 443:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 445:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 446:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 447:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 448:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_halt(&usb_device, ep);
 449:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 450:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_abort(ep);
 451:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 452:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 453:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_clear_halt(udd_ep_id_t ep) {
 455:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 456:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t       ep_num = ep & USB_EP_ADDR_MASK;
 457:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 459:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 460:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 462:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 463:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, ep);
 464:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 465:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* If a job is register on clear halt action then execute callback */
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 467:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 468:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt();
 469:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 470:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 471:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 472:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 473:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_wait_stall_clear(udd_ep_id_t ep, udd_callback_halt_cleared_t callback) {
 475:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 476:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 477:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 478:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num = ep & USB_EP_ADDR_MASK;
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 480:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 481:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 482:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 485:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 486:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 487:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 488:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Wait clear halt endpoint */
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (usb_device_endpoint_is_halted(&usb_device, ep)) {
 490:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy        = true;
 492:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 493:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (usb_device_endpoint_is_configured(&usb_device, ep)) {
 495:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 496:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 497:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 498:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 499:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 500:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 501:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 502:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 503:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint stall sending data
 504:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 505:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_stall_data(void) {
 431              		.loc 1 505 39 is_stmt 1 view -0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 435              		.loc 1 506 5 view .LVU131
 505:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 436              		.loc 1 505 39 is_stmt 0 view .LVU132
 437 0000 10B5     		push	{r4, lr}
 438              		.cfi_def_cfa_offset 8
 439              		.cfi_offset 4, -8
 440              		.cfi_offset 14, -4
 507:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 508:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_halt(&usb_device, USB_EP_DIR_IN);
 441              		.loc 1 508 5 view .LVU133
 442 0002 074C     		ldr	r4, .L34
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 443              		.loc 1 506 26 view .LVU134
 444 0004 074B     		ldr	r3, .L34+4
 445              		.loc 1 508 5 view .LVU135
 446 0006 2046     		mov	r0, r4
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 447              		.loc 1 506 26 view .LVU136
 448 0008 0522     		movs	r2, #5
 449              		.loc 1 508 5 view .LVU137
 450 000a 8021     		movs	r1, #128
 506:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 451              		.loc 1 506 26 view .LVU138
 452 000c 83F8A020 		strb	r2, [r3, #160]
 453              		.loc 1 508 5 is_stmt 1 view .LVU139
 454 0010 FFF7FEFF 		bl	usb_device_endpoint_set_halt
 455              	.LVL31:
 509:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, USB_EP_DIR_OUT);
 456              		.loc 1 509 5 view .LVU140
 457 0014 2046     		mov	r0, r4
 458 0016 0021     		movs	r1, #0
 510:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 459              		.loc 1 510 1 is_stmt 0 view .LVU141
 460 0018 BDE81040 		pop	{r4, lr}
 461              		.cfi_restore 14
 462              		.cfi_restore 4
 463              		.cfi_def_cfa_offset 0
 509:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_clear_halt(&usb_device, USB_EP_DIR_OUT);
 464              		.loc 1 509 5 view .LVU142
 465 001c FFF7FEBF 		b	usb_device_endpoint_clear_halt
 466              	.LVL32:
 467              	.L35:
 468              		.align	2
 469              	.L34:
 470 0020 00000000 		.word	usb_device
 471 0024 00000000 		.word	.LANCHOR0
 472              		.cfi_endproc
 473              	.LFE158:
 475              		.section	.text._usb_on_wakeup,"ax",%progbits
 476              		.align	1
 477              		.syntax unified
 478              		.thumb
 479              		.thumb_func
 480              		.fpu fpv4-sp-d16
 482              	_usb_on_wakeup:
 483              	.LVL33:
 484              	.LFB177:
 511:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket, uint8_t *buf, iram_size_t buf_size, udd_callbac
 513:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 514:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 515:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t      irqflags;
 516:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 517:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ep_num = ep & USB_EP_ADDR_MASK;
 518:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((USB_DEVICE_MAX_EP < ep_num) || (udd_ep_is_halted(ep))) {
 520:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 521:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 522:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 523:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job = udd_ep_get_job(ep);
 524:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 525:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     irqflags = __get_PRIMASK();
 526:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __disable_irq();
 527:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 528:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 530:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 531:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __set_PRIMASK(irqflags);
 532:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 533:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 534:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 535:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->busy = true;
 536:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 537:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __set_PRIMASK(irqflags);
 538:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 539:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* No job running, set up a new one */
 540:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->buf                    = buf;
 541:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->buf_size               = buf_size;
 542:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans               = 0;
 543:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->call_trans             = callback;
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_shortpacket          = b_shortpacket;
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 546:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 547:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Initialize value to simulate a empty transfer */
 548:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t next_trans;
 549:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep & USB_EP_DIR_IN) {
 551:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 552:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 553:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 555:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = ptr_job->b_shortpacket && (0 == (next_trans % ptr_job->ep_size
 557:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 558:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
 559:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans             = 0;
 560:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 561:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->busy = false;
 562:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 564:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 565:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return true;
 566:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return (STATUS_OK == usb_device_endpoint_write_buffer_job(&usb_device, ep_num, &ptr_job->bu
 568:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 569:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 570:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 571:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 572:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* The USB hardware support a maximum transfer size
 573:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                  * of UDD_ENDPOINT_MAX_TRANS Bytes */
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 575:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans -= next_trans % ptr_job->ep_size;
 577:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 578:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (next_trans < ptr_job->ep_size) {
 579:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->b_use_out_cache_buffer = true;
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_e
 581:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, &ptr_
 583:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 584:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 585:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->busy = false;
 586:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 587:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 588:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 589:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return true;
 590:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 591:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 592:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 593:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_set_address(uint8_t address) { usb_device_set_address(&usb_device, address); }
 595:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** uint8_t udd_getaddress(void) { return usb_device_get_address(&usb_device); }
 597:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 598:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_send_remotewakeup(void) {
 599:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t try
 600:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         = 5;
 601:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 602:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     while (2 != usb_get_state_machine_status(&usb_device) && try --) {
 604:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 605:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 606:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 607:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 608:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_set_setup_payload(uint8_t *payload, uint16_t payload_size) {
 609:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload      = payload;
 610:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload_size = payload_size;
 611:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 612:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 613:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 614:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint translate the data in buffer into Device Request Struct
 615:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 616:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_fetch_ram(void) {
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bmRequestType = udd_ctrl_buffer[0];
 618:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wValue        = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 622:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 623:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 624:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 625:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint send out zero length packet
 626:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 627:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_send_zlp_in(void) {
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 631:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 632:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 633:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 634:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Process control endpoint IN transaction
 635:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 636:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_in_sent(void) {
 637:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     static bool b_shortpacket = false;
 638:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t    nb_remain;
 639:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
 641:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 642:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (0 == nb_remain) {
 643:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* All content of current buffer payload are sent Update number of total data sending by pr
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 646:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 647:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Generate an OUT ZLP for handshake phase */
 648:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 650:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 651:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 652:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Need of new buffer because the data phase is not complete */
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((!udd_g_ctrlreq.over_under_run) || (!udd_g_ctrlreq.over_under_run())) {
 654:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 655:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Here nb_remain=0, this allows to send a IN ZLP */
 656:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 657:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* A new payload buffer is given */
 658:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans = 0;
 659:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             nb_remain                 = udd_g_ctrlreq.payload_size;
 660:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 661:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 662:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 663:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Continue transfer and send next data */
 664:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
 665:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_remain     = USB_DEVICE_EP_CTRL_SIZE;
 666:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = false;
 667:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 668:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = true;
 669:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 670:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 671:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Link payload buffer directly on USB hardware */
 672:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload + udd_ctrl_payload_n
 673:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_remain;
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 676:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 677:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 678:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Process control endpoint OUT transaction
 679:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 680:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 681:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_out_received(void *pointer) {
 682:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 683:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 684:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t nb_data;
 685:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_data = ep_callback_para->received_bytes; /* Read data received during OUT phase */
 686:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
 688:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
 690:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 691:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     memcpy((uint8_t *)(udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans), udd_ctrl_buffer, nb_data
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 694:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((USB_DEVICE_EP_CTRL_SIZE != nb_data) || (udd_g_ctrlreq.req.wLength <= (udd_ctrl_prev_payloa
 696:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 697:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * or all data are transferred */
 698:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 699:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Before send ZLP, call intermediate callback
 700:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * in case of data receive generate a stall */
 701:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.over_under_run) {
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 704:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 705:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 706:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall all packets on IN & OUT control endpoint */
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_set_halt(0);
 708:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 709:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 710:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 711:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 712:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Send IN ZLP to ACK setup request */
 713:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_send_zlp_in();
 714:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 715:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 716:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 717:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
 718:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Overrun then request a new payload buffer */
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (!udd_g_ctrlreq.over_under_run) {
 720:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 721:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Stall ZLP */
 722:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 723:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Stall all packets on IN & OUT control endpoint */
 724:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_set_halt(0);
 725:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 726:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (!udd_g_ctrlreq.over_under_run()) {
 728:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 729:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****              * Stall ZLP */
 730:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
 731:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Stall all packets on IN & OUT control endpoint */
 732:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_set_halt(0);
 733:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 734:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 735:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* New payload buffer available
 736:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * Update number of total data received */
 737:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
 738:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 739:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Reinitialize reception on payload buffer */
 740:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_payload_nb_trans = 0;
 741:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL_SIZE);
 743:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 744:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 745:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 746:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 747:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief     Endpoint 0 (control) SETUP received callback
 748:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst pointer to USB module instance
 749:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 750:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_setup(struct usb_module *module_inst, void *pointer) {
 752:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 753:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 756:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 757:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 758:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_SETUP;
 759:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 760:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (8 != ep_callback_para->received_bytes) {
 761:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_stall_data();
 762:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 763:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 764:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_fetch_ram();
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (false == udc_process_setup()) {
 766:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 767:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 768:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (Udd_setup_is_in()) {
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_prev_payload_nb_trans = 0;
 770:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state           = UDD_EPCTRL_DATA_IN;
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 773:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 774:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 775:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (0 == udd_g_ctrlreq.req.wLength) {
 776:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_send_zlp_in();
 777:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 778:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_prev_payload_nb_trans = 0;
 780:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 781:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state           = UDD_EPCTRL_DATA_OUT;
 782:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Initialize buffer size and enable OUT bank */
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_
 784:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 785:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 786:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 788:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 789:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 790:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint Process when underflow condition has occurred
 791:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 792:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 793:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_underflow(void *pointer) {
 794:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 795:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 796:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
 797:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop OUT transaction
 798:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * then stop to wait OUT data phase and wait IN ZLP handshake */
 799:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_send_zlp_in();
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
 801:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 802:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * but host want extra IN data then stall extra IN data */
 803:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
 804:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 805:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 806:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 807:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 808:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control Endpoint Process when overflow condition has occurred
 809:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 810:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 811:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_overflow(void *pointer) {
 812:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 813:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 814:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) {
 815:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop IN transaction
 816:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * then stop to wait IN data phase and wait OUT ZLP handshake */
 817:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
 819:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 820:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****          * but host want extra OUT data then stall extra OUT data and following status stage */
 821:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_endpoint_set_halt(&usb_device, ep_callback_para->endpoint_address);
 822:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 823:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 824:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 825:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 826:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 827:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint transfer fail callback function
 828:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 829:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 830:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 831:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_tansfer_fail(struct usb_module *module_inst, void *pointer) {
 832:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 833:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ep_callback_para->endpoint_address & USB_EP_DIR_IN) {
 835:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 836:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 837:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_overflow(pointer);
 838:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 839:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 840:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 841:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 842:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 843:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint transfer complete callback function
 844:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 845:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the endpoint transfer status parameter struct from driver layer.
 846:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 847:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_ep0_on_tansfer_ok(struct usb_module *module_inst, void *pointer) {
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) { /* handshake Out for status stage */
 849:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 850:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) { /* handshake In for status stage */
 851:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_in_sent();
 852:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 854:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 855:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 856:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ep_control_state = UDD_EPCTRL_SETUP;
 857:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 859:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 860:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 861:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Enable Control Endpoint
 862:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 863:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 864:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void udd_ctrl_ep_enable(struct usb_module *module_inst) {
 865:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Device Endpoint0 Configuration */
 866:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep0;
 867:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep0);
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 871:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 872:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(module_inst, udd_ctrl_buffer);
 873:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 874:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP, _usb_
 875:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, _usb_
 876:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL, _usb
 877:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP);
 878:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 879:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 880:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 881:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 882:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Enable LPM feature
 883:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_lpm_mode(module_inst, USB_DEVICE_LPM_ACK);
 884:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 885:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_SETUP;
 887:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 888:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 889:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 890:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 891:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Suspend callback function
 892:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 893:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 894:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 895:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_suspend(struct usb_module *module_inst, void *pointer) {
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 897:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 898:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 899:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SUSPEND_EVENT
 900:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SUSPEND_EVENT();
 901:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 902:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 903:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 904:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 905:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_device_lpm_suspend(struct usb_module *module_inst, void *pointer) {
 906:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     dbg_print("LPM_SUSP\n");
 907:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 908:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t *lpm_wakeup_enable;
 909:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     lpm_wakeup_enable = (uint32_t *)pointer;
 910:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 911:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 912:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 913:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 914:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 915:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     //#warning Here the sleep mode must be choose to have a DFLL startup time < bmAttribut.HIRD
 916:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND_LPM);  // Enter in LPM SUSPEND mode
 917:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if ((*lpm_wakeup_enable)) {
 918:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         UDC_REMOTEWAKEUP_LPM_ENABLE();
 919:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 920:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!(*lpm_wakeup_enable)) {
 921:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         UDC_REMOTEWAKEUP_LPM_DISABLE();
 922:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 923:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SUSPEND_LPM_EVENT();
 924:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 925:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 926:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 927:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 928:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 929:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint SOF callback function
 930:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 931:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 932:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 933:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_sof_notify(struct usb_module *module_inst, void *pointer) {
 934:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_sof_notify();
 935:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SOF_EVENT
 936:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_SOF_EVENT();
 937:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 938:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 939:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 940:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 941:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 942:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Reset callback function
 943:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 944:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 945:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_bus_reset(struct usb_module *module_inst, void *pointer) {
 947:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 948:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_reset();
 949:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_address(module_inst, 0);
 950:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_ep_enable(module_inst);
 951:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 952:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 953:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** /**
 954:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \internal
 955:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \brief Control endpoint Wakeup callback function
 956:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] module_inst Pointer to USB module instance
 957:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  * \param[in] pointer Pointer to the callback parameter from driver layer.
 958:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****  */
 959:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** static void _usb_on_wakeup(struct usb_module *module_inst, void *pointer) {
 485              		.loc 1 959 75 is_stmt 1 view -0
 486              		.cfi_startproc
 487              		@ args = 0, pretend = 0, frame = 0
 488              		@ frame_needed = 0, uses_anonymous_args = 0
 960:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 489              		.loc 1 960 5 view .LVU144
 100:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 490              		.loc 1 100 48 view .LVU145
 961:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 962:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 491              		.loc 1 962 5 view .LVU146
 959:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 492              		.loc 1 959 75 is_stmt 0 view .LVU147
 493 0000 10B5     		push	{r4, lr}
 494              		.cfi_def_cfa_offset 8
 495              		.cfi_offset 4, -8
 496              		.cfi_offset 14, -4
 497              		.loc 1 962 5 view .LVU148
 498 0002 064C     		ldr	r4, .L37
 499 0004 0221     		movs	r1, #2
 500              	.LVL34:
 501              		.loc 1 962 5 view .LVU149
 502 0006 2046     		mov	r0, r4
 503              	.LVL35:
 504              		.loc 1 962 5 view .LVU150
 505 0008 FFF7FEFF 		bl	usb_device_disable_callback
 506              	.LVL36:
 963:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 507              		.loc 1 963 5 is_stmt 1 view .LVU151
 508 000c 2046     		mov	r0, r4
 509 000e 0421     		movs	r1, #4
 510 0010 FFF7FEFF 		bl	usb_device_enable_callback
 511              	.LVL37:
 964:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 965:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend)
 966:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 967:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 968:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 512              		.loc 1 968 35 view .LVU152
 969:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_RESUME_EVENT
 970:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     UDC_RESUME_EVENT();
 513              		.loc 1 970 5 view .LVU153
 971:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 972:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 514              		.loc 1 972 1 is_stmt 0 view .LVU154
 515 0014 BDE81040 		pop	{r4, lr}
 516              		.cfi_restore 14
 517              		.cfi_restore 4
 518              		.cfi_def_cfa_offset 0
 970:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 519              		.loc 1 970 5 view .LVU155
 520 0018 FFF7FEBF 		b	main_resume_action
 521              	.LVL38:
 522              	.L38:
 523              		.align	2
 524              	.L37:
 525 001c 00000000 		.word	usb_device
 526              		.cfi_endproc
 527              	.LFE177:
 529              		.section	.text._usb_on_bus_reset,"ax",%progbits
 530              		.align	1
 531              		.syntax unified
 532              		.thumb
 533              		.thumb_func
 534              		.fpu fpv4-sp-d16
 536              	_usb_on_bus_reset:
 537              	.LVL39:
 538              	.LFB176:
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 539              		.loc 1 946 78 is_stmt 1 view -0
 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 8
 542              		@ frame_needed = 0, uses_anonymous_args = 0
 948:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_address(module_inst, 0);
 543              		.loc 1 948 5 view .LVU157
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 544              		.loc 1 946 78 is_stmt 0 view .LVU158
 545 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 546              		.cfi_def_cfa_offset 24
 547              		.cfi_offset 4, -12
 548              		.cfi_offset 5, -8
 549              		.cfi_offset 14, -4
 946:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // Reset USB Device Stack Core
 550              		.loc 1 946 78 view .LVU159
 551 0002 0546     		mov	r5, r0
 948:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_set_address(module_inst, 0);
 552              		.loc 1 948 5 view .LVU160
 553 0004 FFF7FEFF 		bl	udc_reset
 554              	.LVL40:
 949:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_ep_enable(module_inst);
 555              		.loc 1 949 5 is_stmt 1 view .LVU161
 556 0008 2B68     		ldr	r3, [r5]
 557              	.LVL41:
 558              	.LBB78:
 559              	.LBI78:
 560              		.file 2 "tmk_core/protocol/arm_atsam/usb/usb.h"
   1:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
   2:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \file
   3:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   4:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief SAM USB Driver
   5:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   6:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Copyright (C) 2014-2016 Atmel Corporation. All rights reserved.
   7:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
   8:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \asf_license_start
   9:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  10:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \page License
  11:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  12:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Redistribution and use in source and binary forms, with or without
  13:tmk_core/protocol/arm_atsam/usb/usb.h ****  * modification, are permitted provided that the following conditions are met:
  14:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  15:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 1. Redistributions of source code must retain the above copyright notice,
  16:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    this list of conditions and the following disclaimer.
  17:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  18:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    this list of conditions and the following disclaimer in the documentation
  20:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    and/or other materials provided with the distribution.
  21:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  22:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 3. The name of Atmel may not be used to endorse or promote products derived
  23:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    from this software without specific prior written permission.
  24:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  25:tmk_core/protocol/arm_atsam/usb/usb.h ****  * 4. This software may only be redistributed and used in connection with an
  26:tmk_core/protocol/arm_atsam/usb/usb.h ****  *    Atmel microcontroller product.
  27:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  28:tmk_core/protocol/arm_atsam/usb/usb.h ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  29:tmk_core/protocol/arm_atsam/usb/usb.h ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  30:tmk_core/protocol/arm_atsam/usb/usb.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
  31:tmk_core/protocol/arm_atsam/usb/usb.h ****  * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
  32:tmk_core/protocol/arm_atsam/usb/usb.h ****  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  33:tmk_core/protocol/arm_atsam/usb/usb.h ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  34:tmk_core/protocol/arm_atsam/usb/usb.h ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  35:tmk_core/protocol/arm_atsam/usb/usb.h ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  36:tmk_core/protocol/arm_atsam/usb/usb.h ****  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:tmk_core/protocol/arm_atsam/usb/usb.h ****  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:tmk_core/protocol/arm_atsam/usb/usb.h ****  * POSSIBILITY OF SUCH DAMAGE.
  39:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  40:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \asf_license_stop
  41:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  42:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
  43:tmk_core/protocol/arm_atsam/usb/usb.h **** /*
  44:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
  45:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
  46:tmk_core/protocol/arm_atsam/usb/usb.h **** #ifndef USB_H_INCLUDED
  47:tmk_core/protocol/arm_atsam/usb/usb.h **** #define USB_H_INCLUDED
  48:tmk_core/protocol/arm_atsam/usb/usb.h **** 
  49:tmk_core/protocol/arm_atsam/usb/usb.h **** #ifdef __cplusplus
  50:tmk_core/protocol/arm_atsam/usb/usb.h **** extern "C" {
  51:tmk_core/protocol/arm_atsam/usb/usb.h **** #endif
  52:tmk_core/protocol/arm_atsam/usb/usb.h **** 
  53:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
  54:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \defgroup asfdoc_sam0_usb_group SAM Universal Serial Bus (USB)
  55:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  56:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The Universal Serial Bus (USB) module complies with the USB 2.1 specification.
  57:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  58:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The following peripherals are used by this module:
  59:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB (Universal Serial Bus)
  60:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  61:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The following devices can use this module:
  62:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - Atmel | SMART SAM D51
  63:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  64:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module covers following mode:
  65:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_DEVICE_MODE
  66:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Device Mode
  67:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  68:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HOST_MODE
  69:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Host Mode
  70:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  71:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  72:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module covers following speed:
  73:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HS_MODE
  74:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB High Speed (480Mbit/s)
  75:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  76:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Full Speed (12Mbit/s)
  77:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_LS_MODE
  78:tmk_core/protocol/arm_atsam/usb/usb.h ****  *  - USB Low Speed (1.5Mbit/s)
  79:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  80:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  81:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_LPM_MODE
  82:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The USB module supports Link Power Management (LPM-L1) protocol.
  83:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  84:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  85:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB support needs whole set of enumeration process, to make the device
  86:tmk_core/protocol/arm_atsam/usb/usb.h ****  * recognizable and usable. The USB driver is designed to interface to the
  87:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB Stack in Atmel Software Framework (ASF).
  88:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  89:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_DEVICE_MODE
  90:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \section asfdoc_sam0_usb_device USB Device Mode
  91:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The ASF USB Device Stack has defined the USB Device Driver (UDD) interface,
  92:tmk_core/protocol/arm_atsam/usb/usb.h ****  * to support USB device operations. The USB module device driver complies with
  93:tmk_core/protocol/arm_atsam/usb/usb.h ****  * this interface, so that the USB Device Stack can work based on the
  94:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB module.
  95:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
  96:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Refer to <a href="http://www.atmel.com/images/doc8360.pdf">
  97:tmk_core/protocol/arm_atsam/usb/usb.h ****  * "ASF - USB Device Stack"</a> for more details.
  98:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
  99:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 100:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \if USB_HOST_MODE
 101:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \section adfdoc_sam0_usb_host USB Host Mode
 102:tmk_core/protocol/arm_atsam/usb/usb.h ****  * The ASF USB Host Stack has defined the USB Host Driver (UHD) interface,
 103:tmk_core/protocol/arm_atsam/usb/usb.h ****  * to support USB host operations. The USB module host driver complies with
 104:tmk_core/protocol/arm_atsam/usb/usb.h ****  * this interface, so that the USB Host Stack can work based on the USB module.
 105:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 106:tmk_core/protocol/arm_atsam/usb/usb.h ****  * Refer to <a href="http://www.atmel.com/images/doc8486.pdf">
 107:tmk_core/protocol/arm_atsam/usb/usb.h ****  * "ASF - USB Host Stack"</a> for more details.
 108:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \endif
 109:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 110:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 111:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the speed status for the USB module */
 112:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_speed {
 113:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_SPEED_LOW,
 114:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_SPEED_FULL,
 115:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 116:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 117:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the possible callback types for the USB in host module */
 118:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_callback {
 119:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_SOF,
 120:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_RESET,
 121:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_WAKEUP,
 122:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_DNRSM,
 123:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_UPRSM,
 124:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_RAMACER,
 125:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_CONNECT,
 126:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_DISCONNECT,
 127:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_CALLBACK_N,
 128:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 129:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 130:tmk_core/protocol/arm_atsam/usb/usb.h **** /** Enum for the possible callback types for the USB pipe in host module */
 131:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_callback {
 132:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_TRANSFER_COMPLETE,
 133:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_ERROR,
 134:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_SETUP,
 135:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_STALL,
 136:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_CALLBACK_N,
 137:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 138:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 139:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 140:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Host pipe types.
 141:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 142:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_type {
 143:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_DISABLE,
 144:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_CONTROL,
 145:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_ISO,
 146:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_BULK,
 147:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_INTERRUPT,
 148:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TYPE_EXTENDED,
 149:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 150:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 151:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 152:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Host pipe token types.
 153:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 154:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_host_pipe_token {
 155:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_SETUP,
 156:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_IN,
 157:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_HOST_PIPE_TOKEN_OUT,
 158:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 159:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 160:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 161:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Enumeration for the possible callback types for the USB in device module
 162:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 163:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_callback {
 164:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_SOF,
 165:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_RESET,
 166:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_WAKEUP,
 167:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_RAMACER,
 168:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_SUSPEND,
 169:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_LPMNYET,
 170:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_LPMSUSP,
 171:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_CALLBACK_N,
 172:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 173:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 174:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 175:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Enumeration for the possible callback types for the USB endpoint in device module
 176:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 177:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_endpoint_callback {
 178:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_TRCPT,
 179:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL,
 180:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_RXSTP,
 181:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_CALLBACK_STALL,
 182:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_EP_CALLBACK_N,
 183:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 184:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 185:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 186:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Device Endpoint types.
 187:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 188:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_endpoint_type {
 189:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_DISABLE,
 190:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_CONTROL,
 191:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS,
 192:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_BULK,
 193:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_ENDPOINT_TYPE_INTERRUPT,
 194:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 195:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 196:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 197:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Endpoint Size
 198:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 199:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_endpoint_size {
 200:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_8_BYTE,
 201:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_16_BYTE,
 202:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_32_BYTE,
 203:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_64_BYTE,
 204:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_128_BYTE,
 205:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_256_BYTE,
 206:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_512_BYTE,
 207:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_ENDPOINT_1023_BYTE,
 208:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 209:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 210:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 211:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Link Power Management Handshake.
 212:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 213:tmk_core/protocol/arm_atsam/usb/usb.h **** enum usb_device_lpm_mode {
 214:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_NOT_SUPPORT,
 215:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_ACK,
 216:tmk_core/protocol/arm_atsam/usb/usb.h ****     USB_DEVICE_LPM_NYET,
 217:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 218:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 219:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 220:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Module structure
 221:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 222:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_module;
 223:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 224:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 225:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \name Host Callback Functions Types
 226:tmk_core/protocol/arm_atsam/usb/usb.h ****  * @{
 227:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 228:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_host_callback_t)(struct usb_module *module_inst);
 229:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_host_pipe_callback_t)(struct usb_module *module_inst, void *);
 230:tmk_core/protocol/arm_atsam/usb/usb.h **** /** @} */
 231:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 232:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 233:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \name Device Callback Functions Types
 234:tmk_core/protocol/arm_atsam/usb/usb.h ****  * @{
 235:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 236:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_device_callback_t)(struct usb_module *module_inst, void *pointer);
 237:tmk_core/protocol/arm_atsam/usb/usb.h **** typedef void (*usb_device_endpoint_callback_t)(struct usb_module *module_inst, void *pointer);
 238:tmk_core/protocol/arm_atsam/usb/usb.h **** /** @} */
 239:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 240:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB configurations */
 241:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_config {
 242:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** \c true for host, \c false for device. */
 243:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool select_host_mode;
 244:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** When \c true the module is enabled during standby. */
 245:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool run_in_standby;
 246:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Generic Clock Generator source channel. */
 247:tmk_core/protocol/arm_atsam/usb/usb.h ****     // enum gclk_generator source_generator;
 248:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t source_generator;
 249:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Speed mode */
 250:tmk_core/protocol/arm_atsam/usb/usb.h ****     // enum usb_speed speed_mode;
 251:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t speed_mode;
 252:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 253:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 254:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 255:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief USB software module instance structure.
 256:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 257:tmk_core/protocol/arm_atsam/usb/usb.h ****  * USB software module instance structure, used to retain software state
 258:tmk_core/protocol/arm_atsam/usb/usb.h ****  * information of an associated hardware module instance.
 259:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 260:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 261:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_module {
 262:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Hardware module pointer of the associated USB peripheral. */
 263:tmk_core/protocol/arm_atsam/usb/usb.h ****     Usb *hw;
 264:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 265:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Array to store device related callback functions */
 266:tmk_core/protocol/arm_atsam/usb/usb.h ****     usb_device_callback_t          device_callback[USB_DEVICE_CALLBACK_N];
 267:tmk_core/protocol/arm_atsam/usb/usb.h ****     usb_device_endpoint_callback_t device_endpoint_callback[USB_EPT_NUM][USB_DEVICE_EP_CALLBACK_N];
 268:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device callbacks registered */
 269:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t device_registered_callback_mask;
 270:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device callbacks enabled */
 271:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t device_enabled_callback_mask;
 272:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device endpoint callbacks registered */
 273:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t device_endpoint_registered_callback_mask[USB_EPT_NUM];
 274:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** Bit mask for device endpoint callbacks enabled */
 275:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t device_endpoint_enabled_callback_mask[USB_EPT_NUM];
 276:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 277:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 278:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB device endpoint configurations */
 279:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_device_endpoint_config {
 280:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** device address */
 281:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t ep_address;
 282:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** endpoint size */
 283:tmk_core/protocol/arm_atsam/usb/usb.h ****     enum usb_endpoint_size ep_size;
 284:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** automatic zero length packet mode, \c true to enable */
 285:tmk_core/protocol/arm_atsam/usb/usb.h ****     bool auto_zlp;
 286:tmk_core/protocol/arm_atsam/usb/usb.h ****     /** type of endpoint with Bank */
 287:tmk_core/protocol/arm_atsam/usb/usb.h ****     enum usb_device_endpoint_type ep_type;
 288:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 289:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 290:tmk_core/protocol/arm_atsam/usb/usb.h **** /** USB device endpoint callback status parameter structure */
 291:tmk_core/protocol/arm_atsam/usb/usb.h **** struct usb_endpoint_callback_parameter {
 292:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t received_bytes;
 293:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t sent_bytes;
 294:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint16_t out_buffer_size;
 295:tmk_core/protocol/arm_atsam/usb/usb.h ****     uint8_t  endpoint_address;
 296:tmk_core/protocol/arm_atsam/usb/usb.h **** };
 297:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 298:tmk_core/protocol/arm_atsam/usb/usb.h **** void usb_enable(struct usb_module *module_inst);
 299:tmk_core/protocol/arm_atsam/usb/usb.h **** void usb_disable(struct usb_module *module_inst);
 300:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 301:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 302:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the status of USB module's state machine
 303:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 304:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB module instance
 305:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 306:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint8_t usb_get_state_machine_status(struct usb_module *module_inst) {
 307:tmk_core/protocol/arm_atsam/usb/usb.h ****     /* Sanity check arguments */
 308:tmk_core/protocol/arm_atsam/usb/usb.h ****     Assert(module_inst);
 309:tmk_core/protocol/arm_atsam/usb/usb.h ****     Assert(module_inst->hw);
 310:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 311:tmk_core/protocol/arm_atsam/usb/usb.h ****     return module_inst->hw->DEVICE.FSMSTATUS.reg;
 312:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 313:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 314:tmk_core/protocol/arm_atsam/usb/usb.h **** void             usb_get_config_defaults(struct usb_config *module_config);
 315:tmk_core/protocol/arm_atsam/usb/usb.h **** enum status_code usb_init(struct usb_module *module_inst, Usb *const hw, struct usb_config *module_
 316:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 317:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 318:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Attach USB device to the bus
 319:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 320:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 321:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_attach(struct usb_module *module_inst) { module_inst->hw->DEVICE.CTRL
 323:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 324:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 325:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Detach USB device from the bus
 326:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 327:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 328:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_detach(struct usb_module *module_inst) { module_inst->hw->DEVICE.CTRL
 330:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 331:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 332:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the speed mode of USB device
 333:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 334:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 335:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB Speed mode (\ref usb_speed).
 336:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 337:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline enum usb_speed usb_device_get_speed(struct usb_module *module_inst) {
 338:tmk_core/protocol/arm_atsam/usb/usb.h ****     if (!(module_inst->hw->DEVICE.STATUS.reg & USB_DEVICE_STATUS_SPEED_Msk)) {
 339:tmk_core/protocol/arm_atsam/usb/usb.h ****         return USB_SPEED_FULL;
 340:tmk_core/protocol/arm_atsam/usb/usb.h ****     } else {
 341:tmk_core/protocol/arm_atsam/usb/usb.h ****         return USB_SPEED_LOW;
 342:tmk_core/protocol/arm_atsam/usb/usb.h ****     }
 343:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 344:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 345:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 346:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the address of USB device
 347:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 348:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 349:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device address value.
 350:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint8_t usb_device_get_address(struct usb_module *module_inst) { return ((uint8_t)(mo
 352:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 353:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 354:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Set the speed mode of USB device
 355:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 356:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 357:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param address     USB device address value
 358:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_set_address(struct usb_module *module_inst, uint8_t address) { module
 561              		.loc 2 359 20 view .LVU162
 562              	.LBB79:
 563              		.loc 2 359 94 view .LVU163
 564              		.loc 2 359 127 is_stmt 0 view .LVU164
 565 000a 8022     		movs	r2, #128
 566 000c 9A72     		strb	r2, [r3, #10]
 567              	.LVL42:
 568              		.loc 2 359 127 view .LVU165
 569              	.LBE79:
 570              	.LBE78:
 950:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 571              		.loc 1 950 5 is_stmt 1 view .LVU166
 572              	.LBB80:
 573              	.LBI80:
 864:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Device Endpoint0 Configuration */
 574              		.loc 1 864 13 view .LVU167
 575              	.LBB81:
 866:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 576              		.loc 1 866 5 view .LVU168
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 577              		.loc 1 868 5 view .LVU169
 578 000e 01A8     		add	r0, sp, #4
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 579              		.loc 1 869 24 is_stmt 0 view .LVU170
 580 0010 0024     		movs	r4, #0
 868:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep0.ep_size = (enum usb_endpoint_size)(32 - clz(((uint32_t)Min(Max(USB_DEVICE_EP_CTRL_SI
 581              		.loc 1 868 5 view .LVU171
 582 0012 FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 583              	.LVL43:
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 584              		.loc 1 869 5 is_stmt 1 view .LVU172
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 585              		.loc 1 870 5 is_stmt 0 view .LVU173
 586 0016 01A9     		add	r1, sp, #4
 587 0018 2846     		mov	r0, r5
 869:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(module_inst, &config_ep0);
 588              		.loc 1 869 24 view .LVU174
 589 001a 8DF80540 		strb	r4, [sp, #5]
 870:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 590              		.loc 1 870 5 is_stmt 1 view .LVU175
 591 001e FFF7FEFF 		bl	usb_device_endpoint_set_config
 592              	.LVL44:
 872:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 593              		.loc 1 872 5 view .LVU176
 594 0022 1549     		ldr	r1, .L40
 595 0024 2846     		mov	r0, r5
 596 0026 FFF7FEFF 		bl	usb_device_endpoint_setup_buffer_job
 597              	.LVL45:
 874:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT, _usb_
 598              		.loc 1 874 5 view .LVU177
 599 002a 2146     		mov	r1, r4
 600 002c 134B     		ldr	r3, .L40+4
 601 002e 0222     		movs	r2, #2
 602 0030 2846     		mov	r0, r5
 603 0032 FFF7FEFF 		bl	usb_device_endpoint_register_callback
 604              	.LVL46:
 875:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_register_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL, _usb
 605              		.loc 1 875 5 view .LVU178
 606 0036 2246     		mov	r2, r4
 607 0038 2146     		mov	r1, r4
 608 003a 114B     		ldr	r3, .L40+8
 609 003c 2846     		mov	r0, r5
 610 003e FFF7FEFF 		bl	usb_device_endpoint_register_callback
 611              	.LVL47:
 876:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_RXSTP);
 612              		.loc 1 876 5 view .LVU179
 613 0042 104B     		ldr	r3, .L40+12
 614 0044 2146     		mov	r1, r4
 615 0046 0122     		movs	r2, #1
 616 0048 2846     		mov	r0, r5
 617 004a FFF7FEFF 		bl	usb_device_endpoint_register_callback
 618              	.LVL48:
 877:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 619              		.loc 1 877 5 view .LVU180
 620 004e 2146     		mov	r1, r4
 621 0050 0222     		movs	r2, #2
 622 0052 2846     		mov	r0, r5
 623 0054 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 624              	.LVL49:
 878:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(module_inst, 0, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 625              		.loc 1 878 5 view .LVU181
 626 0058 2246     		mov	r2, r4
 627 005a 2146     		mov	r1, r4
 628 005c 2846     		mov	r0, r5
 629 005e FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 630              	.LVL50:
 879:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 631              		.loc 1 879 5 view .LVU182
 632 0062 0122     		movs	r2, #1
 633 0064 2146     		mov	r1, r4
 634 0066 2846     		mov	r0, r5
 635 0068 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 636              	.LVL51:
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 637              		.loc 1 886 5 view .LVU183
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 638              		.loc 1 886 26 is_stmt 0 view .LVU184
 639 006c 064B     		ldr	r3, .L40+16
 640 006e 83F8A040 		strb	r4, [r3, #160]
 641              	.LVL52:
 886:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 642              		.loc 1 886 26 view .LVU185
 643              	.LBE81:
 644              	.LBE80:
 951:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 645              		.loc 1 951 1 view .LVU186
 646 0072 03B0     		add	sp, sp, #12
 647              		.cfi_def_cfa_offset 12
 648              		@ sp needed
 649 0074 30BD     		pop	{r4, r5, pc}
 650              	.LVL53:
 651              	.L41:
 951:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 652              		.loc 1 951 1 view .LVU187
 653 0076 00BF     		.align	2
 654              	.L40:
 655 0078 00000000 		.word	udd_ctrl_buffer
 656 007c 00000000 		.word	_usb_ep0_on_setup
 657 0080 00000000 		.word	_usb_ep0_on_tansfer_ok
 658 0084 00000000 		.word	_usb_ep0_on_tansfer_fail
 659 0088 00000000 		.word	.LANCHOR0
 660              		.cfi_endproc
 661              	.LFE176:
 663              		.section	.text.udd_ctrl_send_zlp_in,"ax",%progbits
 664              		.align	1
 665              		.syntax unified
 666              		.thumb
 667              		.thumb_func
 668              		.fpu fpv4-sp-d16
 670              	udd_ctrl_send_zlp_in:
 671              	.LFB165:
 627:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
 672              		.loc 1 627 40 is_stmt 1 view -0
 673              		.cfi_startproc
 674              		@ args = 0, pretend = 0, frame = 0
 675              		@ frame_needed = 0, uses_anonymous_args = 0
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 676              		.loc 1 628 5 view .LVU189
 627:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
 677              		.loc 1 627 40 is_stmt 0 view .LVU190
 678 0000 10B5     		push	{r4, lr}
 679              		.cfi_def_cfa_offset 8
 680              		.cfi_offset 4, -8
 681              		.cfi_offset 14, -4
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 682              		.loc 1 629 5 view .LVU191
 683 0002 094C     		ldr	r4, .L43
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 684              		.loc 1 628 26 view .LVU192
 685 0004 094B     		ldr	r3, .L43+4
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 686              		.loc 1 629 5 view .LVU193
 687 0006 0A49     		ldr	r1, .L43+8
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 688              		.loc 1 628 26 view .LVU194
 689 0008 0322     		movs	r2, #3
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 690              		.loc 1 629 5 view .LVU195
 691 000a 2046     		mov	r0, r4
 628:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 692              		.loc 1 628 26 view .LVU196
 693 000c 83F8A020 		strb	r2, [r3, #160]
 629:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_write_buffer_job(&usb_device, 0, udd_g_ctrlreq.payload, 0);
 694              		.loc 1 629 5 is_stmt 1 view .LVU197
 695 0010 FFF7FEFF 		bl	usb_device_endpoint_setup_buffer_job
 696              	.LVL54:
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 697              		.loc 1 630 5 view .LVU198
 698 0014 074A     		ldr	r2, .L43+12
 699 0016 0023     		movs	r3, #0
 700 0018 2046     		mov	r0, r4
 701 001a 9268     		ldr	r2, [r2, #8]
 702 001c 1946     		mov	r1, r3
 631:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 703              		.loc 1 631 1 is_stmt 0 view .LVU199
 704 001e BDE81040 		pop	{r4, lr}
 705              		.cfi_restore 14
 706              		.cfi_restore 4
 707              		.cfi_def_cfa_offset 0
 630:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 708              		.loc 1 630 5 view .LVU200
 709 0022 FFF7FEBF 		b	usb_device_endpoint_write_buffer_job
 710              	.LVL55:
 711              	.L44:
 712 0026 00BF     		.align	2
 713              	.L43:
 714 0028 00000000 		.word	usb_device
 715 002c 00000000 		.word	.LANCHOR0
 716 0030 00000000 		.word	udd_ctrl_buffer
 717 0034 00000000 		.word	udd_g_ctrlreq
 718              		.cfi_endproc
 719              	.LFE165:
 721              		.section	.text._usb_ep0_on_tansfer_fail,"ax",%progbits
 722              		.align	1
 723              		.syntax unified
 724              		.thumb
 725              		.thumb_func
 726              		.fpu fpv4-sp-d16
 728              	_usb_ep0_on_tansfer_fail:
 729              	.LVL56:
 730              	.LFB171:
 831:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 731              		.loc 1 831 85 is_stmt 1 view -0
 732              		.cfi_startproc
 733              		@ args = 0, pretend = 0, frame = 0
 734              		@ frame_needed = 0, uses_anonymous_args = 0
 735              		@ link register save eliminated.
 832:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 736              		.loc 1 832 5 view .LVU202
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 737              		.loc 1 834 5 view .LVU203
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 738              		.loc 1 834 25 is_stmt 0 view .LVU204
 739 0000 8979     		ldrb	r1, [r1, #6]	@ zero_extendqisi2
 740              	.LVL57:
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 741              		.loc 1 834 25 view .LVU205
 742 0002 0B4A     		ldr	r2, .L53
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 743              		.loc 1 834 8 view .LVU206
 744 0004 0806     		lsls	r0, r1, #24
 745              	.LVL58:
 834:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_underflow(pointer);
 746              		.loc 1 834 8 view .LVU207
 747 0006 92F8A030 		ldrb	r3, [r2, #160]	@ zero_extendqisi2
 748 000a 08D5     		bpl	.L46
 835:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 749              		.loc 1 835 9 is_stmt 1 view .LVU208
 750              	.LVL59:
 751              	.LBB86:
 752              	.LBI86:
 793:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 753              		.loc 1 793 13 view .LVU209
 754              	.LBB87:
 794:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 755              		.loc 1 794 5 view .LVU210
 796:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop OUT transaction
 756              		.loc 1 796 5 view .LVU211
 796:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop OUT transaction
 757              		.loc 1 796 8 is_stmt 0 view .LVU212
 758 000c 012B     		cmp	r3, #1
 759 000e 01D1     		bne	.L47
 799:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
 760              		.loc 1 799 9 is_stmt 1 view .LVU213
 761 0010 FFF7FEBF 		b	udd_ctrl_send_zlp_in
 762              	.LVL60:
 763              	.L47:
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 764              		.loc 1 800 12 view .LVU214
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 765              		.loc 1 800 15 is_stmt 0 view .LVU215
 766 0014 042B     		cmp	r3, #4
 767              	.LVL61:
 768              	.L52:
 800:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A OUT handshake is waiting by device,
 769              		.loc 1 800 15 view .LVU216
 770              	.LBE87:
 771              	.LBE86:
 772              	.LBB88:
 773              	.LBB89:
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 774              		.loc 1 818 15 view .LVU217
 775 0016 0AD1     		bne	.L45
 821:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 776              		.loc 1 821 9 is_stmt 1 view .LVU218
 777 0018 0648     		ldr	r0, .L53+4
 778 001a FFF7FEBF 		b	usb_device_endpoint_set_halt
 779              	.LVL62:
 780              	.L46:
 781              	.LBE89:
 782              	.LBE88:
 837:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 783              		.loc 1 837 9 view .LVU219
 784              	.LBB91:
 785              	.LBI88:
 811:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 786              		.loc 1 811 13 view .LVU220
 787              	.LBB90:
 812:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 788              		.loc 1 812 5 view .LVU221
 814:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop IN transaction
 789              		.loc 1 814 5 view .LVU222
 814:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Host want to stop IN transaction
 790              		.loc 1 814 8 is_stmt 0 view .LVU223
 791 001e 022B     		cmp	r3, #2
 792 0020 03D1     		bne	.L49
 817:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
 793              		.loc 1 817 9 is_stmt 1 view .LVU224
 817:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
 794              		.loc 1 817 30 is_stmt 0 view .LVU225
 795 0022 0423     		movs	r3, #4
 796 0024 82F8A030 		strb	r3, [r2, #160]
 797 0028 7047     		bx	lr
 798              	.L49:
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 799              		.loc 1 818 12 is_stmt 1 view .LVU226
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 800              		.loc 1 818 15 is_stmt 0 view .LVU227
 801 002a 032B     		cmp	r3, #3
 802 002c F3E7     		b	.L52
 803              	.LVL63:
 804              	.L45:
 818:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* A IN handshake is waiting by device,
 805              		.loc 1 818 15 view .LVU228
 806              	.LBE90:
 807              	.LBE91:
 839:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 808              		.loc 1 839 1 view .LVU229
 809 002e 7047     		bx	lr
 810              	.L54:
 811              		.align	2
 812              	.L53:
 813 0030 00000000 		.word	.LANCHOR0
 814 0034 00000000 		.word	usb_device
 815              		.cfi_endproc
 816              	.LFE171:
 818              		.section	.text.udd_ctrl_in_sent,"ax",%progbits
 819              		.align	1
 820              		.syntax unified
 821              		.thumb
 822              		.thumb_func
 823              		.fpu fpv4-sp-d16
 825              	udd_ctrl_in_sent:
 826              	.LFB166:
 636:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     static bool b_shortpacket = false;
 827              		.loc 1 636 36 is_stmt 1 view -0
 828              		.cfi_startproc
 829              		@ args = 0, pretend = 0, frame = 0
 830              		@ frame_needed = 0, uses_anonymous_args = 0
 637:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint16_t    nb_remain;
 831              		.loc 1 637 5 view .LVU231
 638:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 832              		.loc 1 638 5 view .LVU232
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 833              		.loc 1 640 5 view .LVU233
 636:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     static bool b_shortpacket = false;
 834              		.loc 1 636 36 is_stmt 0 view .LVU234
 835 0000 70B5     		push	{r4, r5, r6, lr}
 836              		.cfi_def_cfa_offset 16
 837              		.cfi_offset 4, -16
 838              		.cfi_offset 5, -12
 839              		.cfi_offset 6, -8
 840              		.cfi_offset 14, -4
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 841              		.loc 1 640 44 view .LVU235
 842 0002 1E4E     		ldr	r6, .L66
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 843              		.loc 1 640 30 view .LVU236
 844 0004 1E4D     		ldr	r5, .L66+4
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 845              		.loc 1 640 44 view .LVU237
 846 0006 B6F8A230 		ldrh	r3, [r6, #162]
 640:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 847              		.loc 1 640 15 view .LVU238
 848 000a AC89     		ldrh	r4, [r5, #12]
 849 000c E41A     		subs	r4, r4, r3
 850 000e A4B2     		uxth	r4, r4
 851              	.LVL64:
 642:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* All content of current buffer payload are sent Update number of total data sending by pr
 852              		.loc 1 642 5 is_stmt 1 view .LVU239
 642:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* All content of current buffer payload are sent Update number of total data sending by pr
 853              		.loc 1 642 8 is_stmt 0 view .LVU240
 854 0010 F4B9     		cbnz	r4, .L56
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 855              		.loc 1 644 9 is_stmt 1 view .LVU241
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 856              		.loc 1 644 40 is_stmt 0 view .LVU242
 857 0012 B6F8A420 		ldrh	r2, [r6, #164]
 858 0016 1344     		add	r3, r3, r2
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 859              		.loc 1 645 12 view .LVU243
 860 0018 EA88     		ldrh	r2, [r5, #6]
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 861              		.loc 1 644 40 view .LVU244
 862 001a 9BB2     		uxth	r3, r3
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 863              		.loc 1 645 12 view .LVU245
 864 001c 9A42     		cmp	r2, r3
 644:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans) || b_shortpacket) {
 865              		.loc 1 644 40 view .LVU246
 866 001e A6F8A430 		strh	r3, [r6, #164]	@ movhi
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 867              		.loc 1 645 9 is_stmt 1 view .LVU247
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 868              		.loc 1 645 12 is_stmt 0 view .LVU248
 869 0022 02D0     		beq	.L57
 645:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* All data requested are transferred or a short packet has been sent, then it is the e
 870              		.loc 1 645 75 discriminator 1 view .LVU249
 871 0024 96F8A630 		ldrb	r3, [r6, #166]	@ zero_extendqisi2
 872 0028 43B1     		cbz	r3, .L58
 873              	.L57:
 648:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 874              		.loc 1 648 13 is_stmt 1 view .LVU250
 648:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_setup_buffer_job(&usb_device, udd_ctrl_buffer);
 875              		.loc 1 648 34 is_stmt 0 view .LVU251
 876 002a 0423     		movs	r3, #4
 877 002c 86F8A030 		strb	r3, [r6, #160]
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 878              		.loc 1 649 13 is_stmt 1 view .LVU252
 879 0030 1449     		ldr	r1, .L66+8
 880 0032 1548     		ldr	r0, .L66+12
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 881              		.loc 1 675 1 is_stmt 0 view .LVU253
 882 0034 BDE87040 		pop	{r4, r5, r6, lr}
 883              		.cfi_remember_state
 884              		.cfi_restore 14
 885              		.cfi_restore 6
 886              		.cfi_restore 5
 887              		.cfi_restore 4
 888              		.cfi_def_cfa_offset 0
 889              	.LVL65:
 649:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             return;
 890              		.loc 1 649 13 view .LVU254
 891 0038 FFF7FEBF 		b	usb_device_endpoint_setup_buffer_job
 892              	.LVL66:
 893              	.L58:
 894              		.cfi_restore_state
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 895              		.loc 1 653 9 is_stmt 1 view .LVU255
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 896              		.loc 1 653 28 is_stmt 0 view .LVU256
 897 003c 6B69     		ldr	r3, [r5, #20]
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 898              		.loc 1 653 12 view .LVU257
 899 003e 0BB9     		cbnz	r3, .L59
 900              	.L62:
 668:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 901              		.loc 1 668 23 view .LVU258
 902 0040 0123     		movs	r3, #1
 903 0042 09E0     		b	.L60
 904              	.L59:
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 905              		.loc 1 653 50 discriminator 1 view .LVU259
 906 0044 9847     		blx	r3
 907              	.LVL67:
 653:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* Under run then send zlp on IN
 908              		.loc 1 653 45 discriminator 1 view .LVU260
 909 0046 0028     		cmp	r0, #0
 910 0048 FAD0     		beq	.L62
 658:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             nb_remain                 = udd_g_ctrlreq.payload_size;
 911              		.loc 1 658 13 is_stmt 1 view .LVU261
 658:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             nb_remain                 = udd_g_ctrlreq.payload_size;
 912              		.loc 1 658 39 is_stmt 0 view .LVU262
 913 004a A6F8A240 		strh	r4, [r6, #162]	@ movhi
 659:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 914              		.loc 1 659 13 is_stmt 1 view .LVU263
 659:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 915              		.loc 1 659 39 is_stmt 0 view .LVU264
 916 004e AC89     		ldrh	r4, [r5, #12]
 917              	.LVL68:
 918              	.L56:
 664:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_remain     = USB_DEVICE_EP_CTRL_SIZE;
 919              		.loc 1 664 5 is_stmt 1 view .LVU265
 664:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         nb_remain     = USB_DEVICE_EP_CTRL_SIZE;
 920              		.loc 1 664 8 is_stmt 0 view .LVU266
 921 0050 072C     		cmp	r4, #7
 922 0052 F5D9     		bls	.L62
 666:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 923              		.loc 1 666 23 view .LVU267
 924 0054 0023     		movs	r3, #0
 665:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         b_shortpacket = false;
 925              		.loc 1 665 23 view .LVU268
 926 0056 0824     		movs	r4, #8
 927              	.LVL69:
 928              	.L60:
 672:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 929              		.loc 1 672 5 view .LVU269
 930 0058 A968     		ldr	r1, [r5, #8]
 931 005a B6F8A220 		ldrh	r2, [r6, #162]
 932 005e 86F8A630 		strb	r3, [r6, #166]
 933              	.LVL70:
 672:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 934              		.loc 1 672 5 is_stmt 1 view .LVU270
 935 0062 0A44     		add	r2, r2, r1
 936 0064 2346     		mov	r3, r4
 937 0066 0021     		movs	r1, #0
 938 0068 0748     		ldr	r0, .L66+12
 939 006a FFF7FEFF 		bl	usb_device_endpoint_write_buffer_job
 940              	.LVL71:
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 941              		.loc 1 674 5 view .LVU271
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 942              		.loc 1 674 31 is_stmt 0 view .LVU272
 943 006e B6F8A230 		ldrh	r3, [r6, #162]
 944 0072 1C44     		add	r4, r4, r3
 945              	.LVL72:
 674:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 946              		.loc 1 674 31 view .LVU273
 947 0074 A6F8A240 		strh	r4, [r6, #162]	@ movhi
 675:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 948              		.loc 1 675 1 view .LVU274
 949 0078 70BD     		pop	{r4, r5, r6, pc}
 950              	.L67:
 951 007a 00BF     		.align	2
 952              	.L66:
 953 007c 00000000 		.word	.LANCHOR0
 954 0080 00000000 		.word	udd_g_ctrlreq
 955 0084 00000000 		.word	udd_ctrl_buffer
 956 0088 00000000 		.word	usb_device
 957              		.cfi_endproc
 958              	.LFE166:
 960              		.section	.text._usb_ep0_on_setup,"ax",%progbits
 961              		.align	1
 962              		.syntax unified
 963              		.thumb
 964              		.thumb_func
 965              		.fpu fpv4-sp-d16
 967              	_usb_ep0_on_setup:
 968              	.LVL73:
 969              	.LFB168:
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 970              		.loc 1 751 78 is_stmt 1 view -0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 0
 973              		@ frame_needed = 0, uses_anonymous_args = 0
 752:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 974              		.loc 1 752 5 view .LVU276
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 975              		.loc 1 751 78 is_stmt 0 view .LVU277
 976 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 977              		.cfi_def_cfa_offset 24
 978              		.cfi_offset 4, -24
 979              		.cfi_offset 5, -20
 980              		.cfi_offset 6, -16
 981              		.cfi_offset 7, -12
 982              		.cfi_offset 8, -8
 983              		.cfi_offset 14, -4
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 984              		.loc 1 754 26 view .LVU278
 985 0004 294C     		ldr	r4, .L84
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 986              		.loc 1 754 8 view .LVU279
 987 0006 94F8A030 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 751:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 988              		.loc 1 751 78 view .LVU280
 989 000a 0D46     		mov	r5, r1
 990              	.LVL74:
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 991              		.loc 1 754 5 is_stmt 1 view .LVU281
 754:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.callback) {
 992              		.loc 1 754 8 is_stmt 0 view .LVU282
 993 000c 33B1     		cbz	r3, .L69
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 994              		.loc 1 755 9 is_stmt 1 view .LVU283
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 995              		.loc 1 755 34 is_stmt 0 view .LVU284
 996 000e 284B     		ldr	r3, .L84+4
 997 0010 1B69     		ldr	r3, [r3, #16]
 755:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 998              		.loc 1 755 12 view .LVU285
 999 0012 03B1     		cbz	r3, .L70
 756:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 1000              		.loc 1 756 13 is_stmt 1 view .LVU286
 1001 0014 9847     		blx	r3
 1002              	.LVL75:
 1003              	.L70:
 758:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1004              		.loc 1 758 9 view .LVU287
 758:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1005              		.loc 1 758 30 is_stmt 0 view .LVU288
 1006 0016 0023     		movs	r3, #0
 1007 0018 84F8A030 		strb	r3, [r4, #160]
 1008              	.L69:
 760:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_stall_data();
 1009              		.loc 1 760 5 is_stmt 1 view .LVU289
 760:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_stall_data();
 1010              		.loc 1 760 8 is_stmt 0 view .LVU290
 1011 001c 2F88     		ldrh	r7, [r5]
 1012 001e 082F     		cmp	r7, #8
 1013 0020 03D0     		beq	.L71
 1014              	.LVL76:
 1015              	.L72:
 761:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1016              		.loc 1 761 9 is_stmt 1 view .LVU291
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1017              		.loc 1 787 1 is_stmt 0 view .LVU292
 1018 0022 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1019              		.cfi_remember_state
 1020              		.cfi_restore 14
 1021              		.cfi_restore 8
 1022              		.cfi_restore 7
 1023              		.cfi_restore 6
 1024              		.cfi_restore 5
 1025              		.cfi_restore 4
 1026              		.cfi_def_cfa_offset 0
 761:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1027              		.loc 1 761 9 view .LVU293
 1028 0026 FFF7FEBF 		b	udd_ctrl_stall_data
 1029              	.LVL77:
 1030              	.L71:
 1031              		.cfi_restore_state
 764:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (false == udc_process_setup()) {
 1032              		.loc 1 764 9 is_stmt 1 view .LVU294
 1033              	.LBB94:
 1034              	.LBI94:
 616:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bmRequestType = udd_ctrl_buffer[0];
 1035              		.loc 1 616 13 view .LVU295
 1036              	.LBB95:
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 1037              		.loc 1 617 5 view .LVU296
 618:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wValue        = ((uint16_t)(udd_ctrl_buffer[3]) << 8) + udd_ctrl_buffer[2];
 1038              		.loc 1 618 5 view .LVU297
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 1039              		.loc 1 617 54 is_stmt 0 view .LVU298
 1040 002a 224D     		ldr	r5, .L84+8
 1041              	.LVL78:
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 1042              		.loc 1 617 37 view .LVU299
 1043 002c 204E     		ldr	r6, .L84+4
 1044 002e 2B88     		ldrh	r3, [r5]
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 1045              		.loc 1 619 66 view .LVU300
 1046 0030 EA78     		ldrb	r2, [r5, #3]	@ zero_extendqisi2
 617:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.bRequest      = udd_ctrl_buffer[1];
 1047              		.loc 1 617 37 view .LVU301
 1048 0032 3380     		strh	r3, [r6]	@ movhi
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 1049              		.loc 1 619 5 is_stmt 1 view .LVU302
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 1050              		.loc 1 619 94 is_stmt 0 view .LVU303
 1051 0034 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 1052              		.loc 1 619 77 view .LVU304
 1053 0036 03EB0223 		add	r3, r3, r2, lsl #8
 619:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wIndex        = ((uint16_t)(udd_ctrl_buffer[5]) << 8) + udd_ctrl_buffer[4];
 1054              		.loc 1 619 37 view .LVU305
 1055 003a 7380     		strh	r3, [r6, #2]	@ movhi
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 1056              		.loc 1 620 5 is_stmt 1 view .LVU306
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 1057              		.loc 1 620 66 is_stmt 0 view .LVU307
 1058 003c 6A79     		ldrb	r2, [r5, #5]	@ zero_extendqisi2
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 1059              		.loc 1 620 94 view .LVU308
 1060 003e 2B79     		ldrb	r3, [r5, #4]	@ zero_extendqisi2
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 1061              		.loc 1 620 77 view .LVU309
 1062 0040 03EB0223 		add	r3, r3, r2, lsl #8
 620:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.req.wLength       = ((uint16_t)(udd_ctrl_buffer[7]) << 8) + udd_ctrl_buffer[6];
 1063              		.loc 1 620 37 view .LVU310
 1064 0044 B380     		strh	r3, [r6, #4]	@ movhi
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1065              		.loc 1 621 5 is_stmt 1 view .LVU311
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1066              		.loc 1 621 66 is_stmt 0 view .LVU312
 1067 0046 EA79     		ldrb	r2, [r5, #7]	@ zero_extendqisi2
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1068              		.loc 1 621 94 view .LVU313
 1069 0048 AB79     		ldrb	r3, [r5, #6]	@ zero_extendqisi2
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1070              		.loc 1 621 77 view .LVU314
 1071 004a 03EB0223 		add	r3, r3, r2, lsl #8
 621:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1072              		.loc 1 621 37 view .LVU315
 1073 004e F380     		strh	r3, [r6, #6]	@ movhi
 1074              	.LBE95:
 1075              	.LBE94:
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 1076              		.loc 1 765 9 is_stmt 1 view .LVU316
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 1077              		.loc 1 765 22 is_stmt 0 view .LVU317
 1078 0050 FFF7FEFF 		bl	udc_process_setup
 1079              	.LVL79:
 765:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_stall_data();
 1080              		.loc 1 765 12 view .LVU318
 1081 0054 0028     		cmp	r0, #0
 1082 0056 E4D0     		beq	.L72
 768:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_prev_payload_nb_trans = 0;
 1083              		.loc 1 768 16 is_stmt 1 view .LVU319
 768:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_prev_payload_nb_trans = 0;
 1084              		.loc 1 768 19 is_stmt 0 view .LVU320
 1085 0058 96F90030 		ldrsb	r3, [r6]
 1086 005c 002B     		cmp	r3, #0
 1087 005e 10DA     		bge	.L73
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 1088              		.loc 1 769 13 is_stmt 1 view .LVU321
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 1089              		.loc 1 771 44 is_stmt 0 view .LVU322
 1090 0060 0223     		movs	r3, #2
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 1091              		.loc 1 769 44 view .LVU323
 1092 0062 0021     		movs	r1, #0
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 1093              		.loc 1 771 44 view .LVU324
 1094 0064 84F8A030 		strb	r3, [r4, #160]
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 1095              		.loc 1 772 13 view .LVU325
 1096 0068 2A46     		mov	r2, r5
 1097 006a 3B46     		mov	r3, r7
 1098 006c 1248     		ldr	r0, .L84+12
 769:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_payload_nb_trans      = 0;
 1099              		.loc 1 769 44 view .LVU326
 1100 006e A4F8A410 		strh	r1, [r4, #164]	@ movhi
 770:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state           = UDD_EPCTRL_DATA_IN;
 1101              		.loc 1 770 13 is_stmt 1 view .LVU327
 770:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ep_control_state           = UDD_EPCTRL_DATA_IN;
 1102              		.loc 1 770 44 is_stmt 0 view .LVU328
 1103 0072 A4F8A210 		strh	r1, [r4, #162]	@ movhi
 771:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             usb_device_endpoint_read_buffer_job(&usb_device, 0, udd_ctrl_buffer, USB_DEVICE_EP_CTRL
 1104              		.loc 1 771 13 is_stmt 1 view .LVU329
 772:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_ctrl_in_sent();
 1105              		.loc 1 772 13 view .LVU330
 1106 0076 FFF7FEFF 		bl	usb_device_endpoint_read_buffer_job
 1107              	.LVL80:
 773:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 1108              		.loc 1 773 13 view .LVU331
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1109              		.loc 1 787 1 is_stmt 0 view .LVU332
 1110 007a BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1111              		.cfi_remember_state
 1112              		.cfi_restore 14
 1113              		.cfi_restore 8
 1114              		.cfi_restore 7
 1115              		.cfi_restore 6
 1116              		.cfi_restore 5
 1117              		.cfi_restore 4
 1118              		.cfi_def_cfa_offset 0
 773:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 1119              		.loc 1 773 13 view .LVU333
 1120 007e FFF7FEBF 		b	udd_ctrl_in_sent
 1121              	.LVL81:
 1122              	.L73:
 1123              		.cfi_restore_state
 775:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_send_zlp_in();
 1124              		.loc 1 775 13 is_stmt 1 view .LVU334
 775:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_send_zlp_in();
 1125              		.loc 1 775 16 is_stmt 0 view .LVU335
 1126 0082 F388     		ldrh	r3, [r6, #6]
 1127 0084 1BB9     		cbnz	r3, .L74
 776:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 1128              		.loc 1 776 17 is_stmt 1 view .LVU336
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1129              		.loc 1 787 1 is_stmt 0 view .LVU337
 1130 0086 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1131              		.cfi_remember_state
 1132              		.cfi_restore 14
 1133              		.cfi_restore 8
 1134              		.cfi_restore 7
 1135              		.cfi_restore 6
 1136              		.cfi_restore 5
 1137              		.cfi_restore 4
 1138              		.cfi_def_cfa_offset 0
 776:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return;
 1139              		.loc 1 776 17 view .LVU338
 1140 008a FFF7FEBF 		b	udd_ctrl_send_zlp_in
 1141              	.LVL82:
 1142              	.L74:
 1143              		.cfi_restore_state
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 1144              		.loc 1 779 17 is_stmt 1 view .LVU339
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 1145              		.loc 1 779 48 is_stmt 0 view .LVU340
 1146 008e 0021     		movs	r1, #0
 781:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Initialize buffer size and enable OUT bank */
 1147              		.loc 1 781 48 view .LVU341
 1148 0090 0123     		movs	r3, #1
 1149 0092 84F8A030 		strb	r3, [r4, #160]
 779:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ctrl_payload_nb_trans      = 0;
 1150              		.loc 1 779 48 view .LVU342
 1151 0096 A4F8A410 		strh	r1, [r4, #164]	@ movhi
 780:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state           = UDD_EPCTRL_DATA_OUT;
 1152              		.loc 1 780 17 is_stmt 1 view .LVU343
 780:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 udd_ep_control_state           = UDD_EPCTRL_DATA_OUT;
 1153              		.loc 1 780 48 is_stmt 0 view .LVU344
 1154 009a A4F8A210 		strh	r1, [r4, #162]	@ movhi
 781:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Initialize buffer size and enable OUT bank */
 1155              		.loc 1 781 17 is_stmt 1 view .LVU345
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 1156              		.loc 1 783 17 view .LVU346
 1157 009e 3B46     		mov	r3, r7
 1158 00a0 2A46     		mov	r2, r5
 1159 00a2 0548     		ldr	r0, .L84+12
 787:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1160              		.loc 1 787 1 is_stmt 0 view .LVU347
 1161 00a4 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1162              		.cfi_restore 14
 1163              		.cfi_restore 8
 1164              		.cfi_restore 7
 1165              		.cfi_restore 6
 1166              		.cfi_restore 5
 1167              		.cfi_restore 4
 1168              		.cfi_def_cfa_offset 0
 783:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 1169              		.loc 1 783 17 view .LVU348
 1170 00a8 FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 1171              	.LVL83:
 1172              	.L85:
 1173              		.align	2
 1174              	.L84:
 1175 00ac 00000000 		.word	.LANCHOR0
 1176 00b0 00000000 		.word	udd_g_ctrlreq
 1177 00b4 00000000 		.word	udd_ctrl_buffer
 1178 00b8 00000000 		.word	usb_device
 1179              		.cfi_endproc
 1180              	.LFE168:
 1182              		.section	.text._usb_on_sof_notify,"ax",%progbits
 1183              		.align	1
 1184              		.syntax unified
 1185              		.thumb
 1186              		.thumb_func
 1187              		.fpu fpv4-sp-d16
 1189              	_usb_on_sof_notify:
 1190              	.LVL84:
 1191              	.LFB175:
 933:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_sof_notify();
 1192              		.loc 1 933 79 is_stmt 1 view -0
 1193              		.cfi_startproc
 1194              		@ args = 0, pretend = 0, frame = 0
 1195              		@ frame_needed = 0, uses_anonymous_args = 0
 934:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SOF_EVENT
 1196              		.loc 1 934 5 view .LVU350
 933:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udc_sof_notify();
 1197              		.loc 1 933 79 is_stmt 0 view .LVU351
 1198 0000 08B5     		push	{r3, lr}
 1199              		.cfi_def_cfa_offset 8
 1200              		.cfi_offset 3, -8
 1201              		.cfi_offset 14, -4
 934:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SOF_EVENT
 1202              		.loc 1 934 5 view .LVU352
 1203 0002 FFF7FEFF 		bl	udc_sof_notify
 1204              	.LVL85:
 936:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1205              		.loc 1 936 5 is_stmt 1 view .LVU353
 938:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1206              		.loc 1 938 1 is_stmt 0 view .LVU354
 1207 0006 BDE80840 		pop	{r3, lr}
 1208              		.cfi_restore 14
 1209              		.cfi_restore 3
 1210              		.cfi_def_cfa_offset 0
 936:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1211              		.loc 1 936 5 view .LVU355
 1212 000a FFF7FEBF 		b	main_sof_action
 1213              	.LVL86:
 1214              		.cfi_endproc
 1215              	.LFE175:
 1217              		.section	.text._usb_on_suspend,"ax",%progbits
 1218              		.align	1
 1219              		.syntax unified
 1220              		.thumb
 1221              		.thumb_func
 1222              		.fpu fpv4-sp-d16
 1224              	_usb_on_suspend:
 1225              	.LVL87:
 1226              	.LFB174:
 895:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 1227              		.loc 1 895 76 is_stmt 1 view -0
 1228              		.cfi_startproc
 1229              		@ args = 0, pretend = 0, frame = 0
 1230              		@ frame_needed = 0, uses_anonymous_args = 0
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 1231              		.loc 1 896 5 view .LVU357
 895:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_disable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 1232              		.loc 1 895 76 is_stmt 0 view .LVU358
 1233 0000 10B5     		push	{r4, lr}
 1234              		.cfi_def_cfa_offset 8
 1235              		.cfi_offset 4, -8
 1236              		.cfi_offset 14, -4
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 1237              		.loc 1 896 5 view .LVU359
 1238 0002 064C     		ldr	r4, .L88
 1239 0004 0421     		movs	r1, #4
 1240              	.LVL88:
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 1241              		.loc 1 896 5 view .LVU360
 1242 0006 2046     		mov	r0, r4
 1243              	.LVL89:
 896:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 1244              		.loc 1 896 5 view .LVU361
 1245 0008 FFF7FEFF 		bl	usb_device_disable_callback
 1246              	.LVL90:
 897:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 1247              		.loc 1 897 5 is_stmt 1 view .LVU362
 1248 000c 2046     		mov	r0, r4
 1249 000e 0221     		movs	r1, #2
 1250 0010 FFF7FEFF 		bl	usb_device_enable_callback
 1251              	.LVL91:
 898:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef UDC_SUSPEND_EVENT
 1252              		.loc 1 898 38 view .LVU363
 900:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1253              		.loc 1 900 5 view .LVU364
 902:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1254              		.loc 1 902 1 is_stmt 0 view .LVU365
 1255 0014 BDE81040 		pop	{r4, lr}
 1256              		.cfi_restore 14
 1257              		.cfi_restore 4
 1258              		.cfi_def_cfa_offset 0
 900:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 1259              		.loc 1 900 5 view .LVU366
 1260 0018 FFF7FEBF 		b	main_suspend_action
 1261              	.LVL92:
 1262              	.L89:
 1263              		.align	2
 1264              	.L88:
 1265 001c 00000000 		.word	usb_device
 1266              		.cfi_endproc
 1267              	.LFE174:
 1269              		.section	.text.udd_ep_abort,"ax",%progbits
 1270              		.align	1
 1271              		.global	udd_ep_abort
 1272              		.syntax unified
 1273              		.thumb
 1274              		.thumb_func
 1275              		.fpu fpv4-sp-d16
 1277              	udd_ep_abort:
 1278              	.LVL93:
 1279              	.LFB148:
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1280              		.loc 1 349 35 is_stmt 1 view -0
 1281              		.cfi_startproc
 1282              		@ args = 0, pretend = 0, frame = 0
 1283              		@ frame_needed = 0, uses_anonymous_args = 0
 350:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1284              		.loc 1 350 5 view .LVU368
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1285              		.loc 1 352 5 view .LVU369
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1286              		.loc 1 349 35 is_stmt 0 view .LVU370
 1287 0000 10B5     		push	{r4, lr}
 1288              		.cfi_def_cfa_offset 8
 1289              		.cfi_offset 4, -8
 1290              		.cfi_offset 14, -4
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1291              		.loc 1 352 5 view .LVU371
 1292 0002 0146     		mov	r1, r0
 349:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 1293              		.loc 1 349 35 view .LVU372
 1294 0004 0446     		mov	r4, r0
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1295              		.loc 1 352 5 view .LVU373
 1296 0006 0A48     		ldr	r0, .L97
 1297              	.LVL94:
 352:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1298              		.loc 1 352 5 view .LVU374
 1299 0008 FFF7FEFF 		bl	usb_device_endpoint_abort_job
 1300              	.LVL95:
 355:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!ptr_job->busy) {
 1301              		.loc 1 355 5 is_stmt 1 view .LVU375
 355:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (!ptr_job->busy) {
 1302              		.loc 1 355 15 is_stmt 0 view .LVU376
 1303 000c 2046     		mov	r0, r4
 1304 000e FFF7FEFF 		bl	udd_ep_get_job
 1305              	.LVL96:
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1306              		.loc 1 356 5 is_stmt 1 view .LVU377
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1307              		.loc 1 356 9 is_stmt 0 view .LVU378
 1308 0012 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 356:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1309              		.loc 1 356 8 view .LVU379
 1310 0014 DA07     		lsls	r2, r3, #31
 1311 0016 0AD5     		bpl	.L90
 359:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 1312              		.loc 1 359 5 is_stmt 1 view .LVU380
 359:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (NULL != ptr_job->call_trans) {
 1313              		.loc 1 359 19 is_stmt 0 view .LVU381
 1314 0018 6FF30003 		bfc	r3, #0, #1
 1315 001c 8374     		strb	r3, [r0, #18]
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 1316              		.loc 1 360 5 is_stmt 1 view .LVU382
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 1317              		.loc 1 360 24 is_stmt 0 view .LVU383
 1318 001e 0368     		ldr	r3, [r0]
 360:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* It can be a Transfer or stall callback */
 1319              		.loc 1 360 8 view .LVU384
 1320 0020 2BB1     		cbz	r3, .L90
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1321              		.loc 1 362 9 is_stmt 1 view .LVU385
 1322 0022 2246     		mov	r2, r4
 1323 0024 C168     		ldr	r1, [r0, #12]
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1324              		.loc 1 364 1 is_stmt 0 view .LVU386
 1325 0026 BDE81040 		pop	{r4, lr}
 1326              		.cfi_remember_state
 1327              		.cfi_restore 14
 1328              		.cfi_restore 4
 1329              		.cfi_def_cfa_offset 0
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1330              		.loc 1 362 9 view .LVU387
 1331 002a 0120     		movs	r0, #1
 1332              	.LVL97:
 362:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1333              		.loc 1 362 9 view .LVU388
 1334 002c 1847     		bx	r3	@ indirect register sibling call
 1335              	.LVL98:
 1336              	.L90:
 1337              		.cfi_restore_state
 364:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1338              		.loc 1 364 1 view .LVU389
 1339 002e 10BD     		pop	{r4, pc}
 1340              	.L98:
 1341              		.align	2
 1342              	.L97:
 1343 0030 00000000 		.word	usb_device
 1344              		.cfi_endproc
 1345              	.LFE148:
 1347              		.section	.text.udd_is_high_speed,"ax",%progbits
 1348              		.align	1
 1349              		.global	udd_is_high_speed
 1350              		.syntax unified
 1351              		.thumb
 1352              		.thumb_func
 1353              		.fpu fpv4-sp-d16
 1355              	udd_is_high_speed:
 1356              	.LFB149:
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1357              		.loc 1 366 30 is_stmt 1 view -0
 1358              		.cfi_startproc
 1359              		@ args = 0, pretend = 0, frame = 0
 1360              		@ frame_needed = 0, uses_anonymous_args = 0
 1361              		@ link register save eliminated.
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1362              		.loc 1 366 32 view .LVU391
 366:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1363              		.loc 1 366 1 is_stmt 0 view .LVU392
 1364 0000 0020     		movs	r0, #0
 1365 0002 7047     		bx	lr
 1366              		.cfi_endproc
 1367              	.LFE149:
 1369              		.section	.text.udd_get_frame_number,"ax",%progbits
 1370              		.align	1
 1371              		.global	udd_get_frame_number
 1372              		.syntax unified
 1373              		.thumb
 1374              		.thumb_func
 1375              		.fpu fpv4-sp-d16
 1377              	udd_get_frame_number:
 1378              	.LFB150:
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1379              		.loc 1 368 37 is_stmt 1 view -0
 1380              		.cfi_startproc
 1381              		@ args = 0, pretend = 0, frame = 0
 1382              		@ frame_needed = 0, uses_anonymous_args = 0
 1383              		@ link register save eliminated.
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1384              		.loc 1 368 39 view .LVU394
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1385              		.loc 1 368 46 is_stmt 0 view .LVU395
 1386 0000 024B     		ldr	r3, .L101
 1387 0002 1B68     		ldr	r3, [r3]
 1388              	.LBB96:
 1389              	.LBI96:
 360:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 361:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 362:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the frame number of USB device
 363:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 364:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 365:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device frame number value.
 366:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 367:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint16_t usb_device_get_frame_number(struct usb_module *module_inst) { return ((uint1
 1390              		.loc 2 367 24 is_stmt 1 view .LVU396
 1391              	.LVL99:
 1392              	.LBB97:
 1393              		.loc 2 367 86 view .LVU397
 1394              		.loc 2 367 137 is_stmt 0 view .LVU398
 1395 0004 188A     		ldrh	r0, [r3, #16]
 1396              	.LBE97:
 1397              	.LBE96:
 368:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1398              		.loc 1 368 1 view .LVU399
 1399 0006 C0F3CA00 		ubfx	r0, r0, #3, #11
 1400 000a 7047     		bx	lr
 1401              	.L102:
 1402              		.align	2
 1403              	.L101:
 1404 000c 00000000 		.word	usb_device
 1405              		.cfi_endproc
 1406              	.LFE150:
 1408              		.section	.text.udd_get_micro_frame_number,"ax",%progbits
 1409              		.align	1
 1410              		.global	udd_get_micro_frame_number
 1411              		.syntax unified
 1412              		.thumb
 1413              		.thumb_func
 1414              		.fpu fpv4-sp-d16
 1416              	udd_get_micro_frame_number:
 1417              	.LFB151:
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1418              		.loc 1 370 43 is_stmt 1 view -0
 1419              		.cfi_startproc
 1420              		@ args = 0, pretend = 0, frame = 0
 1421              		@ frame_needed = 0, uses_anonymous_args = 0
 1422              		@ link register save eliminated.
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1423              		.loc 1 370 45 view .LVU401
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1424              		.loc 1 370 52 is_stmt 0 view .LVU402
 1425 0000 014B     		ldr	r3, .L104
 1426 0002 1B68     		ldr	r3, [r3]
 1427              	.LBB98:
 1428              	.LBI98:
 368:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 369:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 370:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief Get the micro-frame number of USB device
 371:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 372:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 373:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \return USB device micro-frame number value.
 374:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 375:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline uint16_t usb_device_get_micro_frame_number(struct usb_module *module_inst) { return (
 1429              		.loc 2 375 24 is_stmt 1 view .LVU403
 1430              	.LVL100:
 1431              	.LBB99:
 1432              		.loc 2 375 92 view .LVU404
 1433              		.loc 2 375 100 is_stmt 0 view .LVU405
 1434 0004 188A     		ldrh	r0, [r3, #16]
 1435              	.LBE99:
 1436              	.LBE98:
 370:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1437              		.loc 1 370 1 view .LVU406
 1438 0006 7047     		bx	lr
 1439              	.L105:
 1440              		.align	2
 1441              	.L104:
 1442 0008 00000000 		.word	usb_device
 1443              		.cfi_endproc
 1444              	.LFE151:
 1446              		.section	.text.udd_ep_free,"ax",%progbits
 1447              		.align	1
 1448              		.global	udd_ep_free
 1449              		.syntax unified
 1450              		.thumb
 1451              		.thumb_func
 1452              		.fpu fpv4-sp-d16
 1454              	udd_ep_free:
 1455              	.LVL101:
 1456              	.LFB152:
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1457              		.loc 1 372 34 is_stmt 1 view -0
 1458              		.cfi_startproc
 1459              		@ args = 0, pretend = 0, frame = 8
 1460              		@ frame_needed = 0, uses_anonymous_args = 0
 373:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 1461              		.loc 1 373 5 view .LVU408
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1462              		.loc 1 374 5 view .LVU409
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1463              		.loc 1 372 34 is_stmt 0 view .LVU410
 1464 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1465              		.cfi_def_cfa_offset 24
 1466              		.cfi_offset 4, -16
 1467              		.cfi_offset 5, -12
 1468              		.cfi_offset 6, -8
 1469              		.cfi_offset 14, -4
 372:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1470              		.loc 1 372 34 view .LVU411
 1471 0002 0446     		mov	r4, r0
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1472              		.loc 1 381 5 view .LVU412
 1473 0004 0E4D     		ldr	r5, .L107
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1474              		.loc 1 374 5 view .LVU413
 1475 0006 01A8     		add	r0, sp, #4
 1476              	.LVL102:
 374:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1477              		.loc 1 374 5 view .LVU414
 1478 0008 FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 1479              	.LVL103:
 376:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_abort(ep);
 1480              		.loc 1 376 5 is_stmt 1 view .LVU415
 377:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1481              		.loc 1 377 5 view .LVU416
 1482 000c 2046     		mov	r0, r4
 1483 000e FFF7FEFF 		bl	udd_ep_abort
 1484              	.LVL104:
 379:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_type    = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
 1485              		.loc 1 379 5 view .LVU417
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 1486              		.loc 1 380 26 is_stmt 0 view .LVU418
 1487 0012 0026     		movs	r6, #0
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1488              		.loc 1 381 5 view .LVU419
 1489 0014 01A9     		add	r1, sp, #4
 1490 0016 2846     		mov	r0, r5
 379:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_ep.ep_type    = USB_DEVICE_ENDPOINT_TYPE_DISABLE;
 1491              		.loc 1 379 26 view .LVU420
 1492 0018 8DF80440 		strb	r4, [sp, #4]
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 1493              		.loc 1 380 5 is_stmt 1 view .LVU421
 380:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_set_config(&usb_device, &config_ep);
 1494              		.loc 1 380 26 is_stmt 0 view .LVU422
 1495 001c 8DF80760 		strb	r6, [sp, #7]
 381:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_unregister_callback(&usb_device, ep_num, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT
 1496              		.loc 1 381 5 is_stmt 1 view .LVU423
 1497 0020 FFF7FEFF 		bl	usb_device_endpoint_set_config
 1498              	.LVL105:
 382:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_disable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 1499              		.loc 1 382 5 view .LVU424
 1500 0024 3246     		mov	r2, r6
 1501 0026 04F00F01 		and	r1, r4, #15
 1502 002a 2846     		mov	r0, r5
 1503 002c FFF7FEFF 		bl	usb_device_endpoint_unregister_callback
 1504              	.LVL106:
 383:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1505              		.loc 1 383 5 view .LVU425
 1506 0030 3246     		mov	r2, r6
 1507 0032 2146     		mov	r1, r4
 1508 0034 2846     		mov	r0, r5
 1509 0036 FFF7FEFF 		bl	usb_device_endpoint_disable_callback
 1510              	.LVL107:
 384:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1511              		.loc 1 384 1 is_stmt 0 view .LVU426
 1512 003a 02B0     		add	sp, sp, #8
 1513              		.cfi_def_cfa_offset 16
 1514              		@ sp needed
 1515 003c 70BD     		pop	{r4, r5, r6, pc}
 1516              	.LVL108:
 1517              	.L108:
 384:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1518              		.loc 1 384 1 view .LVU427
 1519 003e 00BF     		.align	2
 1520              	.L107:
 1521 0040 00000000 		.word	usb_device
 1522              		.cfi_endproc
 1523              	.LFE152:
 1525              		.section	.text.udd_ep_alloc,"ax",%progbits
 1526              		.align	1
 1527              		.global	udd_ep_alloc
 1528              		.syntax unified
 1529              		.thumb
 1530              		.thumb_func
 1531              		.fpu fpv4-sp-d16
 1533              	udd_ep_alloc:
 1534              	.LVL109:
 1535              	.LFB153:
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1536              		.loc 1 386 83 is_stmt 1 view -0
 1537              		.cfi_startproc
 1538              		@ args = 0, pretend = 0, frame = 8
 1539              		@ frame_needed = 0, uses_anonymous_args = 0
 387:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_get_config_defaults(&config_ep);
 1540              		.loc 1 387 5 view .LVU429
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1541              		.loc 1 388 5 view .LVU430
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1542              		.loc 1 386 83 is_stmt 0 view .LVU431
 1543 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1544              		.cfi_def_cfa_offset 24
 1545              		.cfi_offset 4, -16
 1546              		.cfi_offset 5, -12
 1547              		.cfi_offset 6, -8
 1548              		.cfi_offset 14, -4
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1549              		.loc 1 386 83 view .LVU432
 1550 0002 0546     		mov	r5, r0
 1551 0004 1446     		mov	r4, r2
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1552              		.loc 1 388 5 view .LVU433
 1553 0006 01A8     		add	r0, sp, #4
 1554              	.LVL110:
 386:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_device_endpoint_config config_ep;
 1555              		.loc 1 386 83 view .LVU434
 1556 0008 0E46     		mov	r6, r1
 388:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1557              		.loc 1 388 5 view .LVU435
 1558 000a FFF7FEFF 		bl	usb_device_endpoint_get_config_defaults
 1559              	.LVL111:
 390:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1560              		.loc 1 390 5 is_stmt 1 view .LVU436
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 1561              		.loc 1 392 8 is_stmt 0 view .LVU437
 1562 000e 082C     		cmp	r4, #8
 390:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1563              		.loc 1 390 26 view .LVU438
 1564 0010 8DF80450 		strb	r5, [sp, #4]
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 1565              		.loc 1 392 5 is_stmt 1 view .LVU439
 392:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_8_BYTE;
 1566              		.loc 1 392 8 is_stmt 0 view .LVU440
 1567 0014 26D8     		bhi	.L110
 393:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 16) {
 1568              		.loc 1 393 9 is_stmt 1 view .LVU441
 393:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 16) {
 1569              		.loc 1 393 27 is_stmt 0 view .LVU442
 1570 0016 0023     		movs	r3, #0
 1571              	.L124:
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 1572              		.loc 1 411 29 view .LVU443
 1573 0018 2846     		mov	r0, r5
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1574              		.loc 1 407 27 view .LVU444
 1575 001a 8DF80530 		strb	r3, [sp, #5]
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 1576              		.loc 1 411 5 is_stmt 1 view .LVU445
 411:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->ep_size      = MaxEndpointSize;
 1577              		.loc 1 411 29 is_stmt 0 view .LVU446
 1578 001e FFF7FEFF 		bl	udd_ep_get_job
 1579              	.LVL112:
 412:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1580              		.loc 1 412 5 is_stmt 1 view .LVU447
 414:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1581              		.loc 1 414 18 is_stmt 0 view .LVU448
 1582 0022 06F00301 		and	r1, r6, #3
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 1583              		.loc 1 417 8 view .LVU449
 1584 0026 0129     		cmp	r1, #1
 412:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1585              		.loc 1 412 27 view .LVU450
 1586 0028 0482     		strh	r4, [r0, #16]	@ movhi
 414:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1587              		.loc 1 414 5 is_stmt 1 view .LVU451
 1588              	.LVL113:
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 1589              		.loc 1 417 5 view .LVU452
 417:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_ISOCHRONOUS;
 1590              		.loc 1 417 8 is_stmt 0 view .LVU453
 1591 002a 3DD1     		bne	.L120
 418:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_BULK == bmAttributes) {
 1592              		.loc 1 418 9 is_stmt 1 view .LVU454
 418:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_BULK == bmAttributes) {
 1593              		.loc 1 418 27 is_stmt 0 view .LVU455
 1594 002c 0223     		movs	r3, #2
 1595              	.L125:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1596              		.loc 1 429 22 view .LVU456
 1597 002e 01A9     		add	r1, sp, #4
 1598              	.LVL114:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1599              		.loc 1 429 22 view .LVU457
 1600 0030 2148     		ldr	r0, .L126
 1601              	.LVL115:
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1602              		.loc 1 422 27 view .LVU458
 1603 0032 8DF80730 		strb	r3, [sp, #7]
 427:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1604              		.loc 1 427 5 is_stmt 1 view .LVU459
 1605              	.LVL116:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1606              		.loc 1 429 5 view .LVU460
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1607              		.loc 1 429 22 is_stmt 0 view .LVU461
 1608 0036 FFF7FEFF 		bl	usb_device_endpoint_set_config
 1609              	.LVL117:
 429:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1610              		.loc 1 429 8 view .LVU462
 1611 003a 0446     		mov	r4, r0
 1612 003c 78BB     		cbnz	r0, .L123
 432:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRCPT);
 1613              		.loc 1 432 5 is_stmt 1 view .LVU463
 1614 003e 1F4B     		ldr	r3, .L126+4
 1615 0040 0246     		mov	r2, r0
 1616 0042 05F00F01 		and	r1, r5, #15
 1617 0046 1C48     		ldr	r0, .L126
 1618 0048 FFF7FEFF 		bl	usb_device_endpoint_register_callback
 1619              	.LVL118:
 433:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_endpoint_enable_callback(&usb_device, ep, USB_DEVICE_ENDPOINT_CALLBACK_TRFAIL);
 1620              		.loc 1 433 5 view .LVU464
 1621 004c 2246     		mov	r2, r4
 1622 004e 2946     		mov	r1, r5
 1623 0050 1948     		ldr	r0, .L126
 1624 0052 FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 1625              	.LVL119:
 434:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1626              		.loc 1 434 5 view .LVU465
 1627 0056 0122     		movs	r2, #1
 1628 0058 2946     		mov	r1, r5
 1629 005a 1748     		ldr	r0, .L126
 1630 005c FFF7FEFF 		bl	usb_device_endpoint_enable_callback
 1631              	.LVL120:
 436:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1632              		.loc 1 436 5 view .LVU466
 436:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1633              		.loc 1 436 12 is_stmt 0 view .LVU467
 1634 0060 0120     		movs	r0, #1
 1635 0062 1DE0     		b	.L119
 1636              	.LVL121:
 1637              	.L110:
 394:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_16_BYTE;
 1638              		.loc 1 394 12 is_stmt 1 view .LVU468
 394:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_16_BYTE;
 1639              		.loc 1 394 15 is_stmt 0 view .LVU469
 1640 0064 102C     		cmp	r4, #16
 1641 0066 01D8     		bhi	.L112
 395:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 32) {
 1642              		.loc 1 395 9 is_stmt 1 view .LVU470
 395:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 32) {
 1643              		.loc 1 395 27 is_stmt 0 view .LVU471
 1644 0068 0123     		movs	r3, #1
 1645 006a D5E7     		b	.L124
 1646              	.L112:
 396:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_32_BYTE;
 1647              		.loc 1 396 12 is_stmt 1 view .LVU472
 396:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_32_BYTE;
 1648              		.loc 1 396 15 is_stmt 0 view .LVU473
 1649 006c 202C     		cmp	r4, #32
 1650 006e 01D8     		bhi	.L113
 397:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 64) {
 1651              		.loc 1 397 9 is_stmt 1 view .LVU474
 397:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 64) {
 1652              		.loc 1 397 27 is_stmt 0 view .LVU475
 1653 0070 0223     		movs	r3, #2
 1654 0072 D1E7     		b	.L124
 1655              	.L113:
 398:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_64_BYTE;
 1656              		.loc 1 398 12 is_stmt 1 view .LVU476
 398:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_64_BYTE;
 1657              		.loc 1 398 15 is_stmt 0 view .LVU477
 1658 0074 402C     		cmp	r4, #64
 1659 0076 01D8     		bhi	.L114
 399:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 128) {
 1660              		.loc 1 399 9 is_stmt 1 view .LVU478
 399:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 128) {
 1661              		.loc 1 399 27 is_stmt 0 view .LVU479
 1662 0078 0323     		movs	r3, #3
 1663 007a CDE7     		b	.L124
 1664              	.L114:
 400:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_128_BYTE;
 1665              		.loc 1 400 12 is_stmt 1 view .LVU480
 400:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_128_BYTE;
 1666              		.loc 1 400 15 is_stmt 0 view .LVU481
 1667 007c 802C     		cmp	r4, #128
 1668 007e 01D8     		bhi	.L115
 401:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 256) {
 1669              		.loc 1 401 9 is_stmt 1 view .LVU482
 401:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 256) {
 1670              		.loc 1 401 27 is_stmt 0 view .LVU483
 1671 0080 0423     		movs	r3, #4
 1672 0082 C9E7     		b	.L124
 1673              	.L115:
 402:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_256_BYTE;
 1674              		.loc 1 402 12 is_stmt 1 view .LVU484
 402:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_256_BYTE;
 1675              		.loc 1 402 15 is_stmt 0 view .LVU485
 1676 0084 B4F5807F 		cmp	r4, #256
 1677 0088 01D8     		bhi	.L116
 403:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 512) {
 1678              		.loc 1 403 9 is_stmt 1 view .LVU486
 403:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 512) {
 1679              		.loc 1 403 27 is_stmt 0 view .LVU487
 1680 008a 0523     		movs	r3, #5
 1681 008c C4E7     		b	.L124
 1682              	.L116:
 404:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_512_BYTE;
 1683              		.loc 1 404 12 is_stmt 1 view .LVU488
 404:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_512_BYTE;
 1684              		.loc 1 404 15 is_stmt 0 view .LVU489
 1685 008e B4F5007F 		cmp	r4, #512
 1686 0092 01D8     		bhi	.L117
 405:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 1023) {
 1687              		.loc 1 405 9 is_stmt 1 view .LVU490
 405:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (MaxEndpointSize <= 1023) {
 1688              		.loc 1 405 27 is_stmt 0 view .LVU491
 1689 0094 0623     		movs	r3, #6
 1690 0096 BFE7     		b	.L124
 1691              	.L117:
 406:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
 1692              		.loc 1 406 12 is_stmt 1 view .LVU492
 406:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_size = USB_ENDPOINT_1023_BYTE;
 1693              		.loc 1 406 15 is_stmt 0 view .LVU493
 1694 0098 B4F5806F 		cmp	r4, #1024
 1695 009c 02D3     		bcc	.L118
 1696              	.LVL122:
 1697              	.L123:
 409:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1698              		.loc 1 409 16 view .LVU494
 1699 009e 0020     		movs	r0, #0
 1700              	.L119:
 437:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1701              		.loc 1 437 1 view .LVU495
 1702 00a0 02B0     		add	sp, sp, #8
 1703              		.cfi_remember_state
 1704              		.cfi_def_cfa_offset 16
 1705              		@ sp needed
 1706 00a2 70BD     		pop	{r4, r5, r6, pc}
 1707              	.LVL123:
 1708              	.L118:
 1709              		.cfi_restore_state
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1710              		.loc 1 407 9 is_stmt 1 view .LVU496
 407:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1711              		.loc 1 407 27 is_stmt 0 view .LVU497
 1712 00a4 0723     		movs	r3, #7
 1713 00a6 B7E7     		b	.L124
 1714              	.LVL124:
 1715              	.L120:
 419:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
 1716              		.loc 1 419 12 is_stmt 1 view .LVU498
 419:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_BULK;
 1717              		.loc 1 419 15 is_stmt 0 view .LVU499
 1718 00a8 0229     		cmp	r1, #2
 1719 00aa 01D1     		bne	.L122
 420:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
 1720              		.loc 1 420 9 is_stmt 1 view .LVU500
 420:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (USB_EP_TYPE_INTERRUPT == bmAttributes) {
 1721              		.loc 1 420 27 is_stmt 0 view .LVU501
 1722 00ac 0323     		movs	r3, #3
 1723 00ae BEE7     		b	.L125
 1724              	.L122:
 421:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
 1725              		.loc 1 421 12 is_stmt 1 view .LVU502
 421:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         config_ep.ep_type = USB_DEVICE_ENDPOINT_TYPE_INTERRUPT;
 1726              		.loc 1 421 15 is_stmt 0 view .LVU503
 1727 00b0 0329     		cmp	r1, #3
 1728 00b2 F4D1     		bne	.L123
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1729              		.loc 1 422 9 is_stmt 1 view .LVU504
 422:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 1730              		.loc 1 422 27 is_stmt 0 view .LVU505
 1731 00b4 0423     		movs	r3, #4
 1732 00b6 BAE7     		b	.L125
 1733              	.L127:
 1734              		.align	2
 1735              	.L126:
 1736 00b8 00000000 		.word	usb_device
 1737 00bc 00000000 		.word	udd_ep_transfer_process
 1738              		.cfi_endproc
 1739              	.LFE153:
 1741              		.section	.text.udd_ep_is_halted,"ax",%progbits
 1742              		.align	1
 1743              		.global	udd_ep_is_halted
 1744              		.syntax unified
 1745              		.thumb
 1746              		.thumb_func
 1747              		.fpu fpv4-sp-d16
 1749              	udd_ep_is_halted:
 1750              	.LVL125:
 1751              	.LFB154:
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1752              		.loc 1 439 39 is_stmt 1 view -0
 1753              		.cfi_startproc
 1754              		@ args = 0, pretend = 0, frame = 0
 1755              		@ frame_needed = 0, uses_anonymous_args = 0
 1756              		@ link register save eliminated.
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1757              		.loc 1 439 41 view .LVU507
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1758              		.loc 1 439 48 is_stmt 0 view .LVU508
 1759 0000 0146     		mov	r1, r0
 1760 0002 0148     		ldr	r0, .L129
 1761              	.LVL126:
 439:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1762              		.loc 1 439 48 view .LVU509
 1763 0004 FFF7FEBF 		b	usb_device_endpoint_is_halted
 1764              	.LVL127:
 1765              	.L130:
 1766              		.align	2
 1767              	.L129:
 1768 0008 00000000 		.word	usb_device
 1769              		.cfi_endproc
 1770              	.LFE154:
 1772              		.section	.text.udd_ep_set_halt,"ax",%progbits
 1773              		.align	1
 1774              		.global	udd_ep_set_halt
 1775              		.syntax unified
 1776              		.thumb
 1777              		.thumb_func
 1778              		.fpu fpv4-sp-d16
 1780              	udd_ep_set_halt:
 1781              	.LVL128:
 1782              	.LFB155:
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1783              		.loc 1 441 38 is_stmt 1 view -0
 1784              		.cfi_startproc
 1785              		@ args = 0, pretend = 0, frame = 0
 1786              		@ frame_needed = 0, uses_anonymous_args = 0
 442:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1787              		.loc 1 442 5 view .LVU511
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1788              		.loc 1 444 5 view .LVU512
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1789              		.loc 1 444 8 is_stmt 0 view .LVU513
 1790 0000 00F00F03 		and	r3, r0, #15
 1791 0004 042B     		cmp	r3, #4
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1792              		.loc 1 441 38 view .LVU514
 1793 0006 10B5     		push	{r4, lr}
 1794              		.cfi_def_cfa_offset 8
 1795              		.cfi_offset 4, -8
 1796              		.cfi_offset 14, -4
 441:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t ep_num = ep & USB_EP_ADDR_MASK;
 1797              		.loc 1 441 38 view .LVU515
 1798 0008 0446     		mov	r4, r0
 444:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 1799              		.loc 1 444 8 view .LVU516
 1800 000a 08D8     		bhi	.L133
 448:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1801              		.loc 1 448 5 is_stmt 1 view .LVU517
 1802 000c 0146     		mov	r1, r0
 1803 000e 0548     		ldr	r0, .L134
 1804              	.LVL129:
 448:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1805              		.loc 1 448 5 is_stmt 0 view .LVU518
 1806 0010 FFF7FEFF 		bl	usb_device_endpoint_set_halt
 1807              	.LVL130:
 450:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     return true;
 1808              		.loc 1 450 5 is_stmt 1 view .LVU519
 1809 0014 2046     		mov	r0, r4
 1810 0016 FFF7FEFF 		bl	udd_ep_abort
 1811              	.LVL131:
 451:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1812              		.loc 1 451 5 view .LVU520
 451:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 1813              		.loc 1 451 12 is_stmt 0 view .LVU521
 1814 001a 0120     		movs	r0, #1
 1815              	.L132:
 452:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1816              		.loc 1 452 1 view .LVU522
 1817 001c 10BD     		pop	{r4, pc}
 1818              	.LVL132:
 1819              	.L133:
 445:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1820              		.loc 1 445 16 view .LVU523
 1821 001e 0020     		movs	r0, #0
 1822              	.LVL133:
 445:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1823              		.loc 1 445 16 view .LVU524
 1824 0020 FCE7     		b	.L132
 1825              	.L135:
 1826 0022 00BF     		.align	2
 1827              	.L134:
 1828 0024 00000000 		.word	usb_device
 1829              		.cfi_endproc
 1830              	.LFE155:
 1832              		.section	.text._usb_ep0_on_tansfer_ok,"ax",%progbits
 1833              		.align	1
 1834              		.syntax unified
 1835              		.thumb
 1836              		.thumb_func
 1837              		.fpu fpv4-sp-d16
 1839              	_usb_ep0_on_tansfer_ok:
 1840              	.LVL134:
 1841              	.LFB172:
 847:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) { /* handshake Out for status stage */
 1842              		.loc 1 847 83 is_stmt 1 view -0
 1843              		.cfi_startproc
 1844              		@ args = 0, pretend = 0, frame = 0
 1845              		@ frame_needed = 0, uses_anonymous_args = 0
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 1846              		.loc 1 848 5 view .LVU526
 847:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) { /* handshake Out for status stage */
 1847              		.loc 1 847 83 is_stmt 0 view .LVU527
 1848 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1849              		.cfi_def_cfa_offset 24
 1850              		.cfi_offset 4, -24
 1851              		.cfi_offset 5, -20
 1852              		.cfi_offset 6, -16
 1853              		.cfi_offset 7, -12
 1854              		.cfi_offset 8, -8
 1855              		.cfi_offset 14, -4
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 1856              		.loc 1 848 29 view .LVU528
 1857 0004 2D4C     		ldr	r4, .L158
 1858 0006 94F8A030 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 848:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_out_received(pointer);
 1859              		.loc 1 848 8 view .LVU529
 1860 000a 012B     		cmp	r3, #1
 1861 000c 47D1     		bne	.L137
 849:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (UDD_EPCTRL_DATA_IN == udd_ep_control_state) { /* handshake In for status stage */
 1862              		.loc 1 849 9 is_stmt 1 view .LVU530
 1863              	.LVL135:
 1864              	.LBB102:
 1865              	.LBI102:
 681:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_endpoint_callback_parameter *ep_callback_para = (struct usb_endpoint_callback_parame
 1866              		.loc 1 681 13 view .LVU531
 1867              	.LBB103:
 682:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1868              		.loc 1 682 5 view .LVU532
 684:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     nb_data = ep_callback_para->received_bytes; /* Read data received during OUT phase */
 1869              		.loc 1 684 5 view .LVU533
 685:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1870              		.loc 1 685 5 view .LVU534
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1871              		.loc 1 687 22 is_stmt 0 view .LVU535
 1872 000e 2C4E     		ldr	r6, .L158+4
 685:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1873              		.loc 1 685 13 view .LVU536
 1874 0010 0F88     		ldrh	r7, [r1]
 1875              	.LVL136:
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1876              		.loc 1 687 5 is_stmt 1 view .LVU537
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1877              		.loc 1 687 65 is_stmt 0 view .LVU538
 1878 0012 B4F8A250 		ldrh	r5, [r4, #162]
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1879              		.loc 1 687 22 view .LVU539
 1880 0016 B389     		ldrh	r3, [r6, #12]
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1881              		.loc 1 692 12 view .LVU540
 1882 0018 B068     		ldr	r0, [r6, #8]
 1883              	.LVL137:
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1884              		.loc 1 692 5 view .LVU541
 1885 001a 2A49     		ldr	r1, .L158+8
 1886              	.LVL138:
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1887              		.loc 1 687 65 view .LVU542
 1888 001c EA19     		adds	r2, r5, r7
 687:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Payload buffer too small */
 1889              		.loc 1 687 8 view .LVU543
 1890 001e 9342     		cmp	r3, r2
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1891              		.loc 1 689 9 is_stmt 1 view .LVU544
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1892              		.loc 1 689 17 is_stmt 0 view .LVU545
 1893 0020 BCBF     		itt	lt
 1894 0022 5F1B     		sublt	r7, r3, r5
 1895              	.LVL139:
 689:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 1896              		.loc 1 689 17 view .LVU546
 1897 0024 BFB2     		uxthlt	r7, r7
 1898              	.LVL140:
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1899              		.loc 1 692 5 is_stmt 1 view .LVU547
 1900 0026 2844     		add	r0, r0, r5
 1901 0028 3A46     		mov	r2, r7
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1902              		.loc 1 693 31 is_stmt 0 view .LVU548
 1903 002a 3D44     		add	r5, r5, r7
 692:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ctrl_payload_nb_trans += nb_data;
 1904              		.loc 1 692 5 view .LVU549
 1905 002c FFF7FEFF 		bl	memcpy
 1906              	.LVL141:
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1907              		.loc 1 693 5 is_stmt 1 view .LVU550
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1908              		.loc 1 693 31 is_stmt 0 view .LVU551
 1909 0030 ADB2     		uxth	r5, r5
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1910              		.loc 1 695 8 view .LVU552
 1911 0032 082F     		cmp	r7, #8
 693:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1912              		.loc 1 693 31 view .LVU553
 1913 0034 A4F8A250 		strh	r5, [r4, #162]	@ movhi
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1914              		.loc 1 695 5 is_stmt 1 view .LVU554
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1915              		.loc 1 695 8 is_stmt 0 view .LVU555
 1916 0038 05D1     		bne	.L139
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1917              		.loc 1 695 111 view .LVU556
 1918 003a B4F8A430 		ldrh	r3, [r4, #164]
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1919              		.loc 1 695 67 view .LVU557
 1920 003e F288     		ldrh	r2, [r6, #6]
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1921              		.loc 1 695 111 view .LVU558
 1922 0040 2B44     		add	r3, r3, r5
 695:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* End of reception because it is a short packet
 1923              		.loc 1 695 46 view .LVU559
 1924 0042 9A42     		cmp	r2, r3
 1925 0044 10DC     		bgt	.L140
 1926              	.L139:
 701:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.over_under_run) {
 1927              		.loc 1 701 9 is_stmt 1 view .LVU560
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 1928              		.loc 1 702 34 is_stmt 0 view .LVU561
 1929 0046 7369     		ldr	r3, [r6, #20]
 701:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (NULL != udd_g_ctrlreq.over_under_run) {
 1930              		.loc 1 701 36 view .LVU562
 1931 0048 B581     		strh	r5, [r6, #12]	@ movhi
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 1932              		.loc 1 702 9 is_stmt 1 view .LVU563
 702:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (!udd_g_ctrlreq.over_under_run()) {
 1933              		.loc 1 702 12 is_stmt 0 view .LVU564
 1934 004a 4BB1     		cbz	r3, .L141
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 1935              		.loc 1 703 13 is_stmt 1 view .LVU565
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 1936              		.loc 1 703 18 is_stmt 0 view .LVU566
 1937 004c 9847     		blx	r3
 1938              	.LVL142:
 703:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall ZLP */
 1939              		.loc 1 703 16 view .LVU567
 1940 004e 38B9     		cbnz	r0, .L141
 1941              	.L143:
 705:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall all packets on IN & OUT control endpoint */
 1942              		.loc 1 705 17 is_stmt 1 view .LVU568
 705:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Stall all packets on IN & OUT control endpoint */
 1943              		.loc 1 705 38 is_stmt 0 view .LVU569
 1944 0050 0523     		movs	r3, #5
 1945 0052 84F8A030 		strb	r3, [r4, #160]
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 1946              		.loc 1 707 17 is_stmt 1 view .LVU570
 1947 0056 0020     		movs	r0, #0
 1948              	.LBE103:
 1949              	.LBE102:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1950              		.loc 1 858 1 is_stmt 0 view .LVU571
 1951 0058 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1952              		.cfi_remember_state
 1953              		.cfi_restore 14
 1954              		.cfi_restore 8
 1955              		.cfi_restore 7
 1956              		.cfi_restore 6
 1957              		.cfi_restore 5
 1958              		.cfi_restore 4
 1959              		.cfi_def_cfa_offset 0
 1960              	.LVL143:
 1961              	.LBB107:
 1962              	.LBB104:
 707:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* Ack reception of OUT to replace NAK by a STALL */
 1963              		.loc 1 707 17 view .LVU572
 1964 005c FFF7FEBF 		b	udd_ep_set_halt
 1965              	.LVL144:
 1966              	.L141:
 1967              		.cfi_restore_state
 713:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1968              		.loc 1 713 9 is_stmt 1 view .LVU573
 1969              	.LBE104:
 1970              	.LBE107:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 1971              		.loc 1 858 1 is_stmt 0 view .LVU574
 1972 0060 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1973              		.cfi_remember_state
 1974              		.cfi_restore 14
 1975              		.cfi_restore 8
 1976              		.cfi_restore 7
 1977              		.cfi_restore 6
 1978              		.cfi_restore 5
 1979              		.cfi_restore 4
 1980              		.cfi_def_cfa_offset 0
 1981              	.LVL145:
 1982              	.LBB108:
 1983              	.LBB105:
 713:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return;
 1984              		.loc 1 713 9 view .LVU575
 1985 0064 FFF7FEBF 		b	udd_ctrl_send_zlp_in
 1986              	.LVL146:
 1987              	.L140:
 1988              		.cfi_restore_state
 717:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Overrun then request a new payload buffer */
 1989              		.loc 1 717 5 is_stmt 1 view .LVU576
 717:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Overrun then request a new payload buffer */
 1990              		.loc 1 717 8 is_stmt 0 view .LVU577
 1991 0068 B389     		ldrh	r3, [r6, #12]
 1992 006a AB42     		cmp	r3, r5
 1993 006c 0FD1     		bne	.L142
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 1994              		.loc 1 719 9 is_stmt 1 view .LVU578
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 1995              		.loc 1 719 27 is_stmt 0 view .LVU579
 1996 006e 7369     		ldr	r3, [r6, #20]
 719:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No callback available to request a new payload buffer
 1997              		.loc 1 719 12 view .LVU580
 1998 0070 002B     		cmp	r3, #0
 1999 0072 EDD0     		beq	.L143
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 2000              		.loc 1 727 9 is_stmt 1 view .LVU581
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 2001              		.loc 1 727 14 is_stmt 0 view .LVU582
 2002 0074 9847     		blx	r3
 2003              	.LVL147:
 727:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             /* No new payload buffer delivered
 2004              		.loc 1 727 12 view .LVU583
 2005 0076 0028     		cmp	r0, #0
 2006 0078 EAD0     		beq	.L143
 737:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2007              		.loc 1 737 9 is_stmt 1 view .LVU584
 737:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2008              		.loc 1 737 40 is_stmt 0 view .LVU585
 2009 007a B4F8A430 		ldrh	r3, [r4, #164]
 2010 007e B4F8A220 		ldrh	r2, [r4, #162]
 2011 0082 1344     		add	r3, r3, r2
 2012 0084 A4F8A430 		strh	r3, [r4, #164]	@ movhi
 740:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2013              		.loc 1 740 9 is_stmt 1 view .LVU586
 740:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2014              		.loc 1 740 35 is_stmt 0 view .LVU587
 2015 0088 0023     		movs	r3, #0
 2016 008a A4F8A230 		strh	r3, [r4, #162]	@ movhi
 2017              	.L142:
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2018              		.loc 1 742 5 is_stmt 1 view .LVU588
 2019 008e 0823     		movs	r3, #8
 2020 0090 0C4A     		ldr	r2, .L158+8
 2021 0092 0D48     		ldr	r0, .L158+12
 2022 0094 0021     		movs	r1, #0
 2023              	.LBE105:
 2024              	.LBE108:
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2025              		.loc 1 858 1 is_stmt 0 view .LVU589
 2026 0096 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 2027              		.cfi_remember_state
 2028              		.cfi_restore 14
 2029              		.cfi_restore 8
 2030              		.cfi_restore 7
 2031              		.cfi_restore 6
 2032              		.cfi_restore 5
 2033              		.cfi_restore 4
 2034              		.cfi_def_cfa_offset 0
 2035              	.LVL148:
 2036              	.LBB109:
 2037              	.LBB106:
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2038              		.loc 1 742 5 view .LVU590
 2039 009a FFF7FEBF 		b	usb_device_endpoint_read_buffer_job
 2040              	.LVL149:
 2041              	.L137:
 2042              		.cfi_restore_state
 742:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2043              		.loc 1 742 5 view .LVU591
 2044              	.LBE106:
 2045              	.LBE109:
 850:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_in_sent();
 2046              		.loc 1 850 12 is_stmt 1 view .LVU592
 850:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         udd_ctrl_in_sent();
 2047              		.loc 1 850 15 is_stmt 0 view .LVU593
 2048 009e 022B     		cmp	r3, #2
 2049 00a0 03D1     		bne	.L144
 851:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2050              		.loc 1 851 9 is_stmt 1 view .LVU594
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2051              		.loc 1 858 1 is_stmt 0 view .LVU595
 2052 00a2 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 2053              		.cfi_remember_state
 2054              		.cfi_restore 14
 2055              		.cfi_restore 8
 2056              		.cfi_restore 7
 2057              		.cfi_restore 6
 2058              		.cfi_restore 5
 2059              		.cfi_restore 4
 2060              		.cfi_def_cfa_offset 0
 851:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2061              		.loc 1 851 9 view .LVU596
 2062 00a6 FFF7FEBF 		b	udd_ctrl_in_sent
 2063              	.LVL150:
 2064              	.L144:
 2065              		.cfi_restore_state
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 2066              		.loc 1 853 9 is_stmt 1 view .LVU597
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 2067              		.loc 1 853 34 is_stmt 0 view .LVU598
 2068 00aa 054B     		ldr	r3, .L158+4
 2069 00ac 1B69     		ldr	r3, [r3, #16]
 853:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             udd_g_ctrlreq.callback();
 2070              		.loc 1 853 12 view .LVU599
 2071 00ae 03B1     		cbz	r3, .L145
 854:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 2072              		.loc 1 854 13 is_stmt 1 view .LVU600
 2073 00b0 9847     		blx	r3
 2074              	.LVL151:
 2075              	.L145:
 856:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2076              		.loc 1 856 9 view .LVU601
 856:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2077              		.loc 1 856 30 is_stmt 0 view .LVU602
 2078 00b2 0023     		movs	r3, #0
 2079 00b4 84F8A030 		strb	r3, [r4, #160]
 858:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2080              		.loc 1 858 1 view .LVU603
 2081 00b8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2082              	.L159:
 2083              		.align	2
 2084              	.L158:
 2085 00bc 00000000 		.word	.LANCHOR0
 2086 00c0 00000000 		.word	udd_g_ctrlreq
 2087 00c4 00000000 		.word	udd_ctrl_buffer
 2088 00c8 00000000 		.word	usb_device
 2089              		.cfi_endproc
 2090              	.LFE172:
 2092              		.section	.text.udd_ep_clear_halt,"ax",%progbits
 2093              		.align	1
 2094              		.global	udd_ep_clear_halt
 2095              		.syntax unified
 2096              		.thumb
 2097              		.thumb_func
 2098              		.fpu fpv4-sp-d16
 2100              	udd_ep_clear_halt:
 2101              	.LVL152:
 2102              	.LFB156:
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 2103              		.loc 1 454 40 is_stmt 1 view -0
 2104              		.cfi_startproc
 2105              		@ args = 0, pretend = 0, frame = 0
 2106              		@ frame_needed = 0, uses_anonymous_args = 0
 455:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint8_t       ep_num = ep & USB_EP_ADDR_MASK;
 2107              		.loc 1 455 5 view .LVU605
 456:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2108              		.loc 1 456 5 view .LVU606
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2109              		.loc 1 458 5 view .LVU607
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2110              		.loc 1 458 8 is_stmt 0 view .LVU608
 2111 0000 00F00F03 		and	r3, r0, #15
 2112 0004 042B     		cmp	r3, #4
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 2113              		.loc 1 454 40 view .LVU609
 2114 0006 10B5     		push	{r4, lr}
 2115              		.cfi_def_cfa_offset 8
 2116              		.cfi_offset 4, -8
 2117              		.cfi_offset 14, -4
 454:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 2118              		.loc 1 454 40 view .LVU610
 2119 0008 0146     		mov	r1, r0
 458:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2120              		.loc 1 458 8 view .LVU611
 2121 000a 0FD8     		bhi	.L162
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2122              		.loc 1 461 5 is_stmt 1 view .LVU612
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2123              		.loc 1 461 15 is_stmt 0 view .LVU613
 2124 000c FFF7FEFF 		bl	udd_ep_get_job
 2125              	.LVL153:
 461:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2126              		.loc 1 461 15 view .LVU614
 2127 0010 0446     		mov	r4, r0
 2128              	.LVL154:
 463:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2129              		.loc 1 463 5 is_stmt 1 view .LVU615
 2130 0012 0748     		ldr	r0, .L164
 2131              	.LVL155:
 463:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2132              		.loc 1 463 5 is_stmt 0 view .LVU616
 2133 0014 FFF7FEFF 		bl	usb_device_endpoint_clear_halt
 2134              	.LVL156:
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 2135              		.loc 1 466 5 is_stmt 1 view .LVU617
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 2136              		.loc 1 466 23 is_stmt 0 view .LVU618
 2137 0018 A37C     		ldrb	r3, [r4, #18]	@ zero_extendqisi2
 466:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->busy = false;
 2138              		.loc 1 466 8 view .LVU619
 2139 001a DA07     		lsls	r2, r3, #31
 2140 001c 04D5     		bpl	.L163
 467:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt();
 2141              		.loc 1 467 9 is_stmt 1 view .LVU620
 467:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt();
 2142              		.loc 1 467 23 is_stmt 0 view .LVU621
 2143 001e 6FF30003 		bfc	r3, #0, #1
 2144 0022 A374     		strb	r3, [r4, #18]
 468:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2145              		.loc 1 468 9 is_stmt 1 view .LVU622
 2146 0024 2368     		ldr	r3, [r4]
 2147 0026 9847     		blx	r3
 2148              	.LVL157:
 2149              	.L163:
 471:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2150              		.loc 1 471 12 is_stmt 0 view .LVU623
 2151 0028 0120     		movs	r0, #1
 2152 002a 00E0     		b	.L161
 2153              	.LVL158:
 2154              	.L162:
 459:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2155              		.loc 1 459 16 view .LVU624
 2156 002c 0020     		movs	r0, #0
 2157              	.LVL159:
 2158              	.L161:
 472:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2159              		.loc 1 472 1 view .LVU625
 2160 002e 10BD     		pop	{r4, pc}
 2161              	.L165:
 2162              		.align	2
 2163              	.L164:
 2164 0030 00000000 		.word	usb_device
 2165              		.cfi_endproc
 2166              	.LFE156:
 2168              		.section	.text.udd_ep_wait_stall_clear,"ax",%progbits
 2169              		.align	1
 2170              		.global	udd_ep_wait_stall_clear
 2171              		.syntax unified
 2172              		.thumb
 2173              		.thumb_func
 2174              		.fpu fpv4-sp-d16
 2176              	udd_ep_wait_stall_clear:
 2177              	.LVL160:
 2178              	.LFB157:
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2179              		.loc 1 474 84 is_stmt 1 view -0
 2180              		.cfi_startproc
 2181              		@ args = 0, pretend = 0, frame = 0
 2182              		@ frame_needed = 0, uses_anonymous_args = 0
 475:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 2183              		.loc 1 475 5 view .LVU627
 476:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2184              		.loc 1 476 5 view .LVU628
 478:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (USB_DEVICE_MAX_EP < ep_num) {
 2185              		.loc 1 478 5 view .LVU629
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2186              		.loc 1 479 5 view .LVU630
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2187              		.loc 1 474 84 is_stmt 0 view .LVU631
 2188 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2189              		.cfi_def_cfa_offset 24
 2190              		.cfi_offset 3, -24
 2191              		.cfi_offset 4, -20
 2192              		.cfi_offset 5, -16
 2193              		.cfi_offset 6, -12
 2194              		.cfi_offset 7, -8
 2195              		.cfi_offset 14, -4
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2196              		.loc 1 479 8 view .LVU632
 2197 0002 00F00F03 		and	r3, r0, #15
 2198 0006 042B     		cmp	r3, #4
 474:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2199              		.loc 1 474 84 view .LVU633
 2200 0008 0646     		mov	r6, r0
 2201 000a 0F46     		mov	r7, r1
 479:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2202              		.loc 1 479 8 view .LVU634
 2203 000c 02D9     		bls	.L167
 2204              	.LVL161:
 2205              	.L169:
 480:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2206              		.loc 1 480 16 view .LVU635
 2207 000e 0024     		movs	r4, #0
 2208              	.L168:
 500:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2209              		.loc 1 500 1 view .LVU636
 2210 0010 2046     		mov	r0, r4
 2211 0012 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2212              	.LVL162:
 2213              	.L167:
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 2214              		.loc 1 483 5 is_stmt 1 view .LVU637
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 2215              		.loc 1 483 15 is_stmt 0 view .LVU638
 2216 0014 FFF7FEFF 		bl	udd_ep_get_job
 2217              	.LVL163:
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 2218              		.loc 1 484 23 view .LVU639
 2219 0018 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 2220              		.loc 1 484 8 view .LVU640
 2221 001a DB07     		lsls	r3, r3, #31
 483:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     if (ptr_job->busy == true) {
 2222              		.loc 1 483 15 view .LVU641
 2223 001c 0546     		mov	r5, r0
 2224              	.LVL164:
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 2225              		.loc 1 484 5 is_stmt 1 view .LVU642
 484:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 2226              		.loc 1 484 8 is_stmt 0 view .LVU643
 2227 001e F6D4     		bmi	.L169
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 2228              		.loc 1 489 5 is_stmt 1 view .LVU644
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 2229              		.loc 1 489 9 is_stmt 0 view .LVU645
 2230 0020 3146     		mov	r1, r6
 2231              	.LVL165:
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 2232              		.loc 1 489 9 view .LVU646
 2233 0022 0A48     		ldr	r0, .L174
 2234              	.LVL166:
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 2235              		.loc 1 489 9 view .LVU647
 2236 0024 FFF7FEFF 		bl	usb_device_endpoint_is_halted
 2237              	.LVL167:
 489:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         /* Endpoint halted then registers the callback */
 2238              		.loc 1 489 8 view .LVU648
 2239 0028 0446     		mov	r4, r0
 2240 002a 28B1     		cbz	r0, .L170
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 2241              		.loc 1 491 9 is_stmt 1 view .LVU649
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 2242              		.loc 1 491 30 is_stmt 0 view .LVU650
 2243 002c AB7C     		ldrb	r3, [r5, #18]	@ zero_extendqisi2
 492:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 2244              		.loc 1 492 30 view .LVU651
 2245 002e 2F60     		str	r7, [r5]
 491:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         ptr_job->call_nohalt = callback;
 2246              		.loc 1 491 30 view .LVU652
 2247 0030 43F00103 		orr	r3, r3, #1
 2248 0034 AB74     		strb	r3, [r5, #18]
 492:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 2249              		.loc 1 492 9 is_stmt 1 view .LVU653
 493:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (usb_device_endpoint_is_configured(&usb_device, ep)) {
 2250              		.loc 1 493 9 view .LVU654
 493:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else if (usb_device_endpoint_is_configured(&usb_device, ep)) {
 2251              		.loc 1 493 16 is_stmt 0 view .LVU655
 2252 0036 EBE7     		b	.L168
 2253              	.L170:
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 2254              		.loc 1 494 12 is_stmt 1 view .LVU656
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 2255              		.loc 1 494 16 is_stmt 0 view .LVU657
 2256 0038 3146     		mov	r1, r6
 2257 003a 0448     		ldr	r0, .L174
 2258 003c FFF7FEFF 		bl	usb_device_endpoint_is_configured
 2259              	.LVL168:
 494:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         callback(); /* Endpoint not halted then call directly callback */
 2260              		.loc 1 494 15 view .LVU658
 2261 0040 0446     		mov	r4, r0
 2262 0042 0028     		cmp	r0, #0
 2263 0044 E3D0     		beq	.L169
 495:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return true;
 2264              		.loc 1 495 9 is_stmt 1 view .LVU659
 2265 0046 B847     		blx	r7
 2266              	.LVL169:
 496:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2267              		.loc 1 496 9 view .LVU660
 496:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2268              		.loc 1 496 16 is_stmt 0 view .LVU661
 2269 0048 E2E7     		b	.L168
 2270              	.L175:
 2271 004a 00BF     		.align	2
 2272              	.L174:
 2273 004c 00000000 		.word	usb_device
 2274              		.cfi_endproc
 2275              	.LFE157:
 2277              		.section	.text.udd_ep_run,"ax",%progbits
 2278              		.align	1
 2279              		.global	udd_ep_run
 2280              		.syntax unified
 2281              		.thumb
 2282              		.thumb_func
 2283              		.fpu fpv4-sp-d16
 2285              	udd_ep_run:
 2286              	.LVL170:
 2287              	.LFB159:
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2288              		.loc 1 512 120 is_stmt 1 view -0
 2289              		.cfi_startproc
 2290              		@ args = 4, pretend = 0, frame = 0
 2291              		@ frame_needed = 0, uses_anonymous_args = 0
 513:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_job_t *ptr_job;
 2292              		.loc 1 513 5 view .LVU663
 514:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t      irqflags;
 2293              		.loc 1 514 5 view .LVU664
 515:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2294              		.loc 1 515 5 view .LVU665
 517:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2295              		.loc 1 517 5 view .LVU666
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2296              		.loc 1 512 120 is_stmt 0 view .LVU667
 2297 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 2298              		.cfi_def_cfa_offset 32
 2299              		.cfi_offset 4, -32
 2300              		.cfi_offset 5, -28
 2301              		.cfi_offset 6, -24
 2302              		.cfi_offset 7, -20
 2303              		.cfi_offset 8, -16
 2304              		.cfi_offset 9, -12
 2305              		.cfi_offset 10, -8
 2306              		.cfi_offset 14, -4
 517:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2307              		.loc 1 517 12 view .LVU668
 2308 0004 00F00F06 		and	r6, r0, #15
 2309              	.LVL171:
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2310              		.loc 1 519 5 is_stmt 1 view .LVU669
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2311              		.loc 1 519 8 is_stmt 0 view .LVU670
 2312 0008 042E     		cmp	r6, #4
 512:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_ep_id_t   ep_num;
 2313              		.loc 1 512 120 view .LVU671
 2314 000a 8146     		mov	r9, r0
 2315 000c 8A46     		mov	r10, r1
 2316 000e 1746     		mov	r7, r2
 2317 0010 1C46     		mov	r4, r3
 2318 0012 DDF82080 		ldr	r8, [sp, #32]
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2319              		.loc 1 519 8 view .LVU672
 2320 0016 03D9     		bls	.L177
 2321              	.LVL172:
 2322              	.L179:
 520:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2323              		.loc 1 520 16 view .LVU673
 2324 0018 0025     		movs	r5, #0
 2325              	.LVL173:
 2326              	.L178:
 592:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2327              		.loc 1 592 1 view .LVU674
 2328 001a 2846     		mov	r0, r5
 2329 001c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2330              	.LVL174:
 2331              	.L177:
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2332              		.loc 1 519 42 discriminator 1 view .LVU675
 2333 0020 FFF7FEFF 		bl	udd_ep_is_halted
 2334              	.LVL175:
 519:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false;
 2335              		.loc 1 519 38 discriminator 1 view .LVU676
 2336 0024 0546     		mov	r5, r0
 2337 0026 0028     		cmp	r0, #0
 2338 0028 F6D1     		bne	.L179
 523:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2339              		.loc 1 523 5 is_stmt 1 view .LVU677
 523:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2340              		.loc 1 523 15 is_stmt 0 view .LVU678
 2341 002a 4846     		mov	r0, r9
 2342 002c FFF7FEFF 		bl	udd_ep_get_job
 2343              	.LVL176:
 525:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __disable_irq();
 2344              		.loc 1 525 5 is_stmt 1 view .LVU679
 2345              	.LBB110:
 2346              	.LBI110:
 2347              		.file 3 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h"
   1:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.1
   5:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * @date     02. February 2017
   6:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /*
   8:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
   9:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  10:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  12:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  16:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  *
  18:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  24:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  25:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  28:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  34:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  35:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  36:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                     __asm
  37:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  38:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  39:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                  inline
  40:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  41:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  42:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE           static inline
  43:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  44:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  45:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN               __attribute__((noreturn))
  46:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  47:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  48:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __USED                    __attribute__((used))
  49:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  50:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  51:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                    __attribute__((weak))
  52:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  53:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32
  54:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  55:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wpacked"
  56:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wattributes"
  57:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  58:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic pop
  59:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)     (((struct T_UINT32 *)(x))->v)
  60:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  61:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
  62:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)              __attribute__((aligned(x)))
  63:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  64:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  65:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                  __attribute__((packed, aligned(1)))
  66:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  67:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  68:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT           struct __attribute__((packed, aligned(1)))
  69:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
  70:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  71:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  72:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  73:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  74:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  75:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   @{
  76:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  77:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  78:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
  79:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  80:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  81:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  82:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  83:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
  84:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
  85:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  86:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
  87:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  88:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  89:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
  90:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  91:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  92:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  93:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
  94:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
  95:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  97:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
  98:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
  99:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 100:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 101:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 102:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 103:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 104:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 105:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_CONTROL(void)
 106:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 107:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 109:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 110:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 112:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 113:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 114:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 115:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 116:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 117:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 118:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 119:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 120:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_CONTROL_NS(void)
 121:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 122:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 123:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 124:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 125:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 126:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 127:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 128:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 129:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 130:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 131:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 132:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 133:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 134:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 135:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_CONTROL(uint32_t control)
 136:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 137:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 138:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 139:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 140:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 141:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 142:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 143:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 144:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 145:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 146:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 147:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_CONTROL_NS(uint32_t control)
 148:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 149:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 150:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 151:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 152:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 153:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 154:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 155:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 156:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 157:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 158:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 159:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_IPSR(void)
 160:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 161:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 162:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 163:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 164:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 165:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 166:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 167:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 168:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 169:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 170:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 171:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 172:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 173:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_APSR(void)
 174:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 175:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 176:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 177:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 178:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 180:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 181:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 182:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 183:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 184:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 185:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 186:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 187:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_xPSR(void)
 188:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 189:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 190:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 191:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 192:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 193:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 194:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 195:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 196:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 197:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 198:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 199:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 200:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 201:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSP(void)
 202:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 203:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 204:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 205:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 206:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 207:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 208:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 209:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 210:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 211:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 212:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 213:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 214:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 215:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 216:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSP_NS(void)
 217:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 218:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 219:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 220:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 221:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 222:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 223:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 224:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 225:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 226:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 227:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 228:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 229:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 230:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 231:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 232:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 233:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 234:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 235:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 236:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 237:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 238:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 239:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 240:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 241:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 242:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 243:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 244:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 245:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 246:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 247:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 248:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 249:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 250:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 251:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 252:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 253:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 254:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 255:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSP(void)
 256:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 257:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 258:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 259:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 260:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 261:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 262:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 263:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 264:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 265:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 266:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 267:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 268:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 269:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 270:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSP_NS(void)
 271:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 272:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 273:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 274:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 275:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 276:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 277:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 278:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 279:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 280:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 281:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 282:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 283:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 284:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 285:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 286:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 287:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 288:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 289:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 290:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 291:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 292:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 293:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 294:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 295:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 296:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 297:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 298:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 299:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 300:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 301:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 302:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 303:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 304:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 305:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 306:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 307:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 308:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 309:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 2348              		.loc 3 309 57 view .LVU680
 2349              	.LBB111:
 310:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 311:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 2350              		.loc 3 311 3 view .LVU681
 312:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 313:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 2351              		.loc 3 313 3 view .LVU682
 2352              		.syntax unified
 2353              	@ 313 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2354 0030 EFF31081 		MRS r1, primask
 2355              	@ 0 "" 2
 2356              	.LVL177:
 314:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 2357              		.loc 3 314 3 view .LVU683
 2358              		.loc 3 314 3 is_stmt 0 view .LVU684
 2359              		.thumb
 2360              		.syntax unified
 2361              	.LBE111:
 2362              	.LBE110:
 526:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 2363              		.loc 1 526 5 is_stmt 1 view .LVU685
 2364              	.LBB112:
 2365              	.LBI112:
  94:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 2366              		.loc 3 94 53 view .LVU686
 2367              	.LBB113:
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2368              		.loc 3 96 3 view .LVU687
 2369              		.syntax unified
 2370              	@ 96 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2371 0034 72B6     		cpsid i
 2372              	@ 0 "" 2
 2373              		.thumb
 2374              		.syntax unified
 2375              	.LBE113:
 2376              	.LBE112:
 527:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2377              		.loc 1 527 5 view .LVU688
 2378              	.LBB114:
 2379              	.LBI114:
 315:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 316:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 317:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 318:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 319:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 320:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 321:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 322:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 323:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 324:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PRIMASK_NS(void)
 325:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 326:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 327:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 328:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 329:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 330:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 331:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 332:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 333:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 334:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 335:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 336:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 337:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 338:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 339:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 340:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 342:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 343:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 344:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 345:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 346:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 347:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 348:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 349:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 350:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 351:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 352:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 353:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 354:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 355:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 356:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 357:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 358:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 359:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 360:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 361:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 362:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 363:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 364:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 365:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 366:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __enable_fault_irq(void)
 367:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 368:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 369:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 370:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 371:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 372:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 373:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 374:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 375:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 376:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 377:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __disable_fault_irq(void)
 378:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 379:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 380:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 381:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 382:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 383:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 384:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 385:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 386:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 387:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 388:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 389:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 390:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 391:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 392:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 393:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 394:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 395:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 396:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 397:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 398:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 399:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 400:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 401:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 402:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 403:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_BASEPRI_NS(void)
 404:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 405:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 406:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 407:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 408:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 409:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 410:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 411:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 412:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 413:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 414:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 415:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 416:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 417:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 418:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 419:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 420:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 421:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 422:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 423:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 424:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 425:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 426:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 427:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 428:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 429:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 430:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 431:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 432:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 433:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 434:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 435:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 436:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 437:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 438:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 439:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 440:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 441:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 442:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 443:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
 444:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 445:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 446:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 447:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 448:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 449:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 450:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 451:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 452:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 453:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 454:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 455:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 456:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 457:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 458:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 459:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 460:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 461:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 462:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 463:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 464:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 465:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 466:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 467:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 468:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 469:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 470:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 471:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 472:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 473:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 474:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 475:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 476:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 477:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 478:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 479:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 480:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 481:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 482:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 483:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 484:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 485:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 486:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 487:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 488:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 489:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 490:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 491:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 492:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 493:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 494:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 495:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 496:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 497:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 498:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 499:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 500:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 501:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 502:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 503:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 504:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 505:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 506:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 507:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 508:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 509:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 510:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 511:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 512:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 513:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 514:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 515:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_PSPLIM(void)
 516:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 517:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 518:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 519:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 520:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 521:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 522:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 523:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 524:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 525:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 526:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 527:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 528:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 529:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 530:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 531:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_PSPLIM_NS(void)
 532:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 533:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 534:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 535:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 536:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 537:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 538:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 539:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 540:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 541:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 542:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 543:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 544:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 545:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 546:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 547:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 548:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 549:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 550:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 551:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 552:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 553:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 554:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 555:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 556:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 557:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 558:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 559:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 560:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 561:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 562:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 563:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 564:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 565:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 566:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 567:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 568:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 569:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 570:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 571:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_MSPLIM(void)
 572:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 573:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 574:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 575:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 576:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 577:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 578:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 579:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 580:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 581:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 582:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 583:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 584:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 585:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 586:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 587:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 588:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __TZ_get_MSPLIM_NS(void)
 589:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 590:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 591:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 592:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 593:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 594:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 595:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 596:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 597:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 598:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 599:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 600:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 601:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 602:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 603:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 604:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 605:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 606:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 607:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 608:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 609:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3)) && \
 610:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 611:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 612:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 613:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 614:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 615:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 616:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 617:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 618:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 619:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 620:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 621:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 622:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 623:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 624:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 625:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 626:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 627:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 628:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 629:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 630:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 631:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 632:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 633:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 634:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __get_FPSCR(void)
 635:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 636:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 637:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 638:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 639:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 640:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 641:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 642:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 643:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****    return(0U);
 644:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 645:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 646:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 647:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 648:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 649:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 650:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 651:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 652:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 653:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 654:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 655:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 656:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 657:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 658:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 659:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 660:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 661:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 662:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 663:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 664:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 665:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 666:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 667:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 668:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 669:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 670:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 671:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 672:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 673:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 674:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   @{
 675:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** */
 676:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 677:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 678:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 679:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 680:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 681:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 682:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 683:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 684:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #else
 685:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 686:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 687:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 688:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #endif
 689:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 690:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 691:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 692:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 693:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 694:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 695:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 696:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("nop");
 697:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 698:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")       /* This implementation gen
 699:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 700:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 701:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 702:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 703:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 704:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 705:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 706:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfi");
 707:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 708:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")       /* This implementation gen
 709:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 710:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 711:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 712:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 713:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 714:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 715:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 716:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 717:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 718:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("wfe");
 719:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 720:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")       /* This implementation gen
 721:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 722:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 723:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 724:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 725:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 726:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 727:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 728:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //{
 729:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //  __ASM volatile ("sev");
 730:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** //}
 731:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")       /* This implementation gen
 732:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 733:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 734:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 735:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 736:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 737:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 738:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 739:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 740:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 741:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 742:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 743:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 744:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 745:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 746:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 747:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 748:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 749:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 750:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 751:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 752:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 753:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 754:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 755:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 756:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 757:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** /**
 758:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 759:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 760:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 761:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****  */
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
 2380              		.loc 3 762 53 view .LVU689
 2381              	.LBB115:
 763:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 764:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 2382              		.loc 3 764 3 view .LVU690
 2383              		.syntax unified
 2384              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2385 0036 BFF35F8F 		dmb 0xF
 2386              	@ 0 "" 2
 2387              		.thumb
 2388              		.syntax unified
 2389              	.LBE115:
 2390              	.LBE114:
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 2391              		.loc 1 529 5 view .LVU691
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 2392              		.loc 1 529 23 is_stmt 0 view .LVU692
 2393 003a 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 529:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __DMB();
 2394              		.loc 1 529 8 view .LVU693
 2395 003c 13F00102 		ands	r2, r3, #1
 2396 0040 04D0     		beq	.L180
 530:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         __set_PRIMASK(irqflags);
 2397              		.loc 1 530 9 is_stmt 1 view .LVU694
 2398              	.LBB116:
 2399              	.LBI116:
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 2400              		.loc 3 762 53 view .LVU695
 2401              	.LBB117:
 2402              		.loc 3 764 3 view .LVU696
 2403              		.syntax unified
 2404              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2405 0042 BFF35F8F 		dmb 0xF
 2406              	@ 0 "" 2
 2407              		.thumb
 2408              		.syntax unified
 2409              	.LBE117:
 2410              	.LBE116:
 531:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         return false; /* Job already on going */
 2411              		.loc 1 531 9 view .LVU697
 2412              	.LVL178:
 2413              	.LBB118:
 2414              	.LBI118:
 339:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 2415              		.loc 3 339 53 view .LVU698
 2416              	.LBB119:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2417              		.loc 3 341 3 view .LVU699
 2418              		.syntax unified
 2419              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2420 0046 81F31088 		MSR primask, r1
 2421              	@ 0 "" 2
 2422              	.LVL179:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2423              		.loc 3 341 3 is_stmt 0 view .LVU700
 2424              		.thumb
 2425              		.syntax unified
 2426              	.LBE119:
 2427              	.LBE118:
 532:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2428              		.loc 1 532 9 is_stmt 1 view .LVU701
 532:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2429              		.loc 1 532 16 is_stmt 0 view .LVU702
 2430 004a E6E7     		b	.L178
 2431              	.L180:
 535:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 2432              		.loc 1 535 5 is_stmt 1 view .LVU703
 535:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 2433              		.loc 1 535 19 is_stmt 0 view .LVU704
 2434 004c 43F00103 		orr	r3, r3, #1
 2435 0050 8374     		strb	r3, [r0, #18]
 536:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __set_PRIMASK(irqflags);
 2436              		.loc 1 536 5 is_stmt 1 view .LVU705
 2437              	.LBB120:
 2438              	.LBI120:
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 2439              		.loc 3 762 53 view .LVU706
 2440              	.LBB121:
 2441              		.loc 3 764 3 view .LVU707
 2442              		.syntax unified
 2443              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2444 0052 BFF35F8F 		dmb 0xF
 2445              	@ 0 "" 2
 2446              		.thumb
 2447              		.syntax unified
 2448              	.LBE121:
 2449              	.LBE120:
 537:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2450              		.loc 1 537 5 view .LVU708
 2451              	.LVL180:
 2452              	.LBB122:
 2453              	.LBI122:
 339:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 2454              		.loc 3 339 53 view .LVU709
 2455              	.LBB123:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2456              		.loc 3 341 3 view .LVU710
 2457              		.syntax unified
 2458              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 2459 0056 81F31088 		MSR primask, r1
 2460              	@ 0 "" 2
 2461              	.LVL181:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 2462              		.loc 3 341 3 is_stmt 0 view .LVU711
 2463              		.thumb
 2464              		.syntax unified
 2465              	.LBE123:
 2466              	.LBE122:
 540:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->buf_size               = buf_size;
 2467              		.loc 1 540 5 is_stmt 1 view .LVU712
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 2468              		.loc 1 544 37 is_stmt 0 view .LVU713
 2469 005a 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 542:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->call_trans             = callback;
 2470              		.loc 1 542 37 view .LVU714
 2471 005c C260     		str	r2, [r0, #12]
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 2472              		.loc 1 544 37 view .LVU715
 2473 005e 6AF34103 		bfi	r3, r10, #1, #1
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2474              		.loc 1 545 37 view .LVU716
 2475 0062 62F38203 		bfi	r3, r2, #2, #1
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 2476              		.loc 1 550 8 view .LVU717
 2477 0066 19F0800F 		tst	r9, #128
 541:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->nb_trans               = 0;
 2478              		.loc 1 541 37 view .LVU718
 2479 006a C0E90174 		strd	r7, r4, [r0, #4]
 542:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->call_trans             = callback;
 2480              		.loc 1 542 5 is_stmt 1 view .LVU719
 543:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_shortpacket          = b_shortpacket;
 2481              		.loc 1 543 5 view .LVU720
 543:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_shortpacket          = b_shortpacket;
 2482              		.loc 1 543 37 is_stmt 0 view .LVU721
 2483 006e C0F80080 		str	r8, [r0]
 544:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     ptr_job->b_use_out_cache_buffer = false;
 2484              		.loc 1 544 5 is_stmt 1 view .LVU722
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2485              		.loc 1 545 5 view .LVU723
 545:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2486              		.loc 1 545 37 is_stmt 0 view .LVU724
 2487 0072 8374     		strb	r3, [r0, #18]
 548:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2488              		.loc 1 548 5 is_stmt 1 view .LVU725
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 2489              		.loc 1 550 5 view .LVU726
 550:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         if (0 != ptr_job->buf_size) {
 2490              		.loc 1 550 8 is_stmt 0 view .LVU727
 2491 0074 3AD0     		beq	.L181
 551:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2492              		.loc 1 551 9 is_stmt 1 view .LVU728
 2493 0076 DBB2     		uxtb	r3, r3
 2494 0078 03F00205 		and	r5, r3, #2
 551:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2495              		.loc 1 551 12 is_stmt 0 view .LVU729
 2496 007c 1CB3     		cbz	r4, .L182
 552:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2497              		.loc 1 552 13 is_stmt 1 view .LVU730
 552:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2498              		.loc 1 552 24 is_stmt 0 view .LVU731
 2499 007e A3B2     		uxth	r3, r4
 2500              	.LVL182:
 553:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 2501              		.loc 1 553 13 is_stmt 1 view .LVU732
 553:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 next_trans = UDD_ENDPOINT_MAX_TRANS - (UDD_ENDPOINT_MAX_TRANS % ptr_job->ep_size);
 2502              		.loc 1 553 16 is_stmt 0 view .LVU733
 2503 0080 B3F5005F 		cmp	r3, #8192
 2504 0084 08D3     		bcc	.L183
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2505              		.loc 1 554 17 is_stmt 1 view .LVU734
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2506              		.loc 1 554 88 is_stmt 0 view .LVU735
 2507 0086 028A     		ldrh	r2, [r0, #16]
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2508              		.loc 1 554 79 view .LVU736
 2509 0088 41F6FF73 		movw	r3, #8191
 2510              	.LVL183:
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2511              		.loc 1 554 79 view .LVU737
 2512 008c B3FBF2F4 		udiv	r4, r3, r2
 2513              	.LVL184:
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2514              		.loc 1 554 79 view .LVU738
 2515 0090 02FB1434 		mls	r4, r2, r4, r3
 554:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2516              		.loc 1 554 28 view .LVU739
 2517 0094 1B1B     		subs	r3, r3, r4
 2518 0096 9BB2     		uxth	r3, r3
 2519              	.LVL185:
 2520              	.L183:
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2521              		.loc 1 556 13 is_stmt 1 view .LVU740
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2522              		.loc 1 556 61 is_stmt 0 view .LVU741
 2523 0098 45B1     		cbz	r5, .L184
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2524              		.loc 1 556 67 discriminator 1 view .LVU742
 2525 009a 028A     		ldrh	r2, [r0, #16]
 2526 009c B3FBF2F5 		udiv	r5, r3, r2
 2527 00a0 02FB1535 		mls	r5, r2, r5, r3
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2528              		.loc 1 556 61 discriminator 1 view .LVU743
 2529 00a4 ADB2     		uxth	r5, r5
 2530 00a6 B5FA85F5 		clz	r5, r5
 2531 00aa 6D09     		lsrs	r5, r5, #5
 2532              	.L184:
 556:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else if (true == ptr_job->b_shortpacket) {
 2533              		.loc 1 556 36 discriminator 6 view .LVU744
 2534 00ac 827C     		ldrb	r2, [r0, #18]	@ zero_extendqisi2
 2535 00ae 65F34102 		bfi	r2, r5, #1, #1
 2536 00b2 8274     		strb	r2, [r0, #18]
 2537              	.LVL186:
 2538              	.L185:
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2539              		.loc 1 567 9 is_stmt 1 view .LVU745
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2540              		.loc 1 567 30 is_stmt 0 view .LVU746
 2541 00b4 3A46     		mov	r2, r7
 2542 00b6 3146     		mov	r1, r6
 2543              	.LVL187:
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2544              		.loc 1 567 30 view .LVU747
 2545 00b8 1F48     		ldr	r0, .L199
 2546              	.LVL188:
 567:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     } else {
 2547              		.loc 1 567 30 view .LVU748
 2548 00ba FFF7FEFF 		bl	usb_device_endpoint_write_buffer_job
 2549              	.LVL189:
 2550              	.L197:
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2551              		.loc 1 582 35 view .LVU749
 2552 00be B0FA80F5 		clz	r5, r0
 2553 00c2 6D09     		lsrs	r5, r5, #5
 2554 00c4 A9E7     		b	.L178
 2555              	.LVL190:
 2556              	.L182:
 557:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
 2557              		.loc 1 557 16 is_stmt 1 view .LVU750
 557:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             ptr_job->b_shortpacket = false; /* avoid to send zero length packet again */
 2558              		.loc 1 557 19 is_stmt 0 view .LVU751
 2559 00c6 25B1     		cbz	r5, .L186
 558:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans             = 0;
 2560              		.loc 1 558 13 is_stmt 1 view .LVU752
 558:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans             = 0;
 2561              		.loc 1 558 36 is_stmt 0 view .LVU753
 2562 00c8 64F34103 		bfi	r3, r4, #1, #1
 2563 00cc 8374     		strb	r3, [r0, #18]
 559:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 2564              		.loc 1 559 13 is_stmt 1 view .LVU754
 2565              	.LVL191:
 559:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         } else {
 2566              		.loc 1 559 36 is_stmt 0 view .LVU755
 2567 00ce 2346     		mov	r3, r4
 2568 00d0 F0E7     		b	.L185
 2569              	.LVL192:
 2570              	.L186:
 561:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2571              		.loc 1 561 13 is_stmt 1 view .LVU756
 561:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2572              		.loc 1 561 27 is_stmt 0 view .LVU757
 2573 00d2 65F30003 		bfi	r3, r5, #0, #1
 2574              	.L195:
 2575 00d6 8374     		strb	r3, [r0, #18]
 562:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 2576              		.loc 1 562 13 is_stmt 1 view .LVU758
 562:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->call_trans(UDD_EP_TRANSFER_OK, 0, ep);
 2577              		.loc 1 562 16 is_stmt 0 view .LVU759
 2578 00d8 B8F1000F 		cmp	r8, #0
 2579 00dc 01D1     		bne	.L187
 2580              	.LVL193:
 2581              	.L196:
 565:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         }
 2582              		.loc 1 565 20 view .LVU760
 2583 00de 0125     		movs	r5, #1
 2584 00e0 9BE7     		b	.L178
 2585              	.LVL194:
 2586              	.L187:
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2587              		.loc 1 563 17 is_stmt 1 view .LVU761
 2588 00e2 0021     		movs	r1, #0
 2589              	.LVL195:
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2590              		.loc 1 563 17 is_stmt 0 view .LVU762
 2591 00e4 4A46     		mov	r2, r9
 2592 00e6 0846     		mov	r0, r1
 2593              	.LVL196:
 563:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2594              		.loc 1 563 17 view .LVU763
 2595 00e8 C047     		blx	r8
 2596              	.LVL197:
 2597 00ea F8E7     		b	.L196
 2598              	.LVL198:
 2599              	.L181:
 569:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2600              		.loc 1 569 9 is_stmt 1 view .LVU764
 569:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             next_trans = ptr_job->buf_size;
 2601              		.loc 1 569 12 is_stmt 0 view .LVU765
 2602 00ec FCB1     		cbz	r4, .L188
 570:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2603              		.loc 1 570 13 is_stmt 1 view .LVU766
 570:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
 2604              		.loc 1 570 24 is_stmt 0 view .LVU767
 2605 00ee A4B2     		uxth	r4, r4
 2606              	.LVL199:
 571:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* The USB hardware support a maximum transfer size
 2607              		.loc 1 571 13 is_stmt 1 view .LVU768
 2608 00f0 038A     		ldrh	r3, [r0, #16]
 571:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 /* The USB hardware support a maximum transfer size
 2609              		.loc 1 571 16 is_stmt 0 view .LVU769
 2610 00f2 B4F5005F 		cmp	r4, #8192
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2611              		.loc 1 574 17 is_stmt 1 view .LVU770
 574:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2612              		.loc 1 574 79 is_stmt 0 view .LVU771
 2613 00f6 28BF     		it	cs
 2614 00f8 41F6FF74 		movwcs	r4, #8191
 2615              	.LVL200:
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2616              		.loc 1 576 17 is_stmt 1 view .LVU772
 576:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2617              		.loc 1 576 28 is_stmt 0 view .LVU773
 2618 00fc B4FBF3F2 		udiv	r2, r4, r3
 2619 0100 03FB1242 		mls	r2, r3, r2, r4
 2620 0104 A41A     		subs	r4, r4, r2
 2621 0106 A4B2     		uxth	r4, r4
 2622              	.LVL201:
 578:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->b_use_out_cache_buffer = true;
 2623              		.loc 1 578 13 is_stmt 1 view .LVU774
 578:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 ptr_job->b_use_out_cache_buffer = true;
 2624              		.loc 1 578 16 is_stmt 0 view .LVU775
 2625 0108 9C42     		cmp	r4, r3
 579:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_e
 2626              		.loc 1 579 17 is_stmt 1 view .LVU776
 579:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****                 return (STATUS_OK == usb_device_endpoint_read_buffer_job(&usb_device, ep_num, udd_e
 2627              		.loc 1 579 49 is_stmt 0 view .LVU777
 2628 010a 3FBF     		itttt	cc
 2629 010c 827C     		ldrbcc	r2, [r0, #18]	@ zero_extendqisi2
 2630 010e 42F00402 		orrcc	r2, r2, #4
 2631 0112 8274     		strbcc	r2, [r0, #18]
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2632              		.loc 1 580 17 is_stmt 1 view .LVU778
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2633              		.loc 1 580 38 is_stmt 0 view .LVU779
 2634 0114 094A     		ldrcc	r2, .L199+4
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2635              		.loc 1 582 38 view .LVU780
 2636 0116 0848     		ldr	r0, .L199
 2637              	.LVL202:
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2638              		.loc 1 580 126 view .LVU781
 2639 0118 39BF     		ittee	cc
 2640 011a 06F1FF31 		addcc	r1, r6, #-1
 2641              	.LVL203:
 580:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             } else {
 2642              		.loc 1 580 38 view .LVU782
 2643 011e 02EB8112 		addcc	r2, r2, r1, lsl #6
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2644              		.loc 1 582 17 is_stmt 1 view .LVU783
 582:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             }
 2645              		.loc 1 582 38 is_stmt 0 view .LVU784
 2646 0122 2346     		movcs	r3, r4
 2647 0124 3A46     		movcs	r2, r7
 2648 0126 3146     		mov	r1, r6
 2649 0128 FFF7FEFF 		bl	usb_device_endpoint_read_buffer_job
 2650              	.LVL204:
 2651 012c C7E7     		b	.L197
 2652              	.LVL205:
 2653              	.L188:
 585:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2654              		.loc 1 585 13 is_stmt 1 view .LVU785
 585:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****             if (NULL != ptr_job->call_trans) {
 2655              		.loc 1 585 27 is_stmt 0 view .LVU786
 2656 012e 837C     		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 2657 0130 64F30003 		bfi	r3, r4, #0, #1
 2658 0134 CFE7     		b	.L195
 2659              	.L200:
 2660 0136 00BF     		.align	2
 2661              	.L199:
 2662 0138 00000000 		.word	usb_device
 2663 013c 00000000 		.word	udd_ep_out_cache_buffer
 2664              		.cfi_endproc
 2665              	.LFE159:
 2667              		.section	.text.udd_set_address,"ax",%progbits
 2668              		.align	1
 2669              		.global	udd_set_address
 2670              		.syntax unified
 2671              		.thumb
 2672              		.thumb_func
 2673              		.fpu fpv4-sp-d16
 2675              	udd_set_address:
 2676              	.LVL206:
 2677              	.LFB160:
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2678              		.loc 1 594 39 is_stmt 1 view -0
 2679              		.cfi_startproc
 2680              		@ args = 0, pretend = 0, frame = 0
 2681              		@ frame_needed = 0, uses_anonymous_args = 0
 2682              		@ link register save eliminated.
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2683              		.loc 1 594 41 view .LVU788
 2684 0000 024B     		ldr	r3, .L202
 2685 0002 1B68     		ldr	r3, [r3]
 2686              	.LVL207:
 2687              	.LBB124:
 2688              	.LBI124:
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2689              		.loc 2 359 20 view .LVU789
 2690              	.LBB125:
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2691              		.loc 2 359 94 view .LVU790
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2692              		.loc 2 359 127 is_stmt 0 view .LVU791
 2693 0004 40F08000 		orr	r0, r0, #128
 2694              	.LVL208:
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2695              		.loc 2 359 127 view .LVU792
 2696 0008 9872     		strb	r0, [r3, #10]
 2697              	.LVL209:
 359:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2698              		.loc 2 359 127 view .LVU793
 2699              	.LBE125:
 2700              	.LBE124:
 594:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2701              		.loc 1 594 1 view .LVU794
 2702 000a 7047     		bx	lr
 2703              	.L203:
 2704              		.align	2
 2705              	.L202:
 2706 000c 00000000 		.word	usb_device
 2707              		.cfi_endproc
 2708              	.LFE160:
 2710              		.section	.text.udd_getaddress,"ax",%progbits
 2711              		.align	1
 2712              		.global	udd_getaddress
 2713              		.syntax unified
 2714              		.thumb
 2715              		.thumb_func
 2716              		.fpu fpv4-sp-d16
 2718              	udd_getaddress:
 2719              	.LFB161:
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2720              		.loc 1 596 30 is_stmt 1 view -0
 2721              		.cfi_startproc
 2722              		@ args = 0, pretend = 0, frame = 0
 2723              		@ frame_needed = 0, uses_anonymous_args = 0
 2724              		@ link register save eliminated.
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2725              		.loc 1 596 32 view .LVU796
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2726              		.loc 1 596 39 is_stmt 0 view .LVU797
 2727 0000 024B     		ldr	r3, .L205
 2728 0002 1B68     		ldr	r3, [r3]
 2729              	.LBB126:
 2730              	.LBI126:
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2731              		.loc 2 351 23 is_stmt 1 view .LVU798
 2732              	.LVL210:
 2733              	.LBB127:
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2734              		.loc 2 351 80 view .LVU799
 351:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2735              		.loc 2 351 130 is_stmt 0 view .LVU800
 2736 0004 987A     		ldrb	r0, [r3, #10]	@ zero_extendqisi2
 2737              	.LBE127:
 2738              	.LBE126:
 596:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2739              		.loc 1 596 1 view .LVU801
 2740 0006 00F07F00 		and	r0, r0, #127
 2741 000a 7047     		bx	lr
 2742              	.L206:
 2743              		.align	2
 2744              	.L205:
 2745 000c 00000000 		.word	usb_device
 2746              		.cfi_endproc
 2747              	.LFE161:
 2749              		.section	.text.udd_send_remotewakeup,"ax",%progbits
 2750              		.align	1
 2751              		.global	udd_send_remotewakeup
 2752              		.syntax unified
 2753              		.thumb
 2754              		.thumb_func
 2755              		.fpu fpv4-sp-d16
 2757              	udd_send_remotewakeup:
 2758              	.LFB162:
 598:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t try
 2759              		.loc 1 598 34 is_stmt 1 view -0
 2760              		.cfi_startproc
 2761              		@ args = 0, pretend = 0, frame = 0
 2762              		@ frame_needed = 0, uses_anonymous_args = 0
 2763              		@ link register save eliminated.
 599:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         = 5;
 2764              		.loc 1 599 5 view .LVU803
 2765              	.LVL211:
 601:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 2766              		.loc 1 601 5 view .LVU804
 100:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2767              		.loc 1 100 48 view .LVU805
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2768              		.loc 1 603 17 is_stmt 0 view .LVU806
 2769 0000 064B     		ldr	r3, .L214
 2770 0002 1A68     		ldr	r2, [r3]
 2771 0004 0623     		movs	r3, #6
 2772              	.LVL212:
 2773              	.L208:
 2774              	.LBB128:
 2775              	.LBI128:
 306:tmk_core/protocol/arm_atsam/usb/usb.h ****     /* Sanity check arguments */
 2776              		.loc 2 306 23 is_stmt 1 view .LVU807
 2777              	.LBB129:
 308:tmk_core/protocol/arm_atsam/usb/usb.h ****     Assert(module_inst->hw);
 2778              		.loc 2 308 5 view .LVU808
 309:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2779              		.loc 2 309 5 view .LVU809
 311:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 2780              		.loc 2 311 5 view .LVU810
 311:tmk_core/protocol/arm_atsam/usb/usb.h **** }
 2781              		.loc 2 311 45 is_stmt 0 view .LVU811
 2782 0006 517B     		ldrb	r1, [r2, #13]	@ zero_extendqisi2
 2783              	.LBE129:
 2784              	.LBE128:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2785              		.loc 1 603 11 view .LVU812
 2786 0008 0229     		cmp	r1, #2
 2787 000a 01D0     		beq	.L207
 2788              	.LVL213:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2789              		.loc 1 603 59 discriminator 1 view .LVU813
 2790 000c 013B     		subs	r3, r3, #1
 2791              	.LVL214:
 603:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****         usb_device_send_remote_wake_up(&usb_device);
 2792              		.loc 1 603 59 discriminator 1 view .LVU814
 2793 000e 00D1     		bne	.L210
 2794              	.LVL215:
 2795              	.L207:
 606:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2796              		.loc 1 606 1 view .LVU815
 2797 0010 7047     		bx	lr
 2798              	.LVL216:
 2799              	.L210:
 604:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     }
 2800              		.loc 1 604 9 is_stmt 1 view .LVU816
 2801              	.LBB130:
 2802              	.LBI130:
 376:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 377:tmk_core/protocol/arm_atsam/usb/usb.h **** /**
 378:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \brief USB device send the resume wakeup
 379:tmk_core/protocol/arm_atsam/usb/usb.h ****  *
 380:tmk_core/protocol/arm_atsam/usb/usb.h ****  * \param module_inst Pointer to USB device module instance
 381:tmk_core/protocol/arm_atsam/usb/usb.h ****  */
 382:tmk_core/protocol/arm_atsam/usb/usb.h **** static inline void usb_device_send_remote_wake_up(struct usb_module *module_inst) { module_inst->hw
 2803              		.loc 2 382 20 view .LVU817
 2804              	.LBB131:
 2805              		.loc 2 382 85 view .LVU818
 2806              		.loc 2 382 119 is_stmt 0 view .LVU819
 2807 0012 1189     		ldrh	r1, [r2, #8]
 2808 0014 41F00201 		orr	r1, r1, #2
 2809 0018 1181     		strh	r1, [r2, #8]	@ movhi
 2810 001a F4E7     		b	.L208
 2811              	.L215:
 2812              		.align	2
 2813              	.L214:
 2814 001c 00000000 		.word	usb_device
 2815              	.LBE131:
 2816              	.LBE130:
 2817              		.cfi_endproc
 2818              	.LFE162:
 2820              		.section	.text.udd_set_setup_payload,"ax",%progbits
 2821              		.align	1
 2822              		.global	udd_set_setup_payload
 2823              		.syntax unified
 2824              		.thumb
 2825              		.thumb_func
 2826              		.fpu fpv4-sp-d16
 2828              	udd_set_setup_payload:
 2829              	.LVL217:
 2830              	.LFB163:
 608:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload      = payload;
 2831              		.loc 1 608 69 is_stmt 1 view -0
 2832              		.cfi_startproc
 2833              		@ args = 0, pretend = 0, frame = 0
 2834              		@ frame_needed = 0, uses_anonymous_args = 0
 2835              		@ link register save eliminated.
 609:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload_size = payload_size;
 2836              		.loc 1 609 5 view .LVU821
 609:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_g_ctrlreq.payload_size = payload_size;
 2837              		.loc 1 609 32 is_stmt 0 view .LVU822
 2838 0000 014B     		ldr	r3, .L217
 2839 0002 9860     		str	r0, [r3, #8]
 610:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2840              		.loc 1 610 5 is_stmt 1 view .LVU823
 610:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2841              		.loc 1 610 32 is_stmt 0 view .LVU824
 2842 0004 9981     		strh	r1, [r3, #12]	@ movhi
 611:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 2843              		.loc 1 611 1 view .LVU825
 2844 0006 7047     		bx	lr
 2845              	.L218:
 2846              		.align	2
 2847              	.L217:
 2848 0008 00000000 		.word	udd_g_ctrlreq
 2849              		.cfi_endproc
 2850              	.LFE163:
 2852              		.section	.text.udd_detach,"ax",%progbits
 2853              		.align	1
 2854              		.global	udd_detach
 2855              		.syntax unified
 2856              		.thumb
 2857              		.thumb_func
 2858              		.fpu fpv4-sp-d16
 2860              	udd_detach:
 2861              	.LFB178:
 973:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 974:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_detach(void) {
 2862              		.loc 1 974 23 is_stmt 1 view -0
 2863              		.cfi_startproc
 2864              		@ args = 0, pretend = 0, frame = 0
 2865              		@ frame_needed = 0, uses_anonymous_args = 0
 2866              		@ link register save eliminated.
 975:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_detach(&usb_device);
 2867              		.loc 1 975 5 view .LVU827
 2868 0000 034B     		ldr	r3, .L220
 2869 0002 1A68     		ldr	r2, [r3]
 2870              	.LBB132:
 2871              	.LBI132:
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2872              		.loc 2 329 20 view .LVU828
 2873              	.LVL218:
 2874              	.LBB133:
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2875              		.loc 2 329 72 view .LVU829
 329:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2876              		.loc 2 329 106 is_stmt 0 view .LVU830
 2877 0004 1389     		ldrh	r3, [r2, #8]
 2878 0006 43F00103 		orr	r3, r3, #1
 2879 000a 1381     		strh	r3, [r2, #8]	@ movhi
 2880              	.LBE133:
 2881              	.LBE132:
 976:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 2882              		.loc 1 976 38 is_stmt 1 view .LVU831
 977:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2883              		.loc 1 977 1 is_stmt 0 view .LVU832
 2884 000c 7047     		bx	lr
 2885              	.L221:
 2886 000e 00BF     		.align	2
 2887              	.L220:
 2888 0010 00000000 		.word	usb_device
 2889              		.cfi_endproc
 2890              	.LFE178:
 2892              		.section	.text.udd_attach,"ax",%progbits
 2893              		.align	1
 2894              		.global	udd_attach
 2895              		.syntax unified
 2896              		.thumb
 2897              		.thumb_func
 2898              		.fpu fpv4-sp-d16
 2900              	udd_attach:
 2901              	.LFB179:
 978:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 979:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_attach(void) {
 2902              		.loc 1 979 23 is_stmt 1 view -0
 2903              		.cfi_startproc
 2904              		@ args = 0, pretend = 0, frame = 0
 2905              		@ frame_needed = 0, uses_anonymous_args = 0
 980:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 2906              		.loc 1 980 35 view .LVU834
 981:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_attach(&usb_device);
 2907              		.loc 1 981 5 view .LVU835
 979:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_IDLE);
 2908              		.loc 1 979 23 is_stmt 0 view .LVU836
 2909 0000 10B5     		push	{r4, lr}
 2910              		.cfi_def_cfa_offset 8
 2911              		.cfi_offset 4, -8
 2912              		.cfi_offset 14, -4
 2913              		.loc 1 981 5 view .LVU837
 2914 0002 174C     		ldr	r4, .L223
 2915 0004 2268     		ldr	r2, [r4]
 2916              	.LBB134:
 2917              	.LBI134:
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2918              		.loc 2 322 20 is_stmt 1 view .LVU838
 2919              	.LVL219:
 2920              	.LBB135:
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2921              		.loc 2 322 72 view .LVU839
 322:tmk_core/protocol/arm_atsam/usb/usb.h **** 
 2922              		.loc 2 322 106 is_stmt 0 view .LVU840
 2923 0006 1389     		ldrh	r3, [r2, #8]
 2924 0008 23F00103 		bic	r3, r3, #1
 2925 000c 1B04     		lsls	r3, r3, #16
 2926 000e 1B0C     		lsrs	r3, r3, #16
 2927 0010 1381     		strh	r3, [r2, #8]	@ movhi
 2928              	.LBE135:
 2929              	.LBE134:
 982:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 983:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND, _usb_on_suspend);
 2930              		.loc 1 983 5 is_stmt 1 view .LVU841
 2931 0012 0421     		movs	r1, #4
 2932 0014 134A     		ldr	r2, .L223+4
 2933 0016 2046     		mov	r0, r4
 2934 0018 FFF7FEFF 		bl	usb_device_register_callback
 2935              	.LVL220:
 984:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_SOF, _usb_on_sof_notify);
 2936              		.loc 1 984 5 view .LVU842
 2937 001c 124A     		ldr	r2, .L223+8
 2938 001e 0021     		movs	r1, #0
 2939 0020 2046     		mov	r0, r4
 2940 0022 FFF7FEFF 		bl	usb_device_register_callback
 2941              	.LVL221:
 985:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_RESET, _usb_on_bus_reset);
 2942              		.loc 1 985 5 view .LVU843
 2943 0026 114A     		ldr	r2, .L223+12
 2944 0028 0121     		movs	r1, #1
 2945 002a 2046     		mov	r0, r4
 2946 002c FFF7FEFF 		bl	usb_device_register_callback
 2947              	.LVL222:
 986:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP, _usb_on_wakeup);
 2948              		.loc 1 986 5 view .LVU844
 2949 0030 0F4A     		ldr	r2, .L223+16
 2950 0032 0221     		movs	r1, #2
 2951 0034 2046     		mov	r0, r4
 2952 0036 FFF7FEFF 		bl	usb_device_register_callback
 2953              	.LVL223:
 987:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 988:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SUSPEND);
 2954              		.loc 1 988 5 view .LVU845
 2955 003a 0421     		movs	r1, #4
 2956 003c 2046     		mov	r0, r4
 2957 003e FFF7FEFF 		bl	usb_device_enable_callback
 2958              	.LVL224:
 989:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_SOF);
 2959              		.loc 1 989 5 view .LVU846
 2960 0042 0021     		movs	r1, #0
 2961 0044 2046     		mov	r0, r4
 2962 0046 FFF7FEFF 		bl	usb_device_enable_callback
 2963              	.LVL225:
 990:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_RESET);
 2964              		.loc 1 990 5 view .LVU847
 2965 004a 0121     		movs	r1, #1
 2966 004c 2046     		mov	r0, r4
 2967 004e FFF7FEFF 		bl	usb_device_enable_callback
 2968              	.LVL226:
 991:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 2969              		.loc 1 991 5 view .LVU848
 2970 0052 2046     		mov	r0, r4
 2971 0054 0221     		movs	r1, #2
 992:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifdef USB_DEVICE_LPM_SUPPORT
 993:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_register_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP, _usb_device_lpm_suspend)
 994:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_LPMSUSP);
 995:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
 996:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 2972              		.loc 1 996 1 is_stmt 0 view .LVU849
 2973 0056 BDE81040 		pop	{r4, lr}
 2974              		.cfi_restore 14
 2975              		.cfi_restore 4
 2976              		.cfi_def_cfa_offset 0
 991:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_device_enable_callback(&usb_device, USB_DEVICE_CALLBACK_WAKEUP);
 2977              		.loc 1 991 5 view .LVU850
 2978 005a FFF7FEBF 		b	usb_device_enable_callback
 2979              	.LVL227:
 2980              	.L224:
 2981 005e 00BF     		.align	2
 2982              	.L223:
 2983 0060 00000000 		.word	usb_device
 2984 0064 00000000 		.word	_usb_on_suspend
 2985 0068 00000000 		.word	_usb_on_sof_notify
 2986 006c 00000000 		.word	_usb_on_bus_reset
 2987 0070 00000000 		.word	_usb_on_wakeup
 2988              		.cfi_endproc
 2989              	.LFE179:
 2991              		.section	.text.udd_enable,"ax",%progbits
 2992              		.align	1
 2993              		.global	udd_enable
 2994              		.syntax unified
 2995              		.thumb
 2996              		.thumb_func
 2997              		.fpu fpv4-sp-d16
 2999              	udd_enable:
 3000              	.LFB180:
 997:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 998:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_enable(void) {
 3001              		.loc 1 998 23 is_stmt 1 view -0
 3002              		.cfi_startproc
 3003              		@ args = 0, pretend = 0, frame = 8
 3004              		@ frame_needed = 0, uses_anonymous_args = 0
 999:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t irqflags;
 3005              		.loc 1 999 5 view .LVU852
1000:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1001:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* To avoid USB interrupt before end of initialization */
1002:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     irqflags = __get_PRIMASK();
 3006              		.loc 1 1002 5 view .LVU853
 3007              	.LBB136:
 3008              	.LBI136:
 309:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 3009              		.loc 3 309 57 view .LVU854
 3010              	.LBB137:
 311:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** 
 3011              		.loc 3 311 3 view .LVU855
 313:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 3012              		.loc 3 313 3 view .LVU856
 3013              	.LBE137:
 3014              	.LBE136:
 998:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     uint32_t irqflags;
 3015              		.loc 1 998 23 is_stmt 0 view .LVU857
 3016 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 3017              		.cfi_def_cfa_offset 24
 3018              		.cfi_offset 4, -12
 3019              		.cfi_offset 5, -8
 3020              		.cfi_offset 14, -4
 3021              	.LBB139:
 3022              	.LBB138:
 313:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h ****   return(result);
 3023              		.loc 3 313 3 view .LVU858
 3024              		.syntax unified
 3025              	@ 313 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 3026 0002 EFF31085 		MRS r5, primask
 3027              	@ 0 "" 2
 3028              	.LVL228:
 314:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 3029              		.loc 3 314 3 is_stmt 1 view .LVU859
 314:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 3030              		.loc 3 314 3 is_stmt 0 view .LVU860
 3031              		.thumb
 3032              		.syntax unified
 3033              	.LBE138:
 3034              	.LBE139:
1003:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __disable_irq();
 3035              		.loc 1 1003 5 is_stmt 1 view .LVU861
 3036              	.LBB140:
 3037              	.LBI140:
  94:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 3038              		.loc 3 94 53 view .LVU862
 3039              	.LBB141:
  96:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 3040              		.loc 3 96 3 view .LVU863
 3041              		.syntax unified
 3042              	@ 96 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 3043 0006 72B6     		cpsid i
 3044              	@ 0 "" 2
 3045              		.thumb
 3046              		.syntax unified
 3047              	.LBE141:
 3048              	.LBE140:
1004:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 3049              		.loc 1 1004 5 view .LVU864
 3050              	.LBB142:
 3051              	.LBI142:
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 3052              		.loc 3 762 53 view .LVU865
 3053              	.LBB143:
 3054              		.loc 3 764 3 view .LVU866
 3055              		.syntax unified
 3056              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 3057 0008 BFF35F8F 		dmb 0xF
 3058              	@ 0 "" 2
 3059              		.thumb
 3060              		.syntax unified
 3061              	.LBE143:
 3062              	.LBE142:
1005:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1006:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     struct usb_config config_usb;
 3063              		.loc 1 1006 5 view .LVU867
1007:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1008:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Module configuration */
1009:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_get_config_defaults(&config_usb);
 3064              		.loc 1 1009 5 view .LVU868
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
1011:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_init(&usb_device, USB, &config_usb);
 3065              		.loc 1 1011 5 is_stmt 0 view .LVU869
 3066 000c 0B4C     		ldr	r4, .L226
1009:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
 3067              		.loc 1 1009 5 view .LVU870
 3068 000e 01A8     		add	r0, sp, #4
 3069 0010 FFF7FEFF 		bl	usb_get_config_defaults
 3070              	.LVL229:
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
 3071              		.loc 1 1010 5 is_stmt 1 view .LVU871
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
 3072              		.loc 1 1010 33 is_stmt 0 view .LVU872
 3073 0014 0023     		movs	r3, #0
 3074              		.loc 1 1011 5 view .LVU873
 3075 0016 01AA     		add	r2, sp, #4
 3076 0018 4FF08241 		mov	r1, #1090519040
 3077 001c 2046     		mov	r0, r4
1010:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     config_usb.source_generator = UDD_CLOCK_GEN;
 3078              		.loc 1 1010 33 view .LVU874
 3079 001e 8DF80630 		strb	r3, [sp, #6]
 3080              		.loc 1 1011 5 is_stmt 1 view .LVU875
 3081 0022 FFF7FEFF 		bl	usb_init
 3082              	.LVL230:
1012:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1013:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* USB Module Enable */
1014:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     usb_enable(&usb_device);
 3083              		.loc 1 1014 5 view .LVU876
 3084 0026 2046     		mov	r0, r4
 3085 0028 FFF7FEFF 		bl	usb_enable
 3086              	.LVL231:
1015:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1016:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     /* Check clock after enable module, request the clock */
1017:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_wait_clock_ready();
 3087              		.loc 1 1017 5 view .LVU877
 100:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
 3088              		.loc 1 100 48 view .LVU878
1018:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1019:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_sleep_mode(UDD_STATE_SUSPEND);
 3089              		.loc 1 1019 38 view .LVU879
1020:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1021:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     // No VBus detect, assume always high
1022:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
1023:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_attach();
 3090              		.loc 1 1023 5 view .LVU880
 3091 002c FFF7FEFF 		bl	udd_attach
 3092              	.LVL232:
1024:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** #endif
1025:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1026:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __DMB();
 3093              		.loc 1 1026 5 view .LVU881
 3094              	.LBB144:
 3095              	.LBI144:
 762:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 3096              		.loc 3 762 53 view .LVU882
 3097              	.LBB145:
 3098              		.loc 3 764 3 view .LVU883
 3099              		.syntax unified
 3100              	@ 764 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 3101 0030 BFF35F8F 		dmb 0xF
 3102              	@ 0 "" 2
 3103              		.thumb
 3104              		.syntax unified
 3105              	.LBE145:
 3106              	.LBE144:
1027:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     __set_PRIMASK(irqflags);
 3107              		.loc 1 1027 5 view .LVU884
 3108              	.LVL233:
 3109              	.LBB146:
 3110              	.LBI146:
 339:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** {
 3111              		.loc 3 339 53 view .LVU885
 3112              	.LBB147:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 3113              		.loc 3 341 3 view .LVU886
 3114              		.syntax unified
 3115              	@ 341 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h" 1
 3116 0034 85F31088 		MSR primask, r5
 3117              	@ 0 "" 2
 3118              	.LVL234:
 341:lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/cmsis_gcc.h **** }
 3119              		.loc 3 341 3 is_stmt 0 view .LVU887
 3120              		.thumb
 3121              		.syntax unified
 3122              	.LBE147:
 3123              	.LBE146:
1028:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** }
 3124              		.loc 1 1028 1 view .LVU888
 3125 0038 03B0     		add	sp, sp, #12
 3126              		.cfi_def_cfa_offset 12
 3127              		@ sp needed
 3128 003a 30BD     		pop	{r4, r5, pc}
 3129              	.LVL235:
 3130              	.L227:
 3131              		.loc 1 1028 1 view .LVU889
 3132              		.align	2
 3133              	.L226:
 3134 003c 00000000 		.word	usb_device
 3135              		.cfi_endproc
 3136              	.LFE180:
 3138              		.section	.text.udd_disable,"ax",%progbits
 3139              		.align	1
 3140              		.global	udd_disable
 3141              		.syntax unified
 3142              		.thumb
 3143              		.thumb_func
 3144              		.fpu fpv4-sp-d16
 3146              	udd_disable:
 3147              	.LFB181:
1029:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** 
1030:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c **** void udd_disable(void) {
 3148              		.loc 1 1030 24 is_stmt 1 view -0
 3149              		.cfi_startproc
 3150              		@ args = 0, pretend = 0, frame = 0
 3151              		@ frame_needed = 0, uses_anonymous_args = 0
 3152              		@ link register save eliminated.
1031:tmk_core/protocol/arm_atsam/usb/usb_device_udd.c ****     udd_detach();
 3153              		.loc 1 1031 5 view .LVU891
 3154 0000 FFF7FEBF 		b	udd_detach
 3155              	.LVL236:
 3156              		.cfi_endproc
 3157              	.LFE181:
 3159              		.comm	udd_ep_out_cache_buffer,256,4
 3160              		.comm	udd_g_ctrlreq,24,4
 3161              		.comm	udd_ctrl_buffer,8,4
 3162              		.comm	usb_device,180,4
 3163              		.bss
 3164              		.align	2
 3165              		.set	.LANCHOR0,. + 0
 3168              	udd_ep_job:
 3169 0000 00000000 		.space	160
 3169      00000000 
 3169      00000000 
 3169      00000000 
 3169      00000000 
 3172              	udd_ep_control_state:
 3173 00a0 00       		.space	1
 3174 00a1 00       		.space	1
 3177              	udd_ctrl_payload_nb_trans:
 3178 00a2 0000     		.space	2
 3181              	udd_ctrl_prev_payload_nb_trans:
 3182 00a4 0000     		.space	2
 3185              	b_shortpacket.19158:
 3186 00a6 00       		.space	1
 3187              		.text
 3188              	.Letext0:
 3189              		.file 4 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/machine/_default_t
 3190              		.file 5 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/sys/_stdint.h"
 3191              		.file 6 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/samd51j18a.h"
 3192              		.file 7 "lib/arm_atsam/packs/arm/cmsis/5.0.1/CMSIS/Include/core_cm4.h"
 3193              		.file 8 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/system_samd51.h"
 3194              		.file 9 "lib/arm_atsam/packs/atmel/SAMD51_DFP/1.0.70/include/component/usb.h"
 3195              		.file 10 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/lib/gcc/arm-none-eabi/8.3.1/include/std
 3196              		.file 11 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/sys/_types.h"
 3197              		.file 12 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/sys/reent.h"
 3198              		.file 13 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/sys/lock.h"
 3199              		.file 14 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/stdlib.h"
 3200              		.file 15 "tmk_core/protocol/arm_atsam/usb/compiler.h"
 3201              		.file 16 "tmk_core/protocol/arm_atsam/usb/usb_protocol.h"
 3202              		.file 17 "tmk_core/protocol/arm_atsam/usb/udi_device_conf.h"
 3203              		.file 18 "tmk_core/protocol/arm_atsam/usb/udi.h"
 3204              		.file 19 "tmk_core/protocol/arm_atsam/usb/udc_desc.h"
 3205              		.file 20 "tmk_core/protocol/arm_atsam/usb/udi_hid_kbd.h"
 3206              		.file 21 "tmk_core/protocol/arm_atsam/usb/usb_main.h"
 3207              		.file 22 "tmk_core/protocol/arm_atsam/usb/udd.h"
 3208              		.file 23 "tmk_core/protocol/arm_atsam/usb/status_codes.h"
 3209              		.file 24 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_device_udd.c
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:18     .text.udd_ep_get_job:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:25     .text.udd_ep_get_job:0000000000000000 udd_ep_get_job
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:60     .text.udd_ep_get_job:0000000000000020 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:65     .text.udd_ep_transfer_process:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:71     .text.udd_ep_transfer_process:0000000000000000 udd_ep_transfer_process
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:417    .text.udd_ep_transfer_process:0000000000000130 $d
                            *COM*:00000000000000b4 usb_device
                            *COM*:0000000000000100 udd_ep_out_cache_buffer
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:423    .text.udd_ctrl_stall_data:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:429    .text.udd_ctrl_stall_data:0000000000000000 udd_ctrl_stall_data
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:470    .text.udd_ctrl_stall_data:0000000000000020 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:476    .text._usb_on_wakeup:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:482    .text._usb_on_wakeup:0000000000000000 _usb_on_wakeup
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:525    .text._usb_on_wakeup:000000000000001c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:530    .text._usb_on_bus_reset:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:536    .text._usb_on_bus_reset:0000000000000000 _usb_on_bus_reset
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:655    .text._usb_on_bus_reset:0000000000000078 $d
                            *COM*:0000000000000008 udd_ctrl_buffer
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:967    .text._usb_ep0_on_setup:0000000000000000 _usb_ep0_on_setup
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1839   .text._usb_ep0_on_tansfer_ok:0000000000000000 _usb_ep0_on_tansfer_ok
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:728    .text._usb_ep0_on_tansfer_fail:0000000000000000 _usb_ep0_on_tansfer_fail
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:664    .text.udd_ctrl_send_zlp_in:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:670    .text.udd_ctrl_send_zlp_in:0000000000000000 udd_ctrl_send_zlp_in
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:714    .text.udd_ctrl_send_zlp_in:0000000000000028 $d
                            *COM*:0000000000000018 udd_g_ctrlreq
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:722    .text._usb_ep0_on_tansfer_fail:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:813    .text._usb_ep0_on_tansfer_fail:0000000000000030 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:819    .text.udd_ctrl_in_sent:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:825    .text.udd_ctrl_in_sent:0000000000000000 udd_ctrl_in_sent
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:953    .text.udd_ctrl_in_sent:000000000000007c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:961    .text._usb_ep0_on_setup:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1175   .text._usb_ep0_on_setup:00000000000000ac $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1183   .text._usb_on_sof_notify:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1189   .text._usb_on_sof_notify:0000000000000000 _usb_on_sof_notify
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1218   .text._usb_on_suspend:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1224   .text._usb_on_suspend:0000000000000000 _usb_on_suspend
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1265   .text._usb_on_suspend:000000000000001c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1270   .text.udd_ep_abort:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1277   .text.udd_ep_abort:0000000000000000 udd_ep_abort
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1343   .text.udd_ep_abort:0000000000000030 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1348   .text.udd_is_high_speed:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1355   .text.udd_is_high_speed:0000000000000000 udd_is_high_speed
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1370   .text.udd_get_frame_number:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1377   .text.udd_get_frame_number:0000000000000000 udd_get_frame_number
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1404   .text.udd_get_frame_number:000000000000000c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1409   .text.udd_get_micro_frame_number:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1416   .text.udd_get_micro_frame_number:0000000000000000 udd_get_micro_frame_number
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1442   .text.udd_get_micro_frame_number:0000000000000008 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1447   .text.udd_ep_free:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1454   .text.udd_ep_free:0000000000000000 udd_ep_free
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1521   .text.udd_ep_free:0000000000000040 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1526   .text.udd_ep_alloc:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1533   .text.udd_ep_alloc:0000000000000000 udd_ep_alloc
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1736   .text.udd_ep_alloc:00000000000000b8 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1742   .text.udd_ep_is_halted:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1749   .text.udd_ep_is_halted:0000000000000000 udd_ep_is_halted
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1768   .text.udd_ep_is_halted:0000000000000008 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1773   .text.udd_ep_set_halt:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1780   .text.udd_ep_set_halt:0000000000000000 udd_ep_set_halt
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1828   .text.udd_ep_set_halt:0000000000000024 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:1833   .text._usb_ep0_on_tansfer_ok:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2085   .text._usb_ep0_on_tansfer_ok:00000000000000bc $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2093   .text.udd_ep_clear_halt:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2100   .text.udd_ep_clear_halt:0000000000000000 udd_ep_clear_halt
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2164   .text.udd_ep_clear_halt:0000000000000030 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2169   .text.udd_ep_wait_stall_clear:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2176   .text.udd_ep_wait_stall_clear:0000000000000000 udd_ep_wait_stall_clear
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2273   .text.udd_ep_wait_stall_clear:000000000000004c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2278   .text.udd_ep_run:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2285   .text.udd_ep_run:0000000000000000 udd_ep_run
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2662   .text.udd_ep_run:0000000000000138 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2668   .text.udd_set_address:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2675   .text.udd_set_address:0000000000000000 udd_set_address
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2706   .text.udd_set_address:000000000000000c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2711   .text.udd_getaddress:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2718   .text.udd_getaddress:0000000000000000 udd_getaddress
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2745   .text.udd_getaddress:000000000000000c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2750   .text.udd_send_remotewakeup:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2757   .text.udd_send_remotewakeup:0000000000000000 udd_send_remotewakeup
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2814   .text.udd_send_remotewakeup:000000000000001c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2821   .text.udd_set_setup_payload:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2828   .text.udd_set_setup_payload:0000000000000000 udd_set_setup_payload
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2848   .text.udd_set_setup_payload:0000000000000008 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2853   .text.udd_detach:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2860   .text.udd_detach:0000000000000000 udd_detach
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2888   .text.udd_detach:0000000000000010 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2893   .text.udd_attach:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2900   .text.udd_attach:0000000000000000 udd_attach
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2983   .text.udd_attach:0000000000000060 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2992   .text.udd_enable:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:2999   .text.udd_enable:0000000000000000 udd_enable
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3134   .text.udd_enable:000000000000003c $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3139   .text.udd_disable:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3146   .text.udd_disable:0000000000000000 udd_disable
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3164   .bss:0000000000000000 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3168   .bss:0000000000000000 udd_ep_job
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3172   .bss:00000000000000a0 udd_ep_control_state
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3177   .bss:00000000000000a2 udd_ctrl_payload_nb_trans
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3181   .bss:00000000000000a4 udd_ctrl_prev_payload_nb_trans
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cc1NSuQo.s:3185   .bss:00000000000000a6 b_shortpacket.19158

UNDEFINED SYMBOLS
usb_device_endpoint_write_buffer_job
memcpy
usb_device_endpoint_read_buffer_job
usb_device_endpoint_set_halt
usb_device_endpoint_clear_halt
usb_device_disable_callback
usb_device_enable_callback
main_resume_action
udc_reset
usb_device_endpoint_get_config_defaults
usb_device_endpoint_set_config
usb_device_endpoint_setup_buffer_job
usb_device_endpoint_register_callback
usb_device_endpoint_enable_callback
udc_process_setup
udc_sof_notify
main_sof_action
main_suspend_action
usb_device_endpoint_abort_job
usb_device_endpoint_unregister_callback
usb_device_endpoint_disable_callback
usb_device_endpoint_is_halted
usb_device_endpoint_is_configured
usb_device_register_callback
usb_get_config_defaults
usb_init
usb_enable
