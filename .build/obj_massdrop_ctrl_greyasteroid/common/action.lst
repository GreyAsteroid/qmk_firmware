   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"action.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.action_exec,"ax",%progbits
  18              		.align	1
  19              		.global	action_exec
  20              		.arch armv7e-m
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  24              		.fpu fpv4-sp-d16
  26              	action_exec:
  27              	.LFB8:
  28              		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  29              		.loc 1 64 36 view -0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34 0000 84B0     		sub	sp, sp, #16
  35              		.cfi_def_cfa_offset 16
  36              	.LVL0:
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  37              		.loc 1 65 5 view .LVU1
  38              		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  39              		.loc 2 48 51 view .LVU2
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  40              		.loc 1 69 19 view .LVU3
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  41              		.loc 1 91 5 view .LVU4
  64:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  42              		.loc 1 64 36 is_stmt 0 view .LVU5
  43 0002 6B46     		mov	r3, sp
  44 0004 83E80300 		stm	r3, {r0, r1}
  45              	.LVL1:
  46              		.loc 1 91 17 view .LVU6
  47 0008 0022     		movs	r2, #0
  48 000a ADF80E20 		strh	r2, [sp, #14]	@ movhi
  49 000e 93E80300 		ldm	r3, {r0, r1}
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 103:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 104:tmk_core/common/action.c ****     }
 105:tmk_core/common/action.c **** #        endif
 106:tmk_core/common/action.c **** #    endif
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 110:tmk_core/common/action.c ****     action_tapping_process(record);
  50              		.loc 1 110 5 view .LVU7
  51 0012 04AB     		add	r3, sp, #16
  91:tmk_core/common/action.c **** 
  52              		.loc 1 91 17 view .LVU8
  53 0014 0290     		str	r0, [sp, #8]
  54 0016 ADF80C10 		strh	r1, [sp, #12]	@ movhi
  55              		.loc 1 110 5 is_stmt 1 view .LVU9
  56 001a 13E90300 		ldmdb	r3, {r0, r1}
 111:tmk_core/common/action.c **** #else
 112:tmk_core/common/action.c ****     process_record(&record);
 113:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 114:tmk_core/common/action.c ****         dprint("processed: ");
 115:tmk_core/common/action.c ****         debug_record(record);
 116:tmk_core/common/action.c ****         dprintln();
 117:tmk_core/common/action.c ****     }
 118:tmk_core/common/action.c **** #endif
 119:tmk_core/common/action.c **** }
  57              		.loc 1 119 1 is_stmt 0 view .LVU10
  58 001e 04B0     		add	sp, sp, #16
  59              		.cfi_def_cfa_offset 0
  60              		@ sp needed
 110:tmk_core/common/action.c **** #else
  61              		.loc 1 110 5 view .LVU11
  62 0020 FFF7FEBF 		b	action_tapping_process
  63              	.LVL2:
  64              		.cfi_endproc
  65              	.LFE8:
  67              		.section	.text.process_record_quantum,"ax",%progbits
  68              		.align	1
  69              		.weak	process_record_quantum
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  73              		.fpu fpv4-sp-d16
  75              	process_record_quantum:
  76              	.LVL3:
  77              	.LFB10:
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 122:tmk_core/common/action.c **** bool swap_hands = false;
 123:tmk_core/common/action.c **** bool swap_held  = false;
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c **** /** \brief Process Hand Swap
 126:tmk_core/common/action.c ****  *
 127:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 128:tmk_core/common/action.c ****  */
 129:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 130:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 133:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 135:tmk_core/common/action.c **** 
 136:tmk_core/common/action.c ****     if (do_swap) {
 137:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  78              		.loc 1 157 72 is_stmt 1 view -0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              		@ link register save eliminated.
  83              		.loc 1 157 74 view .LVU13
  84              		.loc 1 157 1 is_stmt 0 view .LVU14
  85 0000 0120     		movs	r0, #1
  86              	.LVL4:
  87              		.loc 1 157 1 view .LVU15
  88 0002 7047     		bx	lr
  89              		.cfi_endproc
  90              	.LFE10:
  92              		.section	.text.post_process_record_quantum,"ax",%progbits
  93              		.align	1
  94              		.weak	post_process_record_quantum
  95              		.syntax unified
  96              		.thumb
  97              		.thumb_func
  98              		.fpu fpv4-sp-d16
 100              	post_process_record_quantum:
 101              	.LVL5:
 102              	.LFB11:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 103              		.loc 1 159 77 is_stmt 1 view -0
 104              		.cfi_startproc
 105              		@ args = 0, pretend = 0, frame = 0
 106              		@ frame_needed = 0, uses_anonymous_args = 0
 107              		@ link register save eliminated.
 108              		.loc 1 159 78 view .LVU17
 109              		.loc 1 159 1 is_stmt 0 view .LVU18
 110 0000 7047     		bx	lr
 111              		.cfi_endproc
 112              	.LFE11:
 114              		.section	.text.process_record_tap_hint,"ax",%progbits
 115              		.align	1
 116              		.global	process_record_tap_hint
 117              		.syntax unified
 118              		.thumb
 119              		.thumb_func
 120              		.fpu fpv4-sp-d16
 122              	process_record_tap_hint:
 123              	.LVL6:
 124              	.LFB12:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 125              		.loc 1 166 51 is_stmt 1 view -0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              		@ link register save eliminated.
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 130              		.loc 1 167 5 view .LVU20
 131              		.loc 1 167 23 is_stmt 0 view .LVU21
 132 0000 0088     		ldrh	r0, [r0]
 133              	.LVL7:
 134              		.loc 1 167 23 view .LVU22
 135 0002 FFF7FEBF 		b	layer_switch_get_action
 136              	.LVL8:
 137              		.cfi_endproc
 138              	.LFE12:
 140              		.section	.text.register_code,"ax",%progbits
 141              		.align	1
 142              		.global	register_code
 143              		.syntax unified
 144              		.thumb
 145              		.thumb_func
 146              		.fpu fpv4-sp-d16
 148              	register_code:
 149              	.LVL9:
 150              	.LFB16:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 224:tmk_core/common/action.c ****  *
 225:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 226:tmk_core/common/action.c ****  */
 227:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 228:tmk_core/common/action.c ****     keyevent_t event = record->event;
 229:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 230:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     if (event.pressed) {
 234:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 235:tmk_core/common/action.c ****         clear_weak_mods();
 236:tmk_core/common/action.c ****     }
 237:tmk_core/common/action.c **** 
 238:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 239:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 240:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 241:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 242:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 243:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 244:tmk_core/common/action.c **** #    endif
 245:tmk_core/common/action.c ****     ) {
 246:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 247:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 248:tmk_core/common/action.c ****     }
 249:tmk_core/common/action.c **** #endif
 250:tmk_core/common/action.c **** 
 251:tmk_core/common/action.c ****     switch (action.kind.id) {
 252:tmk_core/common/action.c ****         /* Key and Mods */
 253:tmk_core/common/action.c ****         case ACT_LMODS:
 254:tmk_core/common/action.c ****         case ACT_RMODS: {
 255:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 256:tmk_core/common/action.c ****             if (event.pressed) {
 257:tmk_core/common/action.c ****                 if (mods) {
 258:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 259:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 260:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 261:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 262:tmk_core/common/action.c ****                         add_mods(mods);
 263:tmk_core/common/action.c ****                     } else {
 264:tmk_core/common/action.c ****                         add_weak_mods(mods);
 265:tmk_core/common/action.c ****                     }
 266:tmk_core/common/action.c ****                     send_keyboard_report();
 267:tmk_core/common/action.c ****                 }
 268:tmk_core/common/action.c ****                 register_code(action.key.code);
 269:tmk_core/common/action.c ****             } else {
 270:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 271:tmk_core/common/action.c ****                 if (mods) {
 272:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 273:tmk_core/common/action.c ****                         del_mods(mods);
 274:tmk_core/common/action.c ****                     } else {
 275:tmk_core/common/action.c ****                         del_weak_mods(mods);
 276:tmk_core/common/action.c ****                     }
 277:tmk_core/common/action.c ****                     send_keyboard_report();
 278:tmk_core/common/action.c ****                 }
 279:tmk_core/common/action.c ****             }
 280:tmk_core/common/action.c ****         } break;
 281:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 282:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 283:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 284:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 285:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 286:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 287:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 288:tmk_core/common/action.c ****                     // Oneshot modifier
 289:tmk_core/common/action.c ****                     if (event.pressed) {
 290:tmk_core/common/action.c ****                         if (tap_count == 0) {
 291:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 292:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 293:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 294:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 295:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 296:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 297:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 299:tmk_core/common/action.c ****                             clear_oneshot_mods();
 300:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 301:tmk_core/common/action.c ****                             register_mods(mods);
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     } else {
 307:tmk_core/common/action.c ****                         if (tap_count == 0) {
 308:tmk_core/common/action.c ****                             clear_oneshot_mods();
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 310:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 311:tmk_core/common/action.c ****                             // Retain Oneshot mods
 312:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 313:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 314:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 315:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 316:tmk_core/common/action.c ****                                 unregister_mods(mods);
 317:tmk_core/common/action.c ****                             }
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 320:tmk_core/common/action.c **** #        endif
 321:tmk_core/common/action.c ****                         } else {
 322:tmk_core/common/action.c ****                             clear_oneshot_mods();
 323:tmk_core/common/action.c ****                             unregister_mods(mods);
 324:tmk_core/common/action.c ****                         }
 325:tmk_core/common/action.c ****                     }
 326:tmk_core/common/action.c ****                     break;
 327:tmk_core/common/action.c **** #    endif
 328:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 329:tmk_core/common/action.c ****                     if (event.pressed) {
 330:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 331:tmk_core/common/action.c ****                             register_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     } else {
 334:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     }
 338:tmk_core/common/action.c ****                     break;
 339:tmk_core/common/action.c ****                 default:
 340:tmk_core/common/action.c ****                     if (event.pressed) {
 341:tmk_core/common/action.c ****                         if (tap_count > 0) {
 342:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 343:tmk_core/common/action.c ****                             if (
 344:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 345:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 346:tmk_core/common/action.c **** #        endif
 347:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 348:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 349:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 350:tmk_core/common/action.c ****                                 record->tap.count = 0;
 351:tmk_core/common/action.c ****                                 register_mods(mods);
 352:tmk_core/common/action.c ****                             } else
 353:tmk_core/common/action.c **** #    endif
 354:tmk_core/common/action.c ****                             {
 355:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 356:tmk_core/common/action.c ****                                 register_code(action.key.code);
 357:tmk_core/common/action.c ****                             }
 358:tmk_core/common/action.c ****                         } else {
 359:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 360:tmk_core/common/action.c ****                             register_mods(mods);
 361:tmk_core/common/action.c ****                         }
 362:tmk_core/common/action.c ****                     } else {
 363:tmk_core/common/action.c ****                         if (tap_count > 0) {
 364:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 365:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 366:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 367:tmk_core/common/action.c ****                             } else {
 368:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 369:tmk_core/common/action.c ****                             }
 370:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 371:tmk_core/common/action.c ****                         } else {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 373:tmk_core/common/action.c ****                             unregister_mods(mods);
 374:tmk_core/common/action.c ****                         }
 375:tmk_core/common/action.c ****                     }
 376:tmk_core/common/action.c ****                     break;
 377:tmk_core/common/action.c ****             }
 378:tmk_core/common/action.c ****         } break;
 379:tmk_core/common/action.c **** #endif
 380:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 381:tmk_core/common/action.c ****         /* other HID usage */
 382:tmk_core/common/action.c ****         case ACT_USAGE:
 383:tmk_core/common/action.c ****             switch (action.usage.page) {
 384:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 385:tmk_core/common/action.c ****                     if (event.pressed) {
 386:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 387:tmk_core/common/action.c ****                     } else {
 388:tmk_core/common/action.c ****                         host_system_send(0);
 389:tmk_core/common/action.c ****                     }
 390:tmk_core/common/action.c ****                     break;
 391:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 392:tmk_core/common/action.c ****                     if (event.pressed) {
 393:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 394:tmk_core/common/action.c ****                     } else {
 395:tmk_core/common/action.c ****                         host_consumer_send(0);
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****             break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 402:tmk_core/common/action.c ****         /* Mouse key */
 403:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 404:tmk_core/common/action.c ****             if (event.pressed) {
 405:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 406:tmk_core/common/action.c ****                 switch (action.key.code) {
 407:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 408:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 409:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 412:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 413:tmk_core/common/action.c ****                         break;
 414:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 415:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 416:tmk_core/common/action.c ****                         break;
 417:tmk_core/common/action.c **** #    endif
 418:tmk_core/common/action.c ****                     default:
 419:tmk_core/common/action.c ****                         mousekey_send();
 420:tmk_core/common/action.c ****                         break;
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 424:tmk_core/common/action.c ****                 switch (action.key.code) {
 425:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 426:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 427:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 428:tmk_core/common/action.c ****                         break;
 429:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 430:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 433:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c **** #    endif
 436:tmk_core/common/action.c ****                     default:
 437:tmk_core/common/action.c ****                         mousekey_send();
 438:tmk_core/common/action.c ****                         break;
 439:tmk_core/common/action.c ****                 }
 440:tmk_core/common/action.c ****             }
 441:tmk_core/common/action.c ****             break;
 442:tmk_core/common/action.c **** #endif
 443:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 444:tmk_core/common/action.c ****         case ACT_LAYER:
 445:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 446:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 447:tmk_core/common/action.c ****                 if (!event.pressed) {
 448:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 449:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 450:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 451:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 452:tmk_core/common/action.c ****                         case OP_BIT_AND:
 453:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_OR:
 456:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 459:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                         case OP_BIT_SET:
 462:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 463:tmk_core/common/action.c ****                             break;
 464:tmk_core/common/action.c ****                     }
 465:tmk_core/common/action.c ****                 }
 466:tmk_core/common/action.c ****             } else {
 467:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 468:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 469:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 470:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 471:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 472:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 473:tmk_core/common/action.c ****                         case OP_BIT_AND:
 474:tmk_core/common/action.c ****                             layer_and(bits | mask);
 475:tmk_core/common/action.c ****                             break;
 476:tmk_core/common/action.c ****                         case OP_BIT_OR:
 477:tmk_core/common/action.c ****                             layer_or(bits | mask);
 478:tmk_core/common/action.c ****                             break;
 479:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 480:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 481:tmk_core/common/action.c ****                             break;
 482:tmk_core/common/action.c ****                         case OP_BIT_SET:
 483:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 484:tmk_core/common/action.c ****                             break;
 485:tmk_core/common/action.c ****                     }
 486:tmk_core/common/action.c ****                 }
 487:tmk_core/common/action.c ****             }
 488:tmk_core/common/action.c ****             break;
 489:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 490:tmk_core/common/action.c ****             if (event.pressed) {
 491:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 492:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 493:tmk_core/common/action.c ****             } else {
 494:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 495:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 496:tmk_core/common/action.c ****             }
 497:tmk_core/common/action.c ****             break;
 498:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 499:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 500:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 501:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 502:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 503:tmk_core/common/action.c ****                     /* tap toggle */
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 506:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         }
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 510:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 511:tmk_core/common/action.c ****                         }
 512:tmk_core/common/action.c ****                     }
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****                 case OP_ON_OFF:
 515:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 516:tmk_core/common/action.c ****                     break;
 517:tmk_core/common/action.c ****                 case OP_OFF_ON:
 518:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 519:tmk_core/common/action.c ****                     break;
 520:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 521:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 522:tmk_core/common/action.c ****                     break;
 523:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 524:tmk_core/common/action.c ****                 case OP_ONESHOT:
 525:tmk_core/common/action.c ****                     // Oneshot modifier
 526:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 527:tmk_core/common/action.c ****                     do_release_oneshot = false;
 528:tmk_core/common/action.c ****                     if (event.pressed) {
 529:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 533:tmk_core/common/action.c ****                             break;
 534:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 535:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 536:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     } else {
 539:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 540:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 541:tmk_core/common/action.c ****                             reset_oneshot_layer();
 542:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 543:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 544:tmk_core/common/action.c ****                         } else {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            else
 549:tmk_core/common/action.c ****                     if (event.pressed) {
 550:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 551:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 552:tmk_core/common/action.c ****                     } else {
 553:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 554:tmk_core/common/action.c ****                         if (tap_count > 1) {
 555:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 556:tmk_core/common/action.c ****                         }
 557:tmk_core/common/action.c ****                     }
 558:tmk_core/common/action.c **** #            endif
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        endif
 561:tmk_core/common/action.c ****                 default:
 562:tmk_core/common/action.c ****                     /* tap key */
 563:tmk_core/common/action.c ****                     if (event.pressed) {
 564:tmk_core/common/action.c ****                         if (tap_count > 0) {
 565:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 566:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 567:tmk_core/common/action.c ****                         } else {
 568:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 569:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 570:tmk_core/common/action.c ****                         }
 571:tmk_core/common/action.c ****                     } else {
 572:tmk_core/common/action.c ****                         if (tap_count > 0) {
 573:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 574:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 575:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 576:tmk_core/common/action.c ****                             } else {
 577:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 578:tmk_core/common/action.c ****                             }
 579:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 580:tmk_core/common/action.c ****                         } else {
 581:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 582:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****             }
 587:tmk_core/common/action.c ****             break;
 588:tmk_core/common/action.c **** #    endif
 589:tmk_core/common/action.c **** #endif
 590:tmk_core/common/action.c ****             /* Extentions */
 591:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 592:tmk_core/common/action.c ****         case ACT_MACRO:
 593:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 594:tmk_core/common/action.c ****             break;
 595:tmk_core/common/action.c **** #endif
 596:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 597:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 598:tmk_core/common/action.c ****             switch (action.swap.code) {
 599:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 605:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 608:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c ****                 case OP_SH_ON:
 611:tmk_core/common/action.c ****                     if (!event.pressed) {
 612:tmk_core/common/action.c ****                         swap_hands = true;
 613:tmk_core/common/action.c ****                     }
 614:tmk_core/common/action.c ****                     break;
 615:tmk_core/common/action.c ****                 case OP_SH_OFF:
 616:tmk_core/common/action.c ****                     if (!event.pressed) {
 617:tmk_core/common/action.c ****                         swap_hands = false;
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 621:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 622:tmk_core/common/action.c ****                     if (event.pressed) {
 623:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****                     break;
 628:tmk_core/common/action.c **** #    endif
 629:tmk_core/common/action.c **** 
 630:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 631:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 632:tmk_core/common/action.c ****                     /* tap toggle */
 633:tmk_core/common/action.c **** 
 634:tmk_core/common/action.c ****                     if (event.pressed) {
 635:tmk_core/common/action.c ****                         if (swap_held) {
 636:tmk_core/common/action.c ****                             swap_held = false;
 637:tmk_core/common/action.c ****                         } else {
 638:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                     } else {
 641:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 642:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 643:tmk_core/common/action.c ****                         }
 644:tmk_core/common/action.c ****                     }
 645:tmk_core/common/action.c ****                     break;
 646:tmk_core/common/action.c ****                 default:
 647:tmk_core/common/action.c ****                     /* tap key */
 648:tmk_core/common/action.c ****                     if (tap_count > 0) {
 649:tmk_core/common/action.c ****                         if (swap_held) {
 650:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 651:tmk_core/common/action.c ****                             swap_held  = false;
 652:tmk_core/common/action.c ****                         }
 653:tmk_core/common/action.c ****                         if (event.pressed) {
 654:tmk_core/common/action.c ****                             register_code(action.swap.code);
 655:tmk_core/common/action.c ****                         } else {
 656:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 657:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 658:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 659:tmk_core/common/action.c ****                         }
 660:tmk_core/common/action.c ****                     } else {
 661:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 662:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 663:tmk_core/common/action.c ****                             swap_held  = false;
 664:tmk_core/common/action.c ****                         }
 665:tmk_core/common/action.c ****                     }
 666:tmk_core/common/action.c **** #    endif
 667:tmk_core/common/action.c ****             }
 668:tmk_core/common/action.c **** #endif
 669:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 670:tmk_core/common/action.c ****         case ACT_FUNCTION:
 671:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 672:tmk_core/common/action.c ****             break;
 673:tmk_core/common/action.c **** #endif
 674:tmk_core/common/action.c ****         default:
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****     }
 677:tmk_core/common/action.c **** 
 678:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 679:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 680:tmk_core/common/action.c ****     switch (action.kind.id) {
 681:tmk_core/common/action.c ****         case ACT_LAYER:
 682:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 683:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 684:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 685:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 686:tmk_core/common/action.c **** #    endif
 687:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 688:tmk_core/common/action.c ****             break;
 689:tmk_core/common/action.c ****         default:
 690:tmk_core/common/action.c ****             break;
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #endif
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 695:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 696:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 697:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 698:tmk_core/common/action.c ****     } else {
 699:tmk_core/common/action.c ****         if (event.pressed) {
 700:tmk_core/common/action.c ****             if (tap_count > 0) {
 701:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 702:tmk_core/common/action.c ****             } else {
 703:tmk_core/common/action.c ****             }
 704:tmk_core/common/action.c ****         } else {
 705:tmk_core/common/action.c ****             if (tap_count > 0) {
 706:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 707:tmk_core/common/action.c ****             } else {
 708:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 709:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 710:tmk_core/common/action.c ****                 }
 711:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 712:tmk_core/common/action.c ****             }
 713:tmk_core/common/action.c ****         }
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #    endif
 716:tmk_core/common/action.c **** #endif
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 719:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 721:tmk_core/common/action.c ****         use_oneshot_swaphands();
 722:tmk_core/common/action.c ****     }
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c **** #endif
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 727:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 728:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 729:tmk_core/common/action.c ****      */
 730:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 731:tmk_core/common/action.c ****         record->event.pressed = false;
 732:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733:tmk_core/common/action.c ****         process_record(record);
 734:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c **** }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 740:tmk_core/common/action.c ****  *
 741:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 742:tmk_core/common/action.c ****  */
 743:tmk_core/common/action.c **** void register_code(uint8_t code) {
 151              		.loc 1 743 34 is_stmt 1 view -0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 744:tmk_core/common/action.c ****     if (code == KC_NO) {
 155              		.loc 1 744 5 view .LVU24
 743:tmk_core/common/action.c ****     if (code == KC_NO) {
 156              		.loc 1 743 34 is_stmt 0 view .LVU25
 157 0000 10B5     		push	{r4, lr}
 158              		.cfi_def_cfa_offset 8
 159              		.cfi_offset 4, -8
 160              		.cfi_offset 14, -4
 161              		.loc 1 744 8 view .LVU26
 162 0002 0446     		mov	r4, r0
 163 0004 0028     		cmp	r0, #0
 164 0006 39D0     		beq	.L5
 745:tmk_core/common/action.c ****         return;
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 748:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 749:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 750:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 751:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 752:tmk_core/common/action.c **** #    endif
 753:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 754:tmk_core/common/action.c ****         send_keyboard_report();
 755:tmk_core/common/action.c ****         wait_ms(100);
 756:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 757:tmk_core/common/action.c ****         send_keyboard_report();
 758:tmk_core/common/action.c ****     }
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 761:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 762:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 765:tmk_core/common/action.c ****         send_keyboard_report();
 766:tmk_core/common/action.c ****         wait_ms(100);
 767:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 768:tmk_core/common/action.c ****         send_keyboard_report();
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c **** 
 771:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 772:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 773:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 774:tmk_core/common/action.c **** #    endif
 775:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 776:tmk_core/common/action.c ****         send_keyboard_report();
 777:tmk_core/common/action.c ****         wait_ms(100);
 778:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 779:tmk_core/common/action.c ****         send_keyboard_report();
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c **** 
 783:tmk_core/common/action.c ****     else if
 165              		.loc 1 783 10 is_stmt 1 view .LVU27
 784:tmk_core/common/action.c ****         IS_KEY(code) {
 166              		.loc 1 784 9 is_stmt 0 view .LVU28
 167 0008 031F     		subs	r3, r0, #4
 168 000a DBB2     		uxtb	r3, r3
 169 000c A02B     		cmp	r3, #160
 170 000e 11D8     		bhi	.L7
 785:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 786:tmk_core/common/action.c ****             if (command_proc(code)) return;
 171              		.loc 1 786 13 is_stmt 1 view .LVU29
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 789:tmk_core/common/action.c **** /* TODO: remove
 790:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 791:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 792:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 793:tmk_core/common/action.c **** 
 794:tmk_core/common/action.c ****             add_key(code);
 795:tmk_core/common/action.c ****             send_keyboard_report();
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c ****             set_mods(tmp_mods);
 798:tmk_core/common/action.c ****             send_keyboard_report();
 799:tmk_core/common/action.c ****             oneshot_cancel();
 800:tmk_core/common/action.c ****         } else
 801:tmk_core/common/action.c **** */
 802:tmk_core/common/action.c **** #endif
 803:tmk_core/common/action.c ****             {
 804:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 805:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 806:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 807:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 172              		.loc 1 807 17 view .LVU30
 173              		.loc 1 807 21 is_stmt 0 view .LVU31
 174 0010 1B4B     		ldr	r3, .L18
 175 0012 0146     		mov	r1, r0
 176 0014 1868     		ldr	r0, [r3]
 177              	.LVL10:
 178              		.loc 1 807 21 view .LVU32
 179 0016 FFF7FEFF 		bl	is_key_pressed
 180              	.LVL11:
 181              		.loc 1 807 20 view .LVU33
 182 001a 20B1     		cbz	r0, .L8
 808:tmk_core/common/action.c ****                     del_key(code);
 183              		.loc 1 808 21 is_stmt 1 view .LVU34
 184 001c 2046     		mov	r0, r4
 185 001e FFF7FEFF 		bl	del_key
 186              	.LVL12:
 809:tmk_core/common/action.c ****                     send_keyboard_report();
 187              		.loc 1 809 21 view .LVU35
 188 0022 FFF7FEFF 		bl	send_keyboard_report
 189              	.LVL13:
 190              	.L8:
 810:tmk_core/common/action.c ****                 }
 811:tmk_core/common/action.c ****                 add_key(code);
 191              		.loc 1 811 17 view .LVU36
 192 0026 2046     		mov	r0, r4
 193 0028 FFF7FEFF 		bl	add_key
 194              	.LVL14:
 812:tmk_core/common/action.c ****                 send_keyboard_report();
 195              		.loc 1 812 17 view .LVU37
 196              	.L17:
 813:tmk_core/common/action.c ****             }
 814:tmk_core/common/action.c ****         }
 815:tmk_core/common/action.c ****     else if
 816:tmk_core/common/action.c ****         IS_MOD(code) {
 817:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 818:tmk_core/common/action.c ****             send_keyboard_report();
 197              		.loc 1 818 13 view .LVU38
 819:tmk_core/common/action.c ****         }
 820:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 821:tmk_core/common/action.c ****     else if
 822:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 825:tmk_core/common/action.c **** #endif
 826:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 827:tmk_core/common/action.c ****     else if
 828:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 829:tmk_core/common/action.c ****             mousekey_on(code);
 830:tmk_core/common/action.c ****             mousekey_send();
 831:tmk_core/common/action.c ****         }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** }
 198              		.loc 1 833 1 is_stmt 0 view .LVU39
 199 002c BDE81040 		pop	{r4, lr}
 200              		.cfi_remember_state
 201              		.cfi_restore 14
 202              		.cfi_restore 4
 203              		.cfi_def_cfa_offset 0
 818:tmk_core/common/action.c ****         }
 204              		.loc 1 818 13 view .LVU40
 205 0030 FFF7FEBF 		b	send_keyboard_report
 206              	.LVL15:
 207              	.L7:
 208              		.cfi_restore_state
 815:tmk_core/common/action.c ****         IS_MOD(code) {
 209              		.loc 1 815 10 is_stmt 1 view .LVU41
 816:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 210              		.loc 1 816 9 is_stmt 0 view .LVU42
 211 0034 00F12003 		add	r3, r0, #32
 212 0038 DBB2     		uxtb	r3, r3
 213 003a 072B     		cmp	r3, #7
 214 003c 07D8     		bhi	.L9
 817:tmk_core/common/action.c ****             send_keyboard_report();
 215              		.loc 1 817 13 is_stmt 1 view .LVU43
 817:tmk_core/common/action.c ****             send_keyboard_report();
 216              		.loc 1 817 22 is_stmt 0 view .LVU44
 217 003e 00F00704 		and	r4, r0, #7
 218 0042 0120     		movs	r0, #1
 219              	.LVL16:
 817:tmk_core/common/action.c ****             send_keyboard_report();
 220              		.loc 1 817 22 view .LVU45
 221 0044 A040     		lsls	r0, r0, r4
 817:tmk_core/common/action.c ****             send_keyboard_report();
 222              		.loc 1 817 13 view .LVU46
 223 0046 C0B2     		uxtb	r0, r0
 224 0048 FFF7FEFF 		bl	add_mods
 225              	.LVL17:
 226 004c EEE7     		b	.L17
 227              	.LVL18:
 228              	.L9:
 821:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 229              		.loc 1 821 10 is_stmt 1 view .LVU47
 822:tmk_core/common/action.c ****     else if
 230              		.loc 1 822 9 is_stmt 0 view .LVU48
 231 004e 00F15B03 		add	r3, r0, #91
 232 0052 DBB2     		uxtb	r3, r3
 233 0054 022B     		cmp	r3, #2
 234 0056 05D8     		bhi	.L10
 822:tmk_core/common/action.c ****     else if
 235              		.loc 1 822 27 is_stmt 1 view .LVU49
 236              	.LVL19:
 237              	.LBB10:
 238              	.LBI10:
 239              		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO
  33:tmk_core/common/report.h **** };
  34:tmk_core/common/report.h **** 
  35:tmk_core/common/report.h **** /* Mouse buttons */
  36:tmk_core/common/report.h **** enum mouse_buttons {
  37:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  38:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  39:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  40:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  41:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  42:tmk_core/common/report.h **** };
  43:tmk_core/common/report.h **** 
  44:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  45:tmk_core/common/report.h ****  *
  46:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  47:tmk_core/common/report.h ****  */
  48:tmk_core/common/report.h **** enum consumer_usages {
  49:tmk_core/common/report.h ****     // 15.5 Display Controls (https://www.usb.org/sites/default/files/hutrr41_0.pdf)
  50:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F,
  51:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  52:tmk_core/common/report.h ****     // 15.7 Transport Controls
  53:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  54:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  55:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  56:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  57:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  58:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  59:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  61:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  62:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  63:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  64:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  65:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  66:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  67:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  68:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  69:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  70:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  71:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  72:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  73:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  74:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  75:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  76:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  77:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  78:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  79:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  80:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  81:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  82:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  83:tmk_core/common/report.h **** };
  84:tmk_core/common/report.h **** 
  85:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  86:tmk_core/common/report.h ****  *
  87:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  88:tmk_core/common/report.h ****  */
  89:tmk_core/common/report.h **** enum desktop_usages {
  90:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  91:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  92:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  93:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  94:tmk_core/common/report.h **** };
  95:tmk_core/common/report.h **** 
  96:tmk_core/common/report.h **** // clang-format on
  97:tmk_core/common/report.h **** 
  98:tmk_core/common/report.h **** #define NKRO_SHARED_EP
  99:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 100:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 101:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 102:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 103:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 104:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 105:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 106:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 107:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 108:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 109:tmk_core/common/report.h **** #    else
 110:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 111:tmk_core/common/report.h **** #    endif
 112:tmk_core/common/report.h **** #endif
 113:tmk_core/common/report.h **** 
 114:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 115:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 116:tmk_core/common/report.h **** #else
 117:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 118:tmk_core/common/report.h **** #endif
 119:tmk_core/common/report.h **** 
 120:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 123:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 124:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 125:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 126:tmk_core/common/report.h **** #endif
 127:tmk_core/common/report.h **** 
 128:tmk_core/common/report.h **** #ifdef __cplusplus
 129:tmk_core/common/report.h **** extern "C" {
 130:tmk_core/common/report.h **** #endif
 131:tmk_core/common/report.h **** 
 132:tmk_core/common/report.h **** /*
 133:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 134:tmk_core/common/report.h ****  *
 135:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 136:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 137:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 140:tmk_core/common/report.h ****  *
 141:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 142:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 143:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 146:tmk_core/common/report.h ****  *
 147:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 148:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 149:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 150:tmk_core/common/report.h ****  *
 151:tmk_core/common/report.h ****  */
 152:tmk_core/common/report.h **** typedef union {
 153:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 154:tmk_core/common/report.h ****     struct {
 155:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 156:tmk_core/common/report.h ****         uint8_t report_id;
 157:tmk_core/common/report.h **** #endif
 158:tmk_core/common/report.h ****         uint8_t mods;
 159:tmk_core/common/report.h ****         uint8_t reserved;
 160:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 161:tmk_core/common/report.h ****     };
 162:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 163:tmk_core/common/report.h ****     struct nkro_report {
 164:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 165:tmk_core/common/report.h ****         uint8_t report_id;
 166:tmk_core/common/report.h **** #    endif
 167:tmk_core/common/report.h ****         uint8_t mods;
 168:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 169:tmk_core/common/report.h ****     } nkro;
 170:tmk_core/common/report.h **** #endif
 171:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 172:tmk_core/common/report.h **** 
 173:tmk_core/common/report.h **** typedef struct {
 174:tmk_core/common/report.h ****     uint8_t  report_id;
 175:tmk_core/common/report.h ****     uint16_t usage;
 176:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 177:tmk_core/common/report.h **** 
 178:tmk_core/common/report.h **** typedef struct {
 179:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 180:tmk_core/common/report.h ****     uint8_t report_id;
 181:tmk_core/common/report.h **** #endif
 182:tmk_core/common/report.h ****     uint8_t buttons;
 183:tmk_core/common/report.h ****     int8_t  x;
 184:tmk_core/common/report.h ****     int8_t  y;
 185:tmk_core/common/report.h ****     int8_t  v;
 186:tmk_core/common/report.h ****     int8_t  h;
 187:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 188:tmk_core/common/report.h **** 
 189:tmk_core/common/report.h **** /* keycode to system usage */
 190:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 240              		.loc 3 190 24 view .LVU50
 241              	.LBE10:
 191:tmk_core/common/report.h ****     switch (key) {
 242              		.loc 3 191 5 view .LVU51
 822:tmk_core/common/action.c ****     else if
 243              		.loc 1 822 27 is_stmt 0 view .LVU52
 244 0058 0A4A     		ldr	r2, .L18+4
 245              		.loc 1 833 1 view .LVU53
 246 005a BDE81040 		pop	{r4, lr}
 247              		.cfi_remember_state
 248              		.cfi_restore 14
 249              		.cfi_restore 4
 250              		.cfi_def_cfa_offset 0
 822:tmk_core/common/action.c ****     else if
 251              		.loc 1 822 27 view .LVU54
 252 005e D05C     		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 253              	.LVL20:
 822:tmk_core/common/action.c ****     else if
 254              		.loc 1 822 27 view .LVU55
 255 0060 FFF7FEBF 		b	host_system_send
 256              	.LVL21:
 257              	.L10:
 258              		.cfi_restore_state
 823:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 259              		.loc 1 823 10 is_stmt 1 view .LVU56
 824:tmk_core/common/action.c **** #endif
 260              		.loc 1 824 9 is_stmt 0 view .LVU57
 261 0064 5834     		adds	r4, r4, #88
 262 0066 E4B2     		uxtb	r4, r4
 263 0068 162C     		cmp	r4, #22
 264 006a 07D8     		bhi	.L5
 824:tmk_core/common/action.c **** #endif
 265              		.loc 1 824 29 is_stmt 1 view .LVU58
 266              	.LVL22:
 267              	.LBB11:
 268              	.LBI11:
 192:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 193:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 194:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 195:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 196:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 197:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 198:tmk_core/common/report.h ****         default:
 199:tmk_core/common/report.h ****             return 0;
 200:tmk_core/common/report.h ****     }
 201:tmk_core/common/report.h **** }
 202:tmk_core/common/report.h **** 
 203:tmk_core/common/report.h **** /* keycode to consumer usage */
 204:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 269              		.loc 3 204 24 view .LVU59
 270              	.LBE11:
 205:tmk_core/common/report.h ****     switch (key) {
 271              		.loc 3 205 5 view .LVU60
 824:tmk_core/common/action.c **** #endif
 272              		.loc 1 824 29 is_stmt 0 view .LVU61
 273 006c 054B     		ldr	r3, .L18+4
 274 006e 03EB4404 		add	r4, r3, r4, lsl #1
 275 0072 A088     		ldrh	r0, [r4, #4]
 276              	.LVL23:
 277              		.loc 1 833 1 view .LVU62
 278 0074 BDE81040 		pop	{r4, lr}
 279              		.cfi_remember_state
 280              		.cfi_restore 14
 281              		.cfi_restore 4
 282              		.cfi_def_cfa_offset 0
 824:tmk_core/common/action.c **** #endif
 283              		.loc 1 824 29 view .LVU63
 284 0078 FFF7FEBF 		b	host_consumer_send
 285              	.LVL24:
 286              	.L5:
 287              		.cfi_restore_state
 288              		.loc 1 833 1 view .LVU64
 289 007c 10BD     		pop	{r4, pc}
 290              	.L19:
 291 007e 00BF     		.align	2
 292              	.L18:
 293 0080 00000000 		.word	keyboard_report
 294 0084 00000000 		.word	.LANCHOR0
 295              		.cfi_endproc
 296              	.LFE16:
 298              		.section	.text.unregister_code,"ax",%progbits
 299              		.align	1
 300              		.global	unregister_code
 301              		.syntax unified
 302              		.thumb
 303              		.thumb_func
 304              		.fpu fpv4-sp-d16
 306              	unregister_code:
 307              	.LVL25:
 308              	.LFB17:
 834:tmk_core/common/action.c **** 
 835:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 836:tmk_core/common/action.c ****  *
 837:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 838:tmk_core/common/action.c ****  */
 839:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 309              		.loc 1 839 36 is_stmt 1 view -0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 0
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 840:tmk_core/common/action.c ****     if (code == KC_NO) {
 313              		.loc 1 840 5 view .LVU66
 839:tmk_core/common/action.c ****     if (code == KC_NO) {
 314              		.loc 1 839 36 is_stmt 0 view .LVU67
 315 0000 08B5     		push	{r3, lr}
 316              		.cfi_def_cfa_offset 8
 317              		.cfi_offset 3, -8
 318              		.cfi_offset 14, -4
 319              		.loc 1 840 8 view .LVU68
 320 0002 0346     		mov	r3, r0
 321 0004 48B3     		cbz	r0, .L20
 841:tmk_core/common/action.c ****         return;
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 844:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 846:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** 
 865:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 866:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 867:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 868:tmk_core/common/action.c **** #    endif
 869:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 870:tmk_core/common/action.c ****         send_keyboard_report();
 871:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 872:tmk_core/common/action.c ****         send_keyboard_report();
 873:tmk_core/common/action.c ****     }
 874:tmk_core/common/action.c **** #endif
 875:tmk_core/common/action.c **** 
 876:tmk_core/common/action.c ****     else if
 322              		.loc 1 876 10 is_stmt 1 view .LVU69
 877:tmk_core/common/action.c ****         IS_KEY(code) {
 323              		.loc 1 877 9 is_stmt 0 view .LVU70
 324 0006 021F     		subs	r2, r0, #4
 325 0008 D2B2     		uxtb	r2, r2
 326 000a A02A     		cmp	r2, #160
 327 000c 05D8     		bhi	.L22
 878:tmk_core/common/action.c ****             del_key(code);
 328              		.loc 1 878 13 is_stmt 1 view .LVU71
 329 000e FFF7FEFF 		bl	del_key
 330              	.LVL26:
 879:tmk_core/common/action.c ****             send_keyboard_report();
 331              		.loc 1 879 13 view .LVU72
 332              	.L28:
 880:tmk_core/common/action.c ****         }
 881:tmk_core/common/action.c ****     else if
 882:tmk_core/common/action.c ****         IS_MOD(code) {
 883:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 884:tmk_core/common/action.c ****             send_keyboard_report();
 333              		.loc 1 884 13 view .LVU73
 885:tmk_core/common/action.c ****         }
 886:tmk_core/common/action.c ****     else if
 887:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 888:tmk_core/common/action.c ****     else if
 889:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 890:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 891:tmk_core/common/action.c ****     else if
 892:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 893:tmk_core/common/action.c ****             mousekey_off(code);
 894:tmk_core/common/action.c ****             mousekey_send();
 895:tmk_core/common/action.c ****         }
 896:tmk_core/common/action.c **** #endif
 897:tmk_core/common/action.c **** }
 334              		.loc 1 897 1 is_stmt 0 view .LVU74
 335 0012 BDE80840 		pop	{r3, lr}
 336              		.cfi_remember_state
 337              		.cfi_restore 14
 338              		.cfi_restore 3
 339              		.cfi_def_cfa_offset 0
 884:tmk_core/common/action.c ****         }
 340              		.loc 1 884 13 view .LVU75
 341 0016 FFF7FEBF 		b	send_keyboard_report
 342              	.LVL27:
 343              	.L22:
 344              		.cfi_restore_state
 881:tmk_core/common/action.c ****         IS_MOD(code) {
 345              		.loc 1 881 10 is_stmt 1 view .LVU76
 882:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 346              		.loc 1 882 9 is_stmt 0 view .LVU77
 347 001a 00F12002 		add	r2, r0, #32
 348 001e D2B2     		uxtb	r2, r2
 349 0020 072A     		cmp	r2, #7
 350 0022 07D8     		bhi	.L23
 883:tmk_core/common/action.c ****             send_keyboard_report();
 351              		.loc 1 883 13 is_stmt 1 view .LVU78
 883:tmk_core/common/action.c ****             send_keyboard_report();
 352              		.loc 1 883 22 is_stmt 0 view .LVU79
 353 0024 00F00703 		and	r3, r0, #7
 354 0028 0120     		movs	r0, #1
 355              	.LVL28:
 883:tmk_core/common/action.c ****             send_keyboard_report();
 356              		.loc 1 883 22 view .LVU80
 357 002a 9840     		lsls	r0, r0, r3
 883:tmk_core/common/action.c ****             send_keyboard_report();
 358              		.loc 1 883 13 view .LVU81
 359 002c C0B2     		uxtb	r0, r0
 360 002e FFF7FEFF 		bl	del_mods
 361              	.LVL29:
 362 0032 EEE7     		b	.L28
 363              	.LVL30:
 364              	.L23:
 886:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 365              		.loc 1 886 10 is_stmt 1 view .LVU82
 887:tmk_core/common/action.c ****     else if
 366              		.loc 1 887 9 is_stmt 0 view .LVU83
 367 0034 00F15B02 		add	r2, r0, #91
 368 0038 D2B2     		uxtb	r2, r2
 369 003a 022A     		cmp	r2, #2
 370 003c 04D8     		bhi	.L24
 887:tmk_core/common/action.c ****     else if
 371              		.loc 1 887 27 is_stmt 1 discriminator 1 view .LVU84
 372 003e 0020     		movs	r0, #0
 373              	.LVL31:
 374              		.loc 1 897 1 is_stmt 0 discriminator 1 view .LVU85
 375 0040 BDE80840 		pop	{r3, lr}
 376              		.cfi_remember_state
 377              		.cfi_restore 14
 378              		.cfi_restore 3
 379              		.cfi_def_cfa_offset 0
 887:tmk_core/common/action.c ****     else if
 380              		.loc 1 887 27 discriminator 1 view .LVU86
 381 0044 FFF7FEBF 		b	host_system_send
 382              	.LVL32:
 383              	.L24:
 384              		.cfi_restore_state
 888:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 385              		.loc 1 888 10 is_stmt 1 view .LVU87
 889:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 386              		.loc 1 889 9 is_stmt 0 view .LVU88
 387 0048 5833     		adds	r3, r3, #88
 388 004a DBB2     		uxtb	r3, r3
 389 004c 162B     		cmp	r3, #22
 390 004e 04D8     		bhi	.L20
 889:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 391              		.loc 1 889 29 is_stmt 1 discriminator 1 view .LVU89
 392 0050 0020     		movs	r0, #0
 393              	.LVL33:
 394              		.loc 1 897 1 is_stmt 0 discriminator 1 view .LVU90
 395 0052 BDE80840 		pop	{r3, lr}
 396              		.cfi_remember_state
 397              		.cfi_restore 14
 398              		.cfi_restore 3
 399              		.cfi_def_cfa_offset 0
 889:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 400              		.loc 1 889 29 discriminator 1 view .LVU91
 401 0056 FFF7FEBF 		b	host_consumer_send
 402              	.LVL34:
 403              	.L20:
 404              		.cfi_restore_state
 405              		.loc 1 897 1 view .LVU92
 406 005a 08BD     		pop	{r3, pc}
 407              		.cfi_endproc
 408              	.LFE17:
 410              		.section	.text.tap_code,"ax",%progbits
 411              		.align	1
 412              		.global	tap_code
 413              		.syntax unified
 414              		.thumb
 415              		.thumb_func
 416              		.fpu fpv4-sp-d16
 418              	tap_code:
 419              	.LVL35:
 420              	.LFB18:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 421              		.loc 1 903 29 is_stmt 1 view -0
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 0
 424              		@ frame_needed = 0, uses_anonymous_args = 0
 904:tmk_core/common/action.c ****     register_code(code);
 425              		.loc 1 904 5 view .LVU94
 903:tmk_core/common/action.c ****     register_code(code);
 426              		.loc 1 903 29 is_stmt 0 view .LVU95
 427 0000 10B5     		push	{r4, lr}
 428              		.cfi_def_cfa_offset 8
 429              		.cfi_offset 4, -8
 430              		.cfi_offset 14, -4
 903:tmk_core/common/action.c ****     register_code(code);
 431              		.loc 1 903 29 view .LVU96
 432 0002 0446     		mov	r4, r0
 433              		.loc 1 904 5 view .LVU97
 434 0004 FFF7FEFF 		bl	register_code
 435              	.LVL36:
 905:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 436              		.loc 1 905 5 is_stmt 1 view .LVU98
 437              		.loc 1 905 8 is_stmt 0 view .LVU99
 438 0008 392C     		cmp	r4, #57
 906:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 439              		.loc 1 906 9 is_stmt 1 view .LVU100
 440 000a 0CBF     		ite	eq
 441 000c 5020     		moveq	r0, #80
 907:tmk_core/common/action.c ****     } else {
 908:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 442              		.loc 1 908 9 view .LVU101
 443 000e 0020     		movne	r0, #0
 444 0010 0021     		movs	r1, #0
 445 0012 FFF7FEFF 		bl	CLK_delay_ms
 446              	.LVL37:
 909:tmk_core/common/action.c ****     }
 910:tmk_core/common/action.c ****     unregister_code(code);
 447              		.loc 1 910 5 view .LVU102
 448 0016 2046     		mov	r0, r4
 911:tmk_core/common/action.c **** }
 449              		.loc 1 911 1 is_stmt 0 view .LVU103
 450 0018 BDE81040 		pop	{r4, lr}
 451              		.cfi_restore 14
 452              		.cfi_restore 4
 453              		.cfi_def_cfa_offset 0
 910:tmk_core/common/action.c **** }
 454              		.loc 1 910 5 view .LVU104
 455 001c FFF7FEBF 		b	unregister_code
 456              	.LVL38:
 457              		.cfi_endproc
 458              	.LFE18:
 460              		.section	.text.register_mods,"ax",%progbits
 461              		.align	1
 462              		.global	register_mods
 463              		.syntax unified
 464              		.thumb
 465              		.thumb_func
 466              		.fpu fpv4-sp-d16
 468              	register_mods:
 469              	.LVL39:
 470              	.LFB19:
 912:tmk_core/common/action.c **** 
 913:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:tmk_core/common/action.c ****  *
 915:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 916:tmk_core/common/action.c ****  */
 917:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 471              		.loc 1 917 34 is_stmt 1 view -0
 472              		.cfi_startproc
 473              		@ args = 0, pretend = 0, frame = 0
 474              		@ frame_needed = 0, uses_anonymous_args = 0
 918:tmk_core/common/action.c ****     if (mods) {
 475              		.loc 1 918 5 view .LVU106
 917:tmk_core/common/action.c ****     if (mods) {
 476              		.loc 1 917 34 is_stmt 0 view .LVU107
 477 0000 08B5     		push	{r3, lr}
 478              		.cfi_def_cfa_offset 8
 479              		.cfi_offset 3, -8
 480              		.cfi_offset 14, -4
 481              		.loc 1 918 8 view .LVU108
 482 0002 28B1     		cbz	r0, .L33
 919:tmk_core/common/action.c ****         add_mods(mods);
 483              		.loc 1 919 9 is_stmt 1 view .LVU109
 484 0004 FFF7FEFF 		bl	add_mods
 485              	.LVL40:
 920:tmk_core/common/action.c ****         send_keyboard_report();
 486              		.loc 1 920 9 view .LVU110
 921:tmk_core/common/action.c ****     }
 922:tmk_core/common/action.c **** }
 487              		.loc 1 922 1 is_stmt 0 view .LVU111
 488 0008 BDE80840 		pop	{r3, lr}
 489              		.cfi_remember_state
 490              		.cfi_restore 14
 491              		.cfi_restore 3
 492              		.cfi_def_cfa_offset 0
 920:tmk_core/common/action.c ****         send_keyboard_report();
 493              		.loc 1 920 9 view .LVU112
 494 000c FFF7FEBF 		b	send_keyboard_report
 495              	.LVL41:
 496              	.L33:
 497              		.cfi_restore_state
 498              		.loc 1 922 1 view .LVU113
 499 0010 08BD     		pop	{r3, pc}
 500              		.cfi_endproc
 501              	.LFE19:
 503              		.section	.text.unregister_mods,"ax",%progbits
 504              		.align	1
 505              		.global	unregister_mods
 506              		.syntax unified
 507              		.thumb
 508              		.thumb_func
 509              		.fpu fpv4-sp-d16
 511              	unregister_mods:
 512              	.LVL42:
 513              	.LFB20:
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 514              		.loc 1 928 36 is_stmt 1 view -0
 515              		.cfi_startproc
 516              		@ args = 0, pretend = 0, frame = 0
 517              		@ frame_needed = 0, uses_anonymous_args = 0
 929:tmk_core/common/action.c ****     if (mods) {
 518              		.loc 1 929 5 view .LVU115
 928:tmk_core/common/action.c ****     if (mods) {
 519              		.loc 1 928 36 is_stmt 0 view .LVU116
 520 0000 08B5     		push	{r3, lr}
 521              		.cfi_def_cfa_offset 8
 522              		.cfi_offset 3, -8
 523              		.cfi_offset 14, -4
 524              		.loc 1 929 8 view .LVU117
 525 0002 28B1     		cbz	r0, .L35
 930:tmk_core/common/action.c ****         del_mods(mods);
 526              		.loc 1 930 9 is_stmt 1 view .LVU118
 527 0004 FFF7FEFF 		bl	del_mods
 528              	.LVL43:
 931:tmk_core/common/action.c ****         send_keyboard_report();
 529              		.loc 1 931 9 view .LVU119
 932:tmk_core/common/action.c ****     }
 933:tmk_core/common/action.c **** }
 530              		.loc 1 933 1 is_stmt 0 view .LVU120
 531 0008 BDE80840 		pop	{r3, lr}
 532              		.cfi_remember_state
 533              		.cfi_restore 14
 534              		.cfi_restore 3
 535              		.cfi_def_cfa_offset 0
 931:tmk_core/common/action.c ****         send_keyboard_report();
 536              		.loc 1 931 9 view .LVU121
 537 000c FFF7FEBF 		b	send_keyboard_report
 538              	.LVL44:
 539              	.L35:
 540              		.cfi_restore_state
 541              		.loc 1 933 1 view .LVU122
 542 0010 08BD     		pop	{r3, pc}
 543              		.cfi_endproc
 544              	.LFE20:
 546              		.section	.text.process_action,"ax",%progbits
 547              		.align	1
 548              		.global	process_action
 549              		.syntax unified
 550              		.thumb
 551              		.thumb_func
 552              		.fpu fpv4-sp-d16
 554              	process_action:
 555              	.LVL45:
 556              	.LFB15:
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 557              		.loc 1 227 59 is_stmt 1 view -0
 558              		.cfi_startproc
 559              		@ args = 0, pretend = 0, frame = 0
 560              		@ frame_needed = 0, uses_anonymous_args = 0
 228:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 561              		.loc 1 228 5 view .LVU124
 230:tmk_core/common/action.c **** #endif
 562              		.loc 1 230 5 view .LVU125
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 563              		.loc 1 227 59 is_stmt 0 view .LVU126
 564 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 565              		.cfi_def_cfa_offset 32
 566              		.cfi_offset 4, -32
 567              		.cfi_offset 5, -28
 568              		.cfi_offset 6, -24
 569              		.cfi_offset 7, -20
 570              		.cfi_offset 8, -16
 571              		.cfi_offset 9, -12
 572              		.cfi_offset 10, -8
 573              		.cfi_offset 14, -4
 230:tmk_core/common/action.c **** #endif
 574              		.loc 1 230 36 view .LVU127
 575 0004 90F80690 		ldrb	r9, [r0, #6]	@ zero_extendqisi2
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 576              		.loc 1 233 14 view .LVU128
 577 0008 8578     		ldrb	r5, [r0, #2]	@ zero_extendqisi2
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 578              		.loc 1 227 59 view .LVU129
 579 000a 0746     		mov	r7, r0
 580 000c 0C46     		mov	r4, r1	@ movhi
 230:tmk_core/common/action.c **** #endif
 581              		.loc 1 230 13 view .LVU130
 582 000e 4FEA1919 		lsr	r9, r9, #4
 583              	.LVL46:
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 584              		.loc 1 233 5 is_stmt 1 view .LVU131
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 585              		.loc 1 233 8 is_stmt 0 view .LVU132
 586 0012 0DB1     		cbz	r5, .L38
 235:tmk_core/common/action.c ****     }
 587              		.loc 1 235 9 is_stmt 1 view .LVU133
 588 0014 FFF7FEFF 		bl	clear_weak_mods
 589              	.LVL47:
 590              	.L38:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 591              		.loc 1 239 5 view .LVU134
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 592              		.loc 1 241 5 view .LVU135
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 593              		.loc 1 241 9 is_stmt 0 view .LVU136
 594 0018 FFF7FEFF 		bl	is_oneshot_layer_active
 595              	.LVL48:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 596              		.loc 1 241 8 view .LVU137
 597 001c 8046     		mov	r8, r0
 598 001e A0B1     		cbz	r0, .L39
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 599              		.loc 1 241 35 discriminator 1 view .LVU138
 600 0020 4DB3     		cbz	r5, .L116
 601              	.LVL49:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 602              		.loc 1 241 71 discriminator 2 view .LVU139
 603 0022 C4F30723 		ubfx	r3, r4, #8, #8
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 604              		.loc 1 241 52 discriminator 2 view .LVU140
 605 0026 03F0F003 		and	r3, r3, #240
 606 002a 402B     		cmp	r3, #64
 607 002c 04D0     		beq	.L40
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 608              		.loc 1 241 87 discriminator 3 view .LVU141
 609 002e 04F12003 		add	r3, r4, #32
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 610              		.loc 1 241 84 discriminator 3 view .LVU142
 611 0032 DBB2     		uxtb	r3, r3
 612 0034 072B     		cmp	r3, #7
 613 0036 1ED9     		bls	.L116
 614              	.L40:
 246:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 615              		.loc 1 246 9 is_stmt 1 view .LVU143
 616 0038 0220     		movs	r0, #2
 617 003a FFF7FEFF 		bl	clear_oneshot_layer_state
 618              	.LVL50:
 247:tmk_core/common/action.c ****     }
 619              		.loc 1 247 9 view .LVU144
 247:tmk_core/common/action.c ****     }
 620              		.loc 1 247 31 is_stmt 0 view .LVU145
 621 003e FFF7FEFF 		bl	is_oneshot_layer_active
 622              	.LVL51:
 247:tmk_core/common/action.c ****     }
 623              		.loc 1 247 9 view .LVU146
 624 0042 80F00100 		eor	r0, r0, #1
 625 0046 5FFA80F8 		uxtb	r8, r0
 626              	.LVL52:
 627              	.L39:
 251:tmk_core/common/action.c ****         /* Key and Mods */
 628              		.loc 1 251 5 is_stmt 1 view .LVU147
 629 004a C4F30333 		ubfx	r3, r4, #12, #4
 630 004e 0F2B     		cmp	r3, #15
 631 0050 45D8     		bhi	.L41
 632 0052 DFE813F0 		tbh	[pc, r3, lsl #1]
 633              	.L43:
 634 0056 1300     		.2byte	(.L50-.L43)/2
 635 0058 1300     		.2byte	(.L50-.L43)/2
 636 005a 6800     		.2byte	(.L49-.L43)/2
 637 005c 6800     		.2byte	(.L49-.L43)/2
 638 005e C100     		.2byte	(.L48-.L43)/2
 639 0060 4400     		.2byte	(.L41-.L43)/2
 640 0062 4400     		.2byte	(.L41-.L43)/2
 641 0064 4400     		.2byte	(.L41-.L43)/2
 642 0066 D700     		.2byte	(.L47-.L43)/2
 643 0068 2E01     		.2byte	(.L46-.L43)/2
 644 006a 3F01     		.2byte	(.L45-.L43)/2
 645 006c 3F01     		.2byte	(.L45-.L43)/2
 646 006e 9901     		.2byte	(.L44-.L43)/2
 647 0070 4400     		.2byte	(.L41-.L43)/2
 648 0072 4400     		.2byte	(.L41-.L43)/2
 649 0074 A201     		.2byte	(.L42-.L43)/2
 650              	.LVL53:
 651              		.p2align 1
 652              	.L116:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 653              		.loc 1 239 10 is_stmt 0 view .LVU148
 654 0076 4FF00008 		mov	r8, #0
 655 007a E6E7     		b	.L39
 656              	.LVL54:
 657              	.L50:
 658              	.LBB12:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 659              		.loc 1 255 13 is_stmt 1 view .LVU149
 255:tmk_core/common/action.c ****             if (event.pressed) {
 660              		.loc 1 255 44 is_stmt 0 view .LVU150
 661 007c C4F30723 		ubfx	r3, r4, #8, #8
 662 0080 C4F30326 		ubfx	r6, r4, #8, #4
 255:tmk_core/common/action.c ****             if (event.pressed) {
 663              		.loc 1 255 21 view .LVU151
 664 0084 13F0F00F 		tst	r3, #240
 665 0088 18BF     		it	ne
 666 008a 3601     		lslne	r6, r6, #4
 667              	.LVL55:
 256:tmk_core/common/action.c ****                 if (mods) {
 668              		.loc 1 256 13 is_stmt 1 view .LVU152
 669 008c 5FFA84F9 		uxtb	r9, r4
 256:tmk_core/common/action.c ****                 if (mods) {
 670              		.loc 1 256 16 is_stmt 0 view .LVU153
 671 0090 A5B1     		cbz	r5, .L52
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 672              		.loc 1 257 17 is_stmt 1 view .LVU154
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 673              		.loc 1 257 20 is_stmt 0 view .LVU155
 674 0092 66B1     		cbz	r6, .L53
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 675              		.loc 1 258 21 is_stmt 1 view .LVU156
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 676              		.loc 1 258 25 is_stmt 0 view .LVU157
 677 0094 09F12003 		add	r3, r9, #32
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 678              		.loc 1 258 24 view .LVU158
 679 0098 DBB2     		uxtb	r3, r3
 680 009a 072B     		cmp	r3, #7
 262:tmk_core/common/action.c ****                     } else {
 681              		.loc 1 262 25 view .LVU159
 682 009c 3046     		mov	r0, r6
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 683              		.loc 1 258 24 view .LVU160
 684 009e 02D9     		bls	.L54
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 685              		.loc 1 258 49 discriminator 1 view .LVU161
 686 00a0 B9F1000F 		cmp	r9, #0
 687 00a4 07D1     		bne	.L55
 688              	.L54:
 262:tmk_core/common/action.c ****                     } else {
 689              		.loc 1 262 25 is_stmt 1 view .LVU162
 690 00a6 FFF7FEFF 		bl	add_mods
 691              	.LVL56:
 692              	.L56:
 266:tmk_core/common/action.c ****                 }
 693              		.loc 1 266 21 view .LVU163
 694 00aa FFF7FEFF 		bl	send_keyboard_report
 695              	.LVL57:
 696              	.L53:
 268:tmk_core/common/action.c ****             } else {
 697              		.loc 1 268 17 view .LVU164
 698 00ae 4846     		mov	r0, r9
 699              	.LVL58:
 700              	.L151:
 268:tmk_core/common/action.c ****             } else {
 701              		.loc 1 268 17 is_stmt 0 view .LVU165
 702              	.LBE12:
 703              	.LBB13:
 356:tmk_core/common/action.c ****                             }
 704              		.loc 1 356 33 view .LVU166
 705 00b0 FFF7FEFF 		bl	register_code
 706              	.LVL59:
 707 00b4 13E0     		b	.L41
 708              	.LVL60:
 709              	.L55:
 356:tmk_core/common/action.c ****                             }
 710              		.loc 1 356 33 view .LVU167
 711              	.LBE13:
 712              	.LBB14:
 264:tmk_core/common/action.c ****                     }
 713              		.loc 1 264 25 is_stmt 1 view .LVU168
 714 00b6 FFF7FEFF 		bl	add_weak_mods
 715              	.LVL61:
 716 00ba F6E7     		b	.L56
 717              	.L52:
 270:tmk_core/common/action.c ****                 if (mods) {
 718              		.loc 1 270 17 view .LVU169
 719 00bc 4846     		mov	r0, r9
 720 00be FFF7FEFF 		bl	unregister_code
 721              	.LVL62:
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 722              		.loc 1 271 17 view .LVU170
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 723              		.loc 1 271 20 is_stmt 0 view .LVU171
 724 00c2 66B1     		cbz	r6, .L41
 272:tmk_core/common/action.c ****                         del_mods(mods);
 725              		.loc 1 272 21 is_stmt 1 view .LVU172
 272:tmk_core/common/action.c ****                         del_mods(mods);
 726              		.loc 1 272 25 is_stmt 0 view .LVU173
 727 00c4 09F12003 		add	r3, r9, #32
 272:tmk_core/common/action.c ****                         del_mods(mods);
 728              		.loc 1 272 24 view .LVU174
 729 00c8 DBB2     		uxtb	r3, r3
 730 00ca 072B     		cmp	r3, #7
 273:tmk_core/common/action.c ****                     } else {
 731              		.loc 1 273 25 view .LVU175
 732 00cc 3046     		mov	r0, r6
 272:tmk_core/common/action.c ****                         del_mods(mods);
 733              		.loc 1 272 24 view .LVU176
 734 00ce 02D9     		bls	.L58
 272:tmk_core/common/action.c ****                         del_mods(mods);
 735              		.loc 1 272 49 discriminator 1 view .LVU177
 736 00d0 B9F1000F 		cmp	r9, #0
 737 00d4 24D1     		bne	.L59
 738              	.L58:
 273:tmk_core/common/action.c ****                     } else {
 739              		.loc 1 273 25 is_stmt 1 view .LVU178
 740 00d6 FFF7FEFF 		bl	del_mods
 741              	.LVL63:
 742              	.L60:
 277:tmk_core/common/action.c ****                 }
 743              		.loc 1 277 21 view .LVU179
 744 00da FFF7FEFF 		bl	send_keyboard_report
 745              	.LVL64:
 746              	.L41:
 277:tmk_core/common/action.c ****                 }
 747              		.loc 1 277 21 is_stmt 0 view .LVU180
 748              	.LBE14:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 749              		.loc 1 680 5 is_stmt 1 view .LVU181
 750 00de C4F30334 		ubfx	r4, r4, #12, #4
 751              	.LVL65:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 752              		.loc 1 680 5 is_stmt 0 view .LVU182
 753 00e2 083C     		subs	r4, r4, #8
 754 00e4 032C     		cmp	r4, #3
 755 00e6 03D8     		bhi	.L111
 687:tmk_core/common/action.c ****             break;
 756              		.loc 1 687 13 is_stmt 1 view .LVU183
 757 00e8 FFF7FEFF 		bl	host_keyboard_leds
 758              	.LVL66:
 759 00ec FFF7FEFF 		bl	led_set
 760              	.LVL67:
 688:tmk_core/common/action.c ****         default:
 761              		.loc 1 688 13 view .LVU184
 762              	.L111:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 763              		.loc 1 730 5 view .LVU185
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 764              		.loc 1 730 8 is_stmt 0 view .LVU186
 765 00f0 B8F1000F 		cmp	r8, #0
 766 00f4 00F05881 		beq	.L37
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 767              		.loc 1 730 33 discriminator 1 view .LVU187
 768 00f8 FFF7FEFF 		bl	get_oneshot_layer_state
 769              	.LVL68:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 770              		.loc 1 730 28 discriminator 1 view .LVU188
 771 00fc 10F00100 		ands	r0, r0, #1
 772 0100 40F05281 		bne	.L37
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 773              		.loc 1 731 9 is_stmt 1 view .LVU189
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 774              		.loc 1 731 31 is_stmt 0 view .LVU190
 775 0104 B870     		strb	r0, [r7, #2]
 732:tmk_core/common/action.c ****         process_record(record);
 776              		.loc 1 732 9 is_stmt 1 view .LVU191
 777 0106 FFF7FEFF 		bl	get_oneshot_layer
 778              	.LVL69:
 779 010a FFF7FEFF 		bl	layer_on
 780              	.LVL70:
 733:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 781              		.loc 1 733 9 view .LVU192
 782 010e 3846     		mov	r0, r7
 783 0110 FFF7FEFF 		bl	process_record
 784              	.LVL71:
 734:tmk_core/common/action.c ****     }
 785              		.loc 1 734 9 view .LVU193
 786 0114 FFF7FEFF 		bl	get_oneshot_layer
 787              	.LVL72:
 737:tmk_core/common/action.c **** 
 788              		.loc 1 737 1 is_stmt 0 view .LVU194
 789 0118 BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 790              		.cfi_remember_state
 791              		.cfi_restore 14
 792              		.cfi_restore 10
 793              		.cfi_restore 9
 794              		.cfi_restore 8
 795              		.cfi_restore 7
 796              		.cfi_restore 6
 797              		.cfi_restore 5
 798              		.cfi_restore 4
 799              		.cfi_def_cfa_offset 0
 800              	.LVL73:
 734:tmk_core/common/action.c ****     }
 801              		.loc 1 734 9 view .LVU195
 802 011c FFF7FEBF 		b	layer_off
 803              	.LVL74:
 804              	.L59:
 805              		.cfi_restore_state
 806              	.LBB15:
 275:tmk_core/common/action.c ****                     }
 807              		.loc 1 275 25 is_stmt 1 view .LVU196
 808 0120 FFF7FEFF 		bl	del_weak_mods
 809              	.LVL75:
 810 0124 D9E7     		b	.L60
 811              	.LVL76:
 812              	.L49:
 275:tmk_core/common/action.c ****                     }
 813              		.loc 1 275 25 is_stmt 0 view .LVU197
 814              	.LBE15:
 815              	.LBB16:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 816              		.loc 1 284 13 is_stmt 1 view .LVU198
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 817              		.loc 1 284 44 is_stmt 0 view .LVU199
 818 0126 C4F30723 		ubfx	r3, r4, #8, #8
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 819              		.loc 1 284 21 view .LVU200
 820 012a 03F0F003 		and	r3, r3, #240
 821 012e C4F30326 		ubfx	r6, r4, #8, #4
 822 0132 202B     		cmp	r3, #32
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 823              		.loc 1 285 37 view .LVU201
 824 0134 5FFA84FA 		uxtb	r10, r4
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 825              		.loc 1 284 21 view .LVU202
 826 0138 18BF     		it	ne
 827 013a 3601     		lslne	r6, r6, #4
 828              	.LVL77:
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 829              		.loc 1 285 13 is_stmt 1 view .LVU203
 830 013c BAF1000F 		cmp	r10, #0
 831 0140 0DD0     		beq	.L62
 832 0142 BAF1010F 		cmp	r10, #1
 833 0146 2CD0     		beq	.L63
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 834              		.loc 1 340 21 view .LVU204
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 835              		.loc 1 340 24 is_stmt 0 view .LVU205
 836 0148 BDB3     		cbz	r5, .L71
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 837              		.loc 1 341 25 is_stmt 1 view .LVU206
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 838              		.loc 1 341 28 is_stmt 0 view .LVU207
 839 014a B9F1000F 		cmp	r9, #0
 840 014e 2CD0     		beq	.L72
 343:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 841              		.loc 1 343 29 is_stmt 1 view .LVU208
 347:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 842              		.loc 1 347 33 is_stmt 0 view .LVU209
 843 0150 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 343:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 844              		.loc 1 343 32 view .LVU210
 845 0152 D907     		lsls	r1, r3, #31
 846 0154 2FD5     		bpl	.L73
 348:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 847              		.loc 1 348 76 is_stmt 1 view .LVU211
 350:tmk_core/common/action.c ****                                 register_mods(mods);
 848              		.loc 1 350 33 view .LVU212
 350:tmk_core/common/action.c ****                                 register_mods(mods);
 849              		.loc 1 350 51 is_stmt 0 view .LVU213
 850 0156 6FF30713 		bfc	r3, #4, #4
 851 015a BB71     		strb	r3, [r7, #6]
 351:tmk_core/common/action.c ****                             } else
 852              		.loc 1 351 33 is_stmt 1 view .LVU214
 853 015c 25E0     		b	.L72
 854              	.L62:
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 855              		.loc 1 289 21 view .LVU215
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 856              		.loc 1 289 24 is_stmt 0 view .LVU216
 857 015e 9DB1     		cbz	r5, .L65
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 858              		.loc 1 290 25 is_stmt 1 view .LVU217
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 859              		.loc 1 290 28 is_stmt 0 view .LVU218
 860 0160 B9F1000F 		cmp	r9, #0
 861 0164 06D1     		bne	.L66
 862              	.L67:
 304:tmk_core/common/action.c ****                         }
 863              		.loc 1 304 29 is_stmt 1 view .LVU219
 304:tmk_core/common/action.c ****                         }
 864              		.loc 1 304 50 is_stmt 0 view .LVU220
 865 0166 FFF7FEFF 		bl	get_oneshot_mods
 866              	.LVL78:
 304:tmk_core/common/action.c ****                         }
 867              		.loc 1 304 29 view .LVU221
 868 016a 3043     		orrs	r0, r0, r6
 869 016c C0B2     		uxtb	r0, r0
 870              	.LVL79:
 871              	.L152:
 304:tmk_core/common/action.c ****                         }
 872              		.loc 1 304 29 view .LVU222
 873              	.LBE16:
 492:tmk_core/common/action.c ****             } else {
 874              		.loc 1 492 17 view .LVU223
 875 016e FFF7FEFF 		bl	register_mods
 876              	.LVL80:
 877 0172 B4E7     		b	.L41
 878              	.LVL81:
 879              	.L66:
 880              	.LBB17:
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 881              		.loc 1 293 32 is_stmt 1 view .LVU224
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 882              		.loc 1 293 35 is_stmt 0 view .LVU225
 883 0174 B9F1010F 		cmp	r9, #1
 884 0178 F5D1     		bne	.L67
 294:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 885              		.loc 1 294 65 is_stmt 1 view .LVU226
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 886              		.loc 1 295 29 view .LVU227
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 887              		.loc 1 295 53 is_stmt 0 view .LVU228
 888 017a FFF7FEFF 		bl	get_oneshot_mods
 889              	.LVL82:
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 890              		.loc 1 295 29 view .LVU229
 891 017e 3043     		orrs	r0, r0, r6
 892 0180 C0B2     		uxtb	r0, r0
 893 0182 FFF7FEFF 		bl	set_oneshot_mods
 894              	.LVL83:
 895 0186 AAE7     		b	.L41
 896              	.L65:
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 897              		.loc 1 307 25 is_stmt 1 view .LVU230
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 898              		.loc 1 307 28 is_stmt 0 view .LVU231
 899 0188 B9F1000F 		cmp	r9, #0
 900 018c 05D1     		bne	.L68
 901              	.L155:
 322:tmk_core/common/action.c ****                             unregister_mods(mods);
 902              		.loc 1 322 29 is_stmt 1 view .LVU232
 903 018e FFF7FEFF 		bl	clear_oneshot_mods
 904              	.LVL84:
 323:tmk_core/common/action.c ****                         }
 905              		.loc 1 323 29 view .LVU233
 906              	.L74:
 372:tmk_core/common/action.c ****                             unregister_mods(mods);
 907              		.loc 1 372 67 view .LVU234
 373:tmk_core/common/action.c ****                         }
 908              		.loc 1 373 29 view .LVU235
 909 0192 3046     		mov	r0, r6
 910 0194 FFF7FEFF 		bl	unregister_mods
 911              	.LVL85:
 912 0198 A1E7     		b	.L41
 913              	.L68:
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 914              		.loc 1 310 32 view .LVU236
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 915              		.loc 1 310 35 is_stmt 0 view .LVU237
 916 019a B9F1010F 		cmp	r9, #1
 917 019e 9ED0     		beq	.L41
 918 01a0 F5E7     		b	.L155
 919              	.L63:
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 920              		.loc 1 329 21 is_stmt 1 view .LVU238
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 921              		.loc 1 329 24 is_stmt 0 view .LVU239
 922 01a2 25B1     		cbz	r5, .L70
 330:tmk_core/common/action.c ****                             register_mods(mods);
 923              		.loc 1 330 25 is_stmt 1 view .LVU240
 330:tmk_core/common/action.c ****                             register_mods(mods);
 924              		.loc 1 330 28 is_stmt 0 view .LVU241
 925 01a4 B9F1050F 		cmp	r9, #5
 926 01a8 99D8     		bhi	.L41
 927              	.L72:
 359:tmk_core/common/action.c ****                             register_mods(mods);
 928              		.loc 1 359 67 is_stmt 1 view .LVU242
 360:tmk_core/common/action.c ****                         }
 929              		.loc 1 360 29 view .LVU243
 930 01aa 3046     		mov	r0, r6
 931 01ac DFE7     		b	.L152
 932              	.L70:
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 933              		.loc 1 334 25 view .LVU244
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 934              		.loc 1 334 28 is_stmt 0 view .LVU245
 935 01ae B9F1040F 		cmp	r9, #4
 936 01b2 94D8     		bhi	.L41
 937 01b4 EDE7     		b	.L74
 938              	.L73:
 355:tmk_core/common/action.c ****                                 register_code(action.key.code);
 939              		.loc 1 355 73 is_stmt 1 view .LVU246
 356:tmk_core/common/action.c ****                             }
 940              		.loc 1 356 33 view .LVU247
 941 01b6 5046     		mov	r0, r10
 942 01b8 7AE7     		b	.L151
 943              	.L71:
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 944              		.loc 1 363 25 view .LVU248
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 945              		.loc 1 363 28 is_stmt 0 view .LVU249
 946 01ba B9F1000F 		cmp	r9, #0
 947 01be E8D0     		beq	.L74
 364:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 948              		.loc 1 364 71 is_stmt 1 view .LVU250
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 949              		.loc 1 365 29 view .LVU251
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 950              		.loc 1 365 32 is_stmt 0 view .LVU252
 951 01c0 BAF1390F 		cmp	r10, #57
 366:tmk_core/common/action.c ****                             } else {
 952              		.loc 1 366 33 is_stmt 1 view .LVU253
 953 01c4 0CBF     		ite	eq
 954 01c6 5020     		moveq	r0, #80
 368:tmk_core/common/action.c ****                             }
 955              		.loc 1 368 33 view .LVU254
 956 01c8 0020     		movne	r0, #0
 957 01ca 0021     		movs	r1, #0
 958 01cc FFF7FEFF 		bl	CLK_delay_ms
 959              	.LVL86:
 370:tmk_core/common/action.c ****                         } else {
 960              		.loc 1 370 29 view .LVU255
 961 01d0 5046     		mov	r0, r10
 962              	.LVL87:
 963              	.L153:
 370:tmk_core/common/action.c ****                         } else {
 964              		.loc 1 370 29 is_stmt 0 view .LVU256
 965              	.LBE17:
 579:tmk_core/common/action.c ****                         } else {
 966              		.loc 1 579 29 view .LVU257
 967 01d2 FFF7FEFF 		bl	unregister_code
 968              	.LVL88:
 969 01d6 82E7     		b	.L41
 970              	.L48:
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 971              		.loc 1 383 13 is_stmt 1 view .LVU258
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 972              		.loc 1 383 33 is_stmt 0 view .LVU259
 973 01d8 C4F38123 		ubfx	r3, r4, #10, #2
 974 01dc 43B1     		cbz	r3, .L77
 975 01de 012B     		cmp	r3, #1
 976 01e0 7FF47DAF 		bne	.L41
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 977              		.loc 1 392 21 is_stmt 1 view .LVU260
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 978              		.loc 1 392 24 is_stmt 0 view .LVU261
 979 01e4 65B1     		cbz	r5, .L80
 393:tmk_core/common/action.c ****                     } else {
 980              		.loc 1 393 25 is_stmt 1 view .LVU262
 981 01e6 C4F30900 		ubfx	r0, r4, #0, #10
 982              	.L154:
 395:tmk_core/common/action.c ****                     }
 983              		.loc 1 395 25 is_stmt 0 view .LVU263
 984 01ea FFF7FEFF 		bl	host_consumer_send
 985              	.LVL89:
 986 01ee 76E7     		b	.L41
 987              	.L77:
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 988              		.loc 1 385 21 is_stmt 1 view .LVU264
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 989              		.loc 1 385 24 is_stmt 0 view .LVU265
 990 01f0 25B1     		cbz	r5, .L79
 386:tmk_core/common/action.c ****                     } else {
 991              		.loc 1 386 25 is_stmt 1 view .LVU266
 992 01f2 C4F30900 		ubfx	r0, r4, #0, #10
 993              	.L149:
 388:tmk_core/common/action.c ****                     }
 994              		.loc 1 388 25 is_stmt 0 view .LVU267
 995 01f6 FFF7FEFF 		bl	host_system_send
 996              	.LVL90:
 997 01fa 70E7     		b	.L41
 998              	.L79:
 388:tmk_core/common/action.c ****                     }
 999              		.loc 1 388 25 is_stmt 1 view .LVU268
 1000 01fc 2846     		mov	r0, r5
 1001 01fe FAE7     		b	.L149
 1002              	.L80:
 395:tmk_core/common/action.c ****                     }
 1003              		.loc 1 395 25 view .LVU269
 1004 0200 2846     		mov	r0, r5
 1005 0202 F2E7     		b	.L154
 1006              	.L47:
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1007              		.loc 1 445 13 view .LVU270
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1008              		.loc 1 445 16 is_stmt 0 view .LVU271
 1009 0204 14F4407F 		tst	r4, #768
 1010 0208 25D1     		bne	.L81
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1011              		.loc 1 447 17 is_stmt 1 view .LVU272
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1012              		.loc 1 447 20 is_stmt 0 view .LVU273
 1013 020a 002D     		cmp	r5, #0
 1014 020c 7FF467AF 		bne	.L41
 1015              	.LBB18:
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1016              		.loc 1 448 21 is_stmt 1 view .LVU274
 1017              	.LVL91:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1018              		.loc 1 449 21 view .LVU275
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1019              		.loc 1 450 104 is_stmt 0 view .LVU276
 1020 0210 E206     		lsls	r2, r4, #27
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1021              		.loc 1 448 61 view .LVU277
 1022 0212 C4F34210 		ubfx	r0, r4, #5, #3
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1023              		.loc 1 450 94 view .LVU278
 1024 0216 48BF     		it	mi
 1025 0218 0F25     		movmi	r5, #15
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1026              		.loc 1 449 84 view .LVU279
 1027 021a 4FEA8000 		lsl	r0, r0, #2
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1028              		.loc 1 450 94 view .LVU280
 1029 021e 48BF     		it	mi
 1030 0220 8540     		lslmi	r5, r5, r0
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1031              		.loc 1 449 44 view .LVU281
 1032 0222 04F00F03 		and	r3, r4, #15
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1033              		.loc 1 451 47 view .LVU282
 1034 0226 C4F38122 		ubfx	r2, r4, #10, #2
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1035              		.loc 1 450 104 view .LVU283
 1036 022a 48BF     		it	mi
 1037 022c ED43     		mvnmi	r5, r5
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1038              		.loc 1 449 35 view .LVU284
 1039 022e 8340     		lsls	r3, r3, r0
 1040              	.LVL92:
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1041              		.loc 1 450 21 is_stmt 1 view .LVU285
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1042              		.loc 1 451 21 view .LVU286
 1043 0230 022A     		cmp	r2, #2
 1044 0232 45EA0300 		orr	r0, r5, r3
 1045 0236 08D0     		beq	.L83
 1046 0238 0AD8     		bhi	.L84
 1047 023a 012A     		cmp	r2, #1
 1048 023c 02D0     		beq	.L85
 453:tmk_core/common/action.c ****                             break;
 1049              		.loc 1 453 29 view .LVU287
 1050 023e FFF7FEFF 		bl	default_layer_and
 1051              	.LVL93:
 454:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1052              		.loc 1 454 29 view .LVU288
 1053 0242 4CE7     		b	.L41
 1054              	.LVL94:
 1055              	.L85:
 456:tmk_core/common/action.c ****                             break;
 1056              		.loc 1 456 29 view .LVU289
 1057 0244 FFF7FEFF 		bl	default_layer_or
 1058              	.LVL95:
 457:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1059              		.loc 1 457 29 view .LVU290
 1060 0248 49E7     		b	.L41
 1061              	.LVL96:
 1062              	.L83:
 459:tmk_core/common/action.c ****                             break;
 1063              		.loc 1 459 29 view .LVU291
 1064 024a FFF7FEFF 		bl	default_layer_xor
 1065              	.LVL97:
 460:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1066              		.loc 1 460 29 view .LVU292
 1067 024e 46E7     		b	.L41
 1068              	.LVL98:
 1069              	.L84:
 462:tmk_core/common/action.c ****                             break;
 1070              		.loc 1 462 29 view .LVU293
 1071 0250 FFF7FEFF 		bl	default_layer_set
 1072              	.LVL99:
 463:tmk_core/common/action.c ****                     }
 1073              		.loc 1 463 29 view .LVU294
 1074 0254 43E7     		b	.L41
 1075              	.LVL100:
 1076              	.L81:
 463:tmk_core/common/action.c ****                     }
 1077              		.loc 1 463 29 is_stmt 0 view .LVU295
 1078              	.LBE18:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1079              		.loc 1 468 17 is_stmt 1 view .LVU296
 1080 0256 C4F30122 		ubfx	r2, r4, #8, #2
 1081 025a D3B2     		uxtb	r3, r2
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1082              		.loc 1 468 21 is_stmt 0 view .LVU297
 1083 025c F5B1     		cbz	r5, .L86
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1084              		.loc 1 468 21 discriminator 1 view .LVU298
 1085 025e 02F00103 		and	r3, r2, #1
 1086              	.L87:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1087              		.loc 1 468 20 discriminator 4 view .LVU299
 1088 0262 002B     		cmp	r3, #0
 1089 0264 3FF43BAF 		beq	.L41
 1090              	.LBB19:
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1091              		.loc 1 469 21 is_stmt 1 view .LVU300
 1092              	.LVL101:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1093              		.loc 1 470 21 view .LVU301
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1094              		.loc 1 469 61 is_stmt 0 view .LVU302
 1095 0268 C4F34210 		ubfx	r0, r4, #5, #3
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1096              		.loc 1 470 84 view .LVU303
 1097 026c 8300     		lsls	r3, r0, #2
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1098              		.loc 1 470 44 view .LVU304
 1099 026e 04F00F00 		and	r0, r4, #15
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1100              		.loc 1 470 35 view .LVU305
 1101 0272 00FA03F2 		lsl	r2, r0, r3
 1102              	.LVL102:
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1103              		.loc 1 471 21 is_stmt 1 view .LVU306
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1104              		.loc 1 471 104 is_stmt 0 view .LVU307
 1105 0276 14F01000 		ands	r0, r4, #16
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1106              		.loc 1 471 94 view .LVU308
 1107 027a 1CBF     		itt	ne
 1108 027c 0F20     		movne	r0, #15
 1109 027e 9840     		lslne	r0, r0, r3
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1110              		.loc 1 472 47 view .LVU309
 1111 0280 C4F38123 		ubfx	r3, r4, #10, #2
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1112              		.loc 1 471 104 view .LVU310
 1113 0284 18BF     		it	ne
 1114 0286 C043     		mvnne	r0, r0
 1115              	.LVL103:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1116              		.loc 1 472 21 is_stmt 1 view .LVU311
 1117 0288 022B     		cmp	r3, #2
 1118 028a 40EA0200 		orr	r0, r0, r2
 1119              	.LVL104:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1120              		.loc 1 472 21 is_stmt 0 view .LVU312
 1121 028e 0AD0     		beq	.L89
 1122 0290 0CD8     		bhi	.L90
 1123 0292 012B     		cmp	r3, #1
 1124 0294 04D0     		beq	.L91
 474:tmk_core/common/action.c ****                             break;
 1125              		.loc 1 474 29 is_stmt 1 view .LVU313
 1126 0296 FFF7FEFF 		bl	layer_and
 1127              	.LVL105:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1128              		.loc 1 475 29 view .LVU314
 1129 029a 20E7     		b	.L41
 1130              	.LVL106:
 1131              	.L86:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1132              		.loc 1 475 29 is_stmt 0 view .LVU315
 1133              	.LBE19:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1134              		.loc 1 468 21 discriminator 2 view .LVU316
 1135 029c 5B08     		lsrs	r3, r3, #1
 1136 029e E0E7     		b	.L87
 1137              	.LVL107:
 1138              	.L91:
 1139              	.LBB20:
 477:tmk_core/common/action.c ****                             break;
 1140              		.loc 1 477 29 is_stmt 1 view .LVU317
 1141 02a0 FFF7FEFF 		bl	layer_or
 1142              	.LVL108:
 478:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1143              		.loc 1 478 29 view .LVU318
 1144 02a4 1BE7     		b	.L41
 1145              	.LVL109:
 1146              	.L89:
 480:tmk_core/common/action.c ****                             break;
 1147              		.loc 1 480 29 view .LVU319
 1148 02a6 FFF7FEFF 		bl	layer_xor
 1149              	.LVL110:
 481:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1150              		.loc 1 481 29 view .LVU320
 1151 02aa 18E7     		b	.L41
 1152              	.LVL111:
 1153              	.L90:
 483:tmk_core/common/action.c ****                             break;
 1154              		.loc 1 483 29 view .LVU321
 1155 02ac FFF7FEFF 		bl	layer_state_set
 1156              	.LVL112:
 484:tmk_core/common/action.c ****                     }
 1157              		.loc 1 484 29 view .LVU322
 1158 02b0 15E7     		b	.L41
 1159              	.LVL113:
 1160              	.L46:
 484:tmk_core/common/action.c ****                     }
 1161              		.loc 1 484 29 is_stmt 0 view .LVU323
 1162              	.LBE20:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1163              		.loc 1 490 13 is_stmt 1 view .LVU324
 1164 02b2 5FFA84F9 		uxtb	r9, r4
 1165 02b6 C4F30326 		ubfx	r6, r4, #8, #4
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1166              		.loc 1 490 16 is_stmt 0 view .LVU325
 1167 02ba 25B1     		cbz	r5, .L92
 491:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1168              		.loc 1 491 17 is_stmt 1 view .LVU326
 1169 02bc 3046     		mov	r0, r6
 1170 02be FFF7FEFF 		bl	layer_on
 1171              	.LVL114:
 492:tmk_core/common/action.c ****             } else {
 1172              		.loc 1 492 17 view .LVU327
 1173 02c2 4846     		mov	r0, r9
 1174 02c4 53E7     		b	.L152
 1175              	.L92:
 494:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1176              		.loc 1 494 17 view .LVU328
 1177 02c6 4846     		mov	r0, r9
 1178 02c8 FFF7FEFF 		bl	unregister_mods
 1179              	.LVL115:
 495:tmk_core/common/action.c ****             }
 1180              		.loc 1 495 17 view .LVU329
 1181 02cc 3046     		mov	r0, r6
 1182              	.L148:
 582:tmk_core/common/action.c ****                         }
 1183              		.loc 1 582 29 is_stmt 0 view .LVU330
 1184 02ce FFF7FEFF 		bl	layer_off
 1185              	.LVL116:
 1186 02d2 04E7     		b	.L41
 1187              	.L45:
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1188              		.loc 1 501 13 is_stmt 1 view .LVU331
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1189              		.loc 1 501 37 is_stmt 0 view .LVU332
 1190 02d4 E6B2     		uxtb	r6, r4
 1191 02d6 A6F1F003 		sub	r3, r6, #240
 1192 02da 042B     		cmp	r3, #4
 1193 02dc 3CD8     		bhi	.L93
 1194 02de DFE803F0 		tbb	[pc, r3]
 1195              	.L95:
 1196 02e2 03       		.byte	(.L99-.L95)/2
 1197 02e3 10       		.byte	(.L98-.L95)/2
 1198 02e4 17       		.byte	(.L97-.L95)/2
 1199 02e5 1C       		.byte	(.L96-.L95)/2
 1200 02e6 25       		.byte	(.L94-.L95)/2
 1201 02e7 00       		.p2align 1
 1202              	.L99:
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1203              		.loc 1 504 21 is_stmt 1 view .LVU333
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1204              		.loc 1 504 24 is_stmt 0 view .LVU334
 1205 02e8 45B1     		cbz	r5, .L100
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1206              		.loc 1 505 25 is_stmt 1 view .LVU335
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1207              		.loc 1 505 28 is_stmt 0 view .LVU336
 1208 02ea B9F1040F 		cmp	r9, #4
 1209              	.L146:
 1210 02ee 3FF6F6AE 		bhi	.L41
 506:tmk_core/common/action.c ****                         }
 1211              		.loc 1 506 29 is_stmt 1 view .LVU337
 1212 02f2 C4F30420 		ubfx	r0, r4, #8, #5
 1213 02f6 FFF7FEFF 		bl	layer_invert
 1214              	.LVL117:
 1215 02fa F0E6     		b	.L41
 1216              	.L100:
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1217              		.loc 1 509 25 view .LVU338
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1218              		.loc 1 509 28 is_stmt 0 view .LVU339
 1219 02fc B9F1050F 		cmp	r9, #5
 1220 0300 F5E7     		b	.L146
 1221              	.L98:
 515:tmk_core/common/action.c ****                     break;
 1222              		.loc 1 515 21 is_stmt 1 view .LVU340
 1223 0302 C4F30420 		ubfx	r0, r4, #8, #5
 515:tmk_core/common/action.c ****                     break;
 1224              		.loc 1 515 68 is_stmt 0 view .LVU341
 1225 0306 002D     		cmp	r5, #0
 1226 0308 E1D0     		beq	.L148
 1227              	.L150:
 569:tmk_core/common/action.c ****                         }
 1228              		.loc 1 569 29 view .LVU342
 1229 030a FFF7FEFF 		bl	layer_on
 1230              	.LVL118:
 1231 030e E6E6     		b	.L41
 1232              	.L97:
 518:tmk_core/common/action.c ****                     break;
 1233              		.loc 1 518 21 is_stmt 1 view .LVU343
 1234 0310 C4F30420 		ubfx	r0, r4, #8, #5
 518:tmk_core/common/action.c ****                     break;
 1235              		.loc 1 518 69 is_stmt 0 view .LVU344
 1236 0314 002D     		cmp	r5, #0
 1237 0316 F8D0     		beq	.L150
 1238 0318 D9E7     		b	.L148
 1239              	.L96:
 521:tmk_core/common/action.c ****                     break;
 1240              		.loc 1 521 21 is_stmt 1 view .LVU345
 521:tmk_core/common/action.c ****                     break;
 1241              		.loc 1 521 70 is_stmt 0 view .LVU346
 1242 031a 25B1     		cbz	r5, .L104
 521:tmk_core/common/action.c ****                     break;
 1243              		.loc 1 521 37 discriminator 1 view .LVU347
 1244 031c C4F30420 		ubfx	r0, r4, #8, #5
 1245 0320 FFF7FEFF 		bl	layer_move
 1246              	.LVL119:
 1247 0324 DBE6     		b	.L41
 1248              	.L104:
 521:tmk_core/common/action.c ****                     break;
 1249              		.loc 1 521 72 discriminator 2 view .LVU348
 1250 0326 FFF7FEFF 		bl	layer_clear
 1251              	.LVL120:
 1252 032a D8E6     		b	.L41
 1253              	.L94:
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1254              		.loc 1 549 21 is_stmt 1 view .LVU349
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1255              		.loc 1 549 24 is_stmt 0 view .LVU350
 1256 032c 4DB1     		cbz	r5, .L105
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1257              		.loc 1 550 25 is_stmt 1 view .LVU351
 1258 032e C4F30425 		ubfx	r5, r4, #8, #5
 1259 0332 2846     		mov	r0, r5
 1260 0334 FFF7FEFF 		bl	layer_on
 1261              	.LVL121:
 551:tmk_core/common/action.c ****                     } else {
 1262              		.loc 1 551 25 view .LVU352
 1263 0338 0321     		movs	r1, #3
 1264 033a 2846     		mov	r0, r5
 1265 033c FFF7FEFF 		bl	set_oneshot_layer
 1266              	.LVL122:
 1267 0340 CDE6     		b	.L41
 1268              	.L105:
 553:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1269              		.loc 1 553 25 view .LVU353
 1270 0342 0120     		movs	r0, #1
 1271 0344 FFF7FEFF 		bl	clear_oneshot_layer_state
 1272              	.LVL123:
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1273              		.loc 1 554 25 view .LVU354
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1274              		.loc 1 554 28 is_stmt 0 view .LVU355
 1275 0348 B9F1010F 		cmp	r9, #1
 1276 034c 7FF6C7AE 		bls	.L41
 555:tmk_core/common/action.c ****                         }
 1277              		.loc 1 555 29 is_stmt 1 view .LVU356
 1278 0350 0220     		movs	r0, #2
 1279 0352 FFF7FEFF 		bl	clear_oneshot_layer_state
 1280              	.LVL124:
 1281 0356 C2E6     		b	.L41
 1282              	.L93:
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1283              		.loc 1 563 21 view .LVU357
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1284              		.loc 1 563 24 is_stmt 0 view .LVU358
 1285 0358 3DB1     		cbz	r5, .L106
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1286              		.loc 1 564 25 is_stmt 1 view .LVU359
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1287              		.loc 1 564 28 is_stmt 0 view .LVU360
 1288 035a B9F1000F 		cmp	r9, #0
 1289 035e 01D0     		beq	.L107
 565:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1290              		.loc 1 565 75 is_stmt 1 view .LVU361
 566:tmk_core/common/action.c ****                         } else {
 1291              		.loc 1 566 29 view .LVU362
 1292 0360 3046     		mov	r0, r6
 1293 0362 A5E6     		b	.L151
 1294              	.L107:
 568:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1295              		.loc 1 568 76 view .LVU363
 569:tmk_core/common/action.c ****                         }
 1296              		.loc 1 569 29 view .LVU364
 1297 0364 C4F30420 		ubfx	r0, r4, #8, #5
 1298 0368 CFE7     		b	.L150
 1299              	.L106:
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1300              		.loc 1 572 25 view .LVU365
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1301              		.loc 1 572 28 is_stmt 0 view .LVU366
 1302 036a B9F1000F 		cmp	r9, #0
 1303 036e 08D0     		beq	.L108
 573:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1304              		.loc 1 573 77 is_stmt 1 view .LVU367
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1305              		.loc 1 574 29 view .LVU368
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1306              		.loc 1 574 32 is_stmt 0 view .LVU369
 1307 0370 392E     		cmp	r6, #57
 575:tmk_core/common/action.c ****                             } else {
 1308              		.loc 1 575 33 is_stmt 1 view .LVU370
 1309 0372 0CBF     		ite	eq
 1310 0374 5020     		moveq	r0, #80
 577:tmk_core/common/action.c ****                             }
 1311              		.loc 1 577 33 view .LVU371
 1312 0376 0020     		movne	r0, #0
 1313 0378 0021     		movs	r1, #0
 1314 037a FFF7FEFF 		bl	CLK_delay_ms
 1315              	.LVL125:
 579:tmk_core/common/action.c ****                         } else {
 1316              		.loc 1 579 29 view .LVU372
 1317 037e 3046     		mov	r0, r6
 1318 0380 27E7     		b	.L153
 1319              	.L108:
 581:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1320              		.loc 1 581 79 view .LVU373
 582:tmk_core/common/action.c ****                         }
 1321              		.loc 1 582 29 view .LVU374
 1322 0382 C4F30420 		ubfx	r0, r4, #8, #5
 1323 0386 A2E7     		b	.L148
 1324              	.L44:
 593:tmk_core/common/action.c ****             break;
 1325              		.loc 1 593 13 view .LVU375
 1326 0388 C4F30322 		ubfx	r2, r4, #8, #4
 1327 038c E1B2     		uxtb	r1, r4
 1328 038e 3846     		mov	r0, r7
 1329 0390 FFF7FEFF 		bl	action_get_macro
 1330              	.LVL126:
 1331 0394 FFF7FEFF 		bl	action_macro_play
 1332              	.LVL127:
 594:tmk_core/common/action.c **** #endif
 1333              		.loc 1 594 13 view .LVU376
 1334 0398 A1E6     		b	.L41
 1335              	.L42:
 671:tmk_core/common/action.c ****             break;
 1336              		.loc 1 671 13 view .LVU377
 1337 039a C4F30322 		ubfx	r2, r4, #8, #4
 1338 039e E1B2     		uxtb	r1, r4
 1339 03a0 3846     		mov	r0, r7
 1340 03a2 FFF7FEFF 		bl	action_function
 1341              	.LVL128:
 672:tmk_core/common/action.c **** #endif
 1342              		.loc 1 672 13 view .LVU378
 1343 03a6 9AE6     		b	.L41
 1344              	.LVL129:
 1345              	.L37:
 737:tmk_core/common/action.c **** 
 1346              		.loc 1 737 1 is_stmt 0 view .LVU379
 1347 03a8 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 737:tmk_core/common/action.c **** 
 1348              		.loc 1 737 1 view .LVU380
 1349              		.cfi_endproc
 1350              	.LFE15:
 1352              		.section	.text.process_record_handler,"ax",%progbits
 1353              		.align	1
 1354              		.global	process_record_handler
 1355              		.syntax unified
 1356              		.thumb
 1357              		.thumb_func
 1358              		.fpu fpv4-sp-d16
 1360              	process_record_handler:
 1361              	.LVL130:
 1362              	.LFB14:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1363              		.loc 1 208 50 is_stmt 1 view -0
 1364              		.cfi_startproc
 1365              		@ args = 0, pretend = 0, frame = 0
 1366              		@ frame_needed = 0, uses_anonymous_args = 0
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1367              		.loc 1 209 5 view .LVU382
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1368              		.loc 1 208 50 is_stmt 0 view .LVU383
 1369 0000 38B5     		push	{r3, r4, r5, lr}
 1370              		.cfi_def_cfa_offset 16
 1371              		.cfi_offset 3, -16
 1372              		.cfi_offset 4, -12
 1373              		.cfi_offset 5, -8
 1374              		.cfi_offset 14, -4
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1375              		.loc 1 208 50 view .LVU384
 1376 0002 0446     		mov	r4, r0
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1377              		.loc 1 209 23 view .LVU385
 1378 0004 0188     		ldrh	r1, [r0]
 1379 0006 8078     		ldrb	r0, [r0, #2]	@ zero_extendqisi2
 1380              	.LVL131:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1381              		.loc 1 209 23 view .LVU386
 1382 0008 FFF7FEFF 		bl	store_or_get_action
 1383              	.LVL132:
 1384 000c 0546     		mov	r5, r0	@ movhi
 1385              	.LVL133:
 210:tmk_core/common/action.c ****     debug_action(action);
 1386              		.loc 1 210 23 is_stmt 1 view .LVU387
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1387              		.loc 1 211 5 view .LVU388
 213:tmk_core/common/action.c ****     layer_debug();
 1388              		.loc 1 213 29 view .LVU389
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1389              		.loc 1 214 5 view .LVU390
 1390 000e FFF7FEFF 		bl	layer_debug
 1391              	.LVL134:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1392              		.loc 1 215 37 view .LVU391
 216:tmk_core/common/action.c **** #endif
 1393              		.loc 1 216 5 view .LVU392
 1394 0012 FFF7FEFF 		bl	default_layer_debug
 1395              	.LVL135:
 218:tmk_core/common/action.c **** 
 1396              		.loc 1 218 15 view .LVU393
 220:tmk_core/common/action.c **** }
 1397              		.loc 1 220 5 view .LVU394
 220:tmk_core/common/action.c **** }
 1398              		.loc 1 220 5 is_stmt 0 view .LVU395
 1399 0016 2946     		mov	r1, r5	@ movhi
 1400 0018 2046     		mov	r0, r4
 221:tmk_core/common/action.c **** 
 1401              		.loc 1 221 1 view .LVU396
 1402 001a BDE83840 		pop	{r3, r4, r5, lr}
 1403              		.cfi_restore 14
 1404              		.cfi_restore 5
 1405              		.cfi_restore 4
 1406              		.cfi_restore 3
 1407              		.cfi_def_cfa_offset 0
 1408              	.LVL136:
 220:tmk_core/common/action.c **** }
 1409              		.loc 1 220 5 view .LVU397
 1410 001e FFF7FEBF 		b	process_action
 1411              	.LVL137:
 220:tmk_core/common/action.c **** }
 1412              		.loc 1 220 5 view .LVU398
 1413              		.cfi_endproc
 1414              	.LFE14:
 1416              		.section	.text.process_record,"ax",%progbits
 1417              		.align	1
 1418              		.global	process_record
 1419              		.syntax unified
 1420              		.thumb
 1421              		.thumb_func
 1422              		.fpu fpv4-sp-d16
 1424              	process_record:
 1425              	.LVL138:
 1426              	.LFB13:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1427              		.loc 1 190 42 is_stmt 1 view -0
 1428              		.cfi_startproc
 1429              		@ args = 0, pretend = 0, frame = 8
 1430              		@ frame_needed = 0, uses_anonymous_args = 0
 191:tmk_core/common/action.c ****         return;
 1431              		.loc 1 191 5 view .LVU400
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1432              		.loc 1 190 42 is_stmt 0 view .LVU401
 1433 0000 13B5     		push	{r0, r1, r4, lr}
 1434              		.cfi_def_cfa_offset 16
 1435              		.cfi_offset 4, -8
 1436              		.cfi_offset 14, -4
 191:tmk_core/common/action.c ****         return;
 1437              		.loc 1 191 9 view .LVU402
 1438 0002 8388     		ldrh	r3, [r0, #4]
 1439 0004 0288     		ldrh	r2, [r0]	@ unaligned
 1440 0006 ADF80420 		strh	r2, [sp, #4]	@ unaligned
 1441              	.LBB21:
 1442              	.LBI21:
 1443              		.loc 2 48 20 is_stmt 1 view .LVU403
 1444              	.LBB22:
 1445              		.loc 2 48 51 view .LVU404
 1446              	.LBE22:
 1447              	.LBE21:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1448              		.loc 1 190 42 is_stmt 0 view .LVU405
 1449 000a 0446     		mov	r4, r0
 1450              	.LBB24:
 1451              	.LBB23:
 1452              		.loc 2 48 74 view .LVU406
 1453 000c CBB1     		cbz	r3, .L157
 1454              	.LBE23:
 1455              	.LBE24:
 191:tmk_core/common/action.c ****         return;
 1456              		.loc 1 191 8 view .LVU407
 1457 000e BDF80420 		ldrh	r2, [sp, #4]
 1458 0012 4FF6FF73 		movw	r3, #65535
 1459 0016 9A42     		cmp	r2, r3
 1460 0018 13D0     		beq	.L157
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1461              		.loc 1 195 5 is_stmt 1 view .LVU408
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1462              		.loc 1 195 10 is_stmt 0 view .LVU409
 1463 001a FFF7FEFF 		bl	process_record_quantum
 1464              	.LVL139:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1465              		.loc 1 195 8 view .LVU410
 1466 001e 50B9     		cbnz	r0, .L161
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1467              		.loc 1 197 9 is_stmt 1 view .LVU411
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1468              		.loc 1 197 13 is_stmt 0 view .LVU412
 1469 0020 FFF7FEFF 		bl	is_oneshot_layer_active
 1470              	.LVL140:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1471              		.loc 1 197 12 view .LVU413
 1472 0024 68B1     		cbz	r0, .L157
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1473              		.loc 1 197 39 discriminator 1 view .LVU414
 1474 0026 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1475 0028 5BB1     		cbz	r3, .L157
 198:tmk_core/common/action.c ****         }
 1476              		.loc 1 198 13 is_stmt 1 view .LVU415
 1477 002a 0220     		movs	r0, #2
 206:tmk_core/common/action.c **** 
 1478              		.loc 1 206 1 is_stmt 0 view .LVU416
 1479 002c 02B0     		add	sp, sp, #8
 1480              		.cfi_remember_state
 1481              		.cfi_def_cfa_offset 8
 1482              		@ sp needed
 1483 002e BDE81040 		pop	{r4, lr}
 1484              		.cfi_restore 14
 1485              		.cfi_restore 4
 1486              		.cfi_def_cfa_offset 0
 1487              	.LVL141:
 198:tmk_core/common/action.c ****         }
 1488              		.loc 1 198 13 view .LVU417
 1489 0032 FFF7FEBF 		b	clear_oneshot_layer_state
 1490              	.LVL142:
 1491              	.L161:
 1492              		.cfi_restore_state
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1493              		.loc 1 204 5 is_stmt 1 view .LVU418
 1494 0036 2046     		mov	r0, r4
 1495 0038 FFF7FEFF 		bl	process_record_handler
 1496              	.LVL143:
 205:tmk_core/common/action.c **** }
 1497              		.loc 1 205 5 view .LVU419
 1498 003c 2046     		mov	r0, r4
 1499 003e FFF7FEFF 		bl	post_process_record_quantum
 1500              	.LVL144:
 1501              	.L157:
 206:tmk_core/common/action.c **** 
 1502              		.loc 1 206 1 is_stmt 0 view .LVU420
 1503 0042 02B0     		add	sp, sp, #8
 1504              		.cfi_def_cfa_offset 8
 1505              		@ sp needed
 1506 0044 10BD     		pop	{r4, pc}
 206:tmk_core/common/action.c **** 
 1507              		.loc 1 206 1 view .LVU421
 1508              		.cfi_endproc
 1509              	.LFE13:
 1511              		.section	.text.process_record_nocache,"ax",%progbits
 1512              		.align	1
 1513              		.global	process_record_nocache
 1514              		.syntax unified
 1515              		.thumb
 1516              		.thumb_func
 1517              		.fpu fpv4-sp-d16
 1519              	process_record_nocache:
 1520              	.LVL145:
 1521              	.LFB9:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1522              		.loc 1 148 50 is_stmt 1 view -0
 1523              		.cfi_startproc
 1524              		@ args = 0, pretend = 0, frame = 0
 1525              		@ frame_needed = 0, uses_anonymous_args = 0
 149:tmk_core/common/action.c ****     process_record(record);
 1526              		.loc 1 149 5 view .LVU423
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1527              		.loc 1 148 50 is_stmt 0 view .LVU424
 1528 0000 10B5     		push	{r4, lr}
 1529              		.cfi_def_cfa_offset 8
 1530              		.cfi_offset 4, -8
 1531              		.cfi_offset 14, -4
 149:tmk_core/common/action.c ****     process_record(record);
 1532              		.loc 1 149 26 view .LVU425
 1533 0002 044C     		ldr	r4, .L169
 1534 0004 0123     		movs	r3, #1
 1535 0006 2370     		strb	r3, [r4]
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 1536              		.loc 1 150 5 is_stmt 1 view .LVU426
 1537 0008 FFF7FEFF 		bl	process_record
 1538              	.LVL146:
 151:tmk_core/common/action.c **** }
 1539              		.loc 1 151 5 view .LVU427
 151:tmk_core/common/action.c **** }
 1540              		.loc 1 151 26 is_stmt 0 view .LVU428
 1541 000c 0023     		movs	r3, #0
 1542 000e 2370     		strb	r3, [r4]
 152:tmk_core/common/action.c **** #else
 1543              		.loc 1 152 1 view .LVU429
 1544 0010 10BD     		pop	{r4, pc}
 1545              	.L170:
 1546 0012 00BF     		.align	2
 1547              	.L169:
 1548 0014 00000000 		.word	.LANCHOR1
 1549              		.cfi_endproc
 1550              	.LFE9:
 1552              		.section	.text.register_weak_mods,"ax",%progbits
 1553              		.align	1
 1554              		.global	register_weak_mods
 1555              		.syntax unified
 1556              		.thumb
 1557              		.thumb_func
 1558              		.fpu fpv4-sp-d16
 1560              	register_weak_mods:
 1561              	.LVL147:
 1562              	.LFB21:
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1563              		.loc 1 939 39 is_stmt 1 view -0
 1564              		.cfi_startproc
 1565              		@ args = 0, pretend = 0, frame = 0
 1566              		@ frame_needed = 0, uses_anonymous_args = 0
 940:tmk_core/common/action.c ****     if (mods) {
 1567              		.loc 1 940 5 view .LVU431
 939:tmk_core/common/action.c ****     if (mods) {
 1568              		.loc 1 939 39 is_stmt 0 view .LVU432
 1569 0000 08B5     		push	{r3, lr}
 1570              		.cfi_def_cfa_offset 8
 1571              		.cfi_offset 3, -8
 1572              		.cfi_offset 14, -4
 1573              		.loc 1 940 8 view .LVU433
 1574 0002 28B1     		cbz	r0, .L171
 941:tmk_core/common/action.c ****         add_weak_mods(mods);
 1575              		.loc 1 941 9 is_stmt 1 view .LVU434
 1576 0004 FFF7FEFF 		bl	add_weak_mods
 1577              	.LVL148:
 942:tmk_core/common/action.c ****         send_keyboard_report();
 1578              		.loc 1 942 9 view .LVU435
 943:tmk_core/common/action.c ****     }
 944:tmk_core/common/action.c **** }
 1579              		.loc 1 944 1 is_stmt 0 view .LVU436
 1580 0008 BDE80840 		pop	{r3, lr}
 1581              		.cfi_remember_state
 1582              		.cfi_restore 14
 1583              		.cfi_restore 3
 1584              		.cfi_def_cfa_offset 0
 942:tmk_core/common/action.c ****         send_keyboard_report();
 1585              		.loc 1 942 9 view .LVU437
 1586 000c FFF7FEBF 		b	send_keyboard_report
 1587              	.LVL149:
 1588              	.L171:
 1589              		.cfi_restore_state
 1590              		.loc 1 944 1 view .LVU438
 1591 0010 08BD     		pop	{r3, pc}
 1592              		.cfi_endproc
 1593              	.LFE21:
 1595              		.section	.text.unregister_weak_mods,"ax",%progbits
 1596              		.align	1
 1597              		.global	unregister_weak_mods
 1598              		.syntax unified
 1599              		.thumb
 1600              		.thumb_func
 1601              		.fpu fpv4-sp-d16
 1603              	unregister_weak_mods:
 1604              	.LVL150:
 1605              	.LFB22:
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1606              		.loc 1 950 41 is_stmt 1 view -0
 1607              		.cfi_startproc
 1608              		@ args = 0, pretend = 0, frame = 0
 1609              		@ frame_needed = 0, uses_anonymous_args = 0
 951:tmk_core/common/action.c ****     if (mods) {
 1610              		.loc 1 951 5 view .LVU440
 950:tmk_core/common/action.c ****     if (mods) {
 1611              		.loc 1 950 41 is_stmt 0 view .LVU441
 1612 0000 08B5     		push	{r3, lr}
 1613              		.cfi_def_cfa_offset 8
 1614              		.cfi_offset 3, -8
 1615              		.cfi_offset 14, -4
 1616              		.loc 1 951 8 view .LVU442
 1617 0002 28B1     		cbz	r0, .L173
 952:tmk_core/common/action.c ****         del_weak_mods(mods);
 1618              		.loc 1 952 9 is_stmt 1 view .LVU443
 1619 0004 FFF7FEFF 		bl	del_weak_mods
 1620              	.LVL151:
 953:tmk_core/common/action.c ****         send_keyboard_report();
 1621              		.loc 1 953 9 view .LVU444
 954:tmk_core/common/action.c ****     }
 955:tmk_core/common/action.c **** }
 1622              		.loc 1 955 1 is_stmt 0 view .LVU445
 1623 0008 BDE80840 		pop	{r3, lr}
 1624              		.cfi_remember_state
 1625              		.cfi_restore 14
 1626              		.cfi_restore 3
 1627              		.cfi_def_cfa_offset 0
 953:tmk_core/common/action.c ****         send_keyboard_report();
 1628              		.loc 1 953 9 view .LVU446
 1629 000c FFF7FEBF 		b	send_keyboard_report
 1630              	.LVL152:
 1631              	.L173:
 1632              		.cfi_restore_state
 1633              		.loc 1 955 1 view .LVU447
 1634 0010 08BD     		pop	{r3, pc}
 1635              		.cfi_endproc
 1636              	.LFE22:
 1638              		.section	.text.clear_keyboard_but_mods_and_keys,"ax",%progbits
 1639              		.align	1
 1640              		.global	clear_keyboard_but_mods_and_keys
 1641              		.syntax unified
 1642              		.thumb
 1643              		.thumb_func
 1644              		.fpu fpv4-sp-d16
 1646              	clear_keyboard_but_mods_and_keys:
 1647              	.LFB25:
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard(void) {
 962:tmk_core/common/action.c ****     clear_mods();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 971:tmk_core/common/action.c ****     clear_keys();
 972:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1648              		.loc 1 979 41 is_stmt 1 view -0
 1649              		.cfi_startproc
 1650              		@ args = 0, pretend = 0, frame = 0
 1651              		@ frame_needed = 0, uses_anonymous_args = 0
 980:tmk_core/common/action.c ****     clear_weak_mods();
 1652              		.loc 1 980 5 view .LVU449
 979:tmk_core/common/action.c ****     clear_weak_mods();
 1653              		.loc 1 979 41 is_stmt 0 view .LVU450
 1654 0000 08B5     		push	{r3, lr}
 1655              		.cfi_def_cfa_offset 8
 1656              		.cfi_offset 3, -8
 1657              		.cfi_offset 14, -4
 1658              		.loc 1 980 5 view .LVU451
 1659 0002 FFF7FEFF 		bl	clear_weak_mods
 1660              	.LVL153:
 981:tmk_core/common/action.c ****     clear_macro_mods();
 1661              		.loc 1 981 5 is_stmt 1 view .LVU452
 1662 0006 FFF7FEFF 		bl	clear_macro_mods
 1663              	.LVL154:
 982:tmk_core/common/action.c ****     send_keyboard_report();
 1664              		.loc 1 982 5 view .LVU453
 1665 000a FFF7FEFF 		bl	send_keyboard_report
 1666              	.LVL155:
 983:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 984:tmk_core/common/action.c ****     mousekey_clear();
 985:tmk_core/common/action.c ****     mousekey_send();
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 988:tmk_core/common/action.c ****     host_system_send(0);
 1667              		.loc 1 988 5 view .LVU454
 1668 000e 0020     		movs	r0, #0
 1669 0010 FFF7FEFF 		bl	host_system_send
 1670              	.LVL156:
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 1671              		.loc 1 989 5 view .LVU455
 1672 0014 0020     		movs	r0, #0
 990:tmk_core/common/action.c **** #endif
 991:tmk_core/common/action.c **** }
 1673              		.loc 1 991 1 is_stmt 0 view .LVU456
 1674 0016 BDE80840 		pop	{r3, lr}
 1675              		.cfi_restore 14
 1676              		.cfi_restore 3
 1677              		.cfi_def_cfa_offset 0
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 1678              		.loc 1 989 5 view .LVU457
 1679 001a FFF7FEBF 		b	host_consumer_send
 1680              	.LVL157:
 1681              		.cfi_endproc
 1682              	.LFE25:
 1684              		.section	.text.clear_keyboard_but_mods,"ax",%progbits
 1685              		.align	1
 1686              		.global	clear_keyboard_but_mods
 1687              		.syntax unified
 1688              		.thumb
 1689              		.thumb_func
 1690              		.fpu fpv4-sp-d16
 1692              	clear_keyboard_but_mods:
 1693              	.LFB24:
 970:tmk_core/common/action.c ****     clear_keys();
 1694              		.loc 1 970 36 is_stmt 1 view -0
 1695              		.cfi_startproc
 1696              		@ args = 0, pretend = 0, frame = 0
 1697              		@ frame_needed = 0, uses_anonymous_args = 0
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1698              		.loc 1 971 5 view .LVU459
 970:tmk_core/common/action.c ****     clear_keys();
 1699              		.loc 1 970 36 is_stmt 0 view .LVU460
 1700 0000 08B5     		push	{r3, lr}
 1701              		.cfi_def_cfa_offset 8
 1702              		.cfi_offset 3, -8
 1703              		.cfi_offset 14, -4
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1704              		.loc 1 971 5 view .LVU461
 1705 0002 FFF7FEFF 		bl	clear_keys
 1706              	.LVL158:
 972:tmk_core/common/action.c **** }
 1707              		.loc 1 972 5 is_stmt 1 view .LVU462
 973:tmk_core/common/action.c **** 
 1708              		.loc 1 973 1 is_stmt 0 view .LVU463
 1709 0006 BDE80840 		pop	{r3, lr}
 1710              		.cfi_restore 14
 1711              		.cfi_restore 3
 1712              		.cfi_def_cfa_offset 0
 972:tmk_core/common/action.c **** }
 1713              		.loc 1 972 5 view .LVU464
 1714 000a FFF7FEBF 		b	clear_keyboard_but_mods_and_keys
 1715              	.LVL159:
 1716              		.cfi_endproc
 1717              	.LFE24:
 1719              		.section	.text.clear_keyboard,"ax",%progbits
 1720              		.align	1
 1721              		.global	clear_keyboard
 1722              		.syntax unified
 1723              		.thumb
 1724              		.thumb_func
 1725              		.fpu fpv4-sp-d16
 1727              	clear_keyboard:
 1728              	.LFB23:
 961:tmk_core/common/action.c ****     clear_mods();
 1729              		.loc 1 961 27 is_stmt 1 view -0
 1730              		.cfi_startproc
 1731              		@ args = 0, pretend = 0, frame = 0
 1732              		@ frame_needed = 0, uses_anonymous_args = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1733              		.loc 1 962 5 view .LVU466
 961:tmk_core/common/action.c ****     clear_mods();
 1734              		.loc 1 961 27 is_stmt 0 view .LVU467
 1735 0000 08B5     		push	{r3, lr}
 1736              		.cfi_def_cfa_offset 8
 1737              		.cfi_offset 3, -8
 1738              		.cfi_offset 14, -4
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1739              		.loc 1 962 5 view .LVU468
 1740 0002 FFF7FEFF 		bl	clear_mods
 1741              	.LVL160:
 963:tmk_core/common/action.c **** }
 1742              		.loc 1 963 5 is_stmt 1 view .LVU469
 964:tmk_core/common/action.c **** 
 1743              		.loc 1 964 1 is_stmt 0 view .LVU470
 1744 0006 BDE80840 		pop	{r3, lr}
 1745              		.cfi_restore 14
 1746              		.cfi_restore 3
 1747              		.cfi_def_cfa_offset 0
 963:tmk_core/common/action.c **** }
 1748              		.loc 1 963 5 view .LVU471
 1749 000a FFF7FEBF 		b	clear_keyboard_but_mods
 1750              	.LVL161:
 1751              		.cfi_endproc
 1752              	.LFE23:
 1754              		.section	.text.is_tap_action,"ax",%progbits
 1755              		.align	1
 1756              		.global	is_tap_action
 1757              		.syntax unified
 1758              		.thumb
 1759              		.thumb_func
 1760              		.fpu fpv4-sp-d16
 1762              	is_tap_action:
 1763              	.LVL162:
 1764              	.LFB27:
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 998:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 999:tmk_core/common/action.c ****     return is_tap_action(action);
1000:tmk_core/common/action.c **** }
1001:tmk_core/common/action.c **** 
1002:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:tmk_core/common/action.c ****  *
1004:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1005:tmk_core/common/action.c ****  */
1006:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1765              		.loc 1 1006 37 is_stmt 1 view -0
 1766              		.cfi_startproc
 1767              		@ args = 0, pretend = 0, frame = 0
 1768              		@ frame_needed = 0, uses_anonymous_args = 0
1007:tmk_core/common/action.c ****     switch (action.kind.id) {
 1769              		.loc 1 1007 5 view .LVU473
 1770              		.loc 1 1007 24 is_stmt 0 view .LVU474
 1771 0000 C0F30333 		ubfx	r3, r0, #12, #4
 1772 0004 0E33     		adds	r3, r3, #14
 1773 0006 03F00F02 		and	r2, r3, #15
 1774 000a 0D2A     		cmp	r2, #13
1006:tmk_core/common/action.c ****     switch (action.kind.id) {
 1775              		.loc 1 1006 37 view .LVU475
 1776 000c 10B5     		push	{r4, lr}
 1777              		.cfi_def_cfa_offset 8
 1778              		.cfi_offset 4, -8
 1779              		.cfi_offset 14, -4
 1780 000e 22D8     		bhi	.L184
 1781 0010 0121     		movs	r1, #1
 1782 0012 01FA02F3 		lsl	r3, r1, r2
 1783 0016 13F4105F 		tst	r3, #9216
 1784 001a C4B2     		uxtb	r4, r0
 1785 001c 18D1     		bne	.L180
 1786 001e 40F20332 		movw	r2, #771
 1787 0022 1342     		tst	r3, r2
 1788 0024 03D1     		bne	.L181
 1789 0026 13F01000 		ands	r0, r3, #16
 1790              	.LVL163:
1006:tmk_core/common/action.c ****     switch (action.kind.id) {
 1791              		.loc 1 1006 37 view .LVU476
 1792 002a 0DD1     		bne	.L182
 1793              	.LVL164:
 1794              	.L179:
1008:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1009:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1010:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1011:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1012:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
1013:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1014:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1015:tmk_core/common/action.c ****                 case OP_ONESHOT:
1016:tmk_core/common/action.c ****                     return true;
1017:tmk_core/common/action.c ****             }
1018:tmk_core/common/action.c ****             return false;
1019:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1020:tmk_core/common/action.c ****             switch (action.swap.code) {
1021:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1022:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1023:tmk_core/common/action.c ****                     return true;
1024:tmk_core/common/action.c ****             }
1025:tmk_core/common/action.c ****             return false;
1026:tmk_core/common/action.c ****         case ACT_MACRO:
1027:tmk_core/common/action.c ****         case ACT_FUNCTION:
1028:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1029:tmk_core/common/action.c ****                 return true;
1030:tmk_core/common/action.c ****             }
1031:tmk_core/common/action.c ****             return false;
1032:tmk_core/common/action.c ****     }
1033:tmk_core/common/action.c ****     return false;
1034:tmk_core/common/action.c **** }
 1795              		.loc 1 1034 1 view .LVU477
 1796 002c 10BD     		pop	{r4, pc}
 1797              	.LVL165:
 1798              	.L181:
1012:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1799              		.loc 1 1012 13 is_stmt 1 view .LVU478
 1800 002e F02C     		cmp	r4, #240
 1801 0030 13D0     		beq	.L188
 1802 0032 04D8     		bhi	.L183
1016:tmk_core/common/action.c ****             }
 1803              		.loc 1 1016 28 is_stmt 0 view .LVU479
 1804 0034 E72C     		cmp	r4, #231
 1805 0036 8CBF     		ite	hi
 1806 0038 0020     		movhi	r0, #0
 1807              	.LVL166:
1016:tmk_core/common/action.c ****             }
 1808              		.loc 1 1016 28 view .LVU480
 1809 003a 0120     		movls	r0, #1
 1810 003c F6E7     		b	.L179
 1811              	.LVL167:
 1812              	.L183:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1813              		.loc 1 1018 20 view .LVU481
 1814 003e F42C     		cmp	r4, #244
 1815              	.LVL168:
 1816              	.L190:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1817              		.loc 1 1018 20 view .LVU482
 1818 0040 14BF     		ite	ne
 1819 0042 0020     		movne	r0, #0
 1820              	.LVL169:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1821              		.loc 1 1018 20 view .LVU483
 1822 0044 0120     		moveq	r0, #1
 1823 0046 F1E7     		b	.L179
 1824              	.L182:
1020:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 1825              		.loc 1 1020 13 is_stmt 1 view .LVU484
 1826 0048 E72C     		cmp	r4, #231
 1827 004a 06D9     		bls	.L188
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1828              		.loc 1 1018 20 is_stmt 0 view .LVU485
 1829 004c F12C     		cmp	r4, #241
 1830 004e F7E7     		b	.L190
 1831              	.LVL170:
 1832              	.L180:
1028:tmk_core/common/action.c ****                 return true;
 1833              		.loc 1 1028 13 is_stmt 1 view .LVU486
1028:tmk_core/common/action.c ****                 return true;
 1834              		.loc 1 1028 16 is_stmt 0 view .LVU487
 1835 0050 C0F3C020 		ubfx	r0, r0, #11, #1
 1836              	.LVL171:
1028:tmk_core/common/action.c ****                 return true;
 1837              		.loc 1 1028 16 view .LVU488
 1838 0054 EAE7     		b	.L179
 1839              	.LVL172:
 1840              	.L184:
1033:tmk_core/common/action.c **** }
 1841              		.loc 1 1033 12 view .LVU489
 1842 0056 0020     		movs	r0, #0
 1843              	.LVL173:
1033:tmk_core/common/action.c **** }
 1844              		.loc 1 1033 12 view .LVU490
 1845 0058 E8E7     		b	.L179
 1846              	.LVL174:
 1847              	.L188:
1016:tmk_core/common/action.c ****             }
 1848              		.loc 1 1016 28 view .LVU491
 1849 005a 0846     		mov	r0, r1
 1850              	.LVL175:
1016:tmk_core/common/action.c ****             }
 1851              		.loc 1 1016 28 view .LVU492
 1852 005c E6E7     		b	.L179
 1853              		.cfi_endproc
 1854              	.LFE27:
 1856              		.section	.text.is_tap_key,"ax",%progbits
 1857              		.align	1
 1858              		.global	is_tap_key
 1859              		.syntax unified
 1860              		.thumb
 1861              		.thumb_func
 1862              		.fpu fpv4-sp-d16
 1864              	is_tap_key:
 1865              	.LFB26:
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1866              		.loc 1 997 31 is_stmt 1 view -0
 1867              		.cfi_startproc
 1868              		@ args = 0, pretend = 0, frame = 8
 1869              		@ frame_needed = 0, uses_anonymous_args = 0
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1870              		.loc 1 998 5 view .LVU494
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1871              		.loc 1 997 31 is_stmt 0 view .LVU495
 1872 0000 07B5     		push	{r0, r1, r2, lr}
 1873              		.cfi_def_cfa_offset 16
 1874              		.cfi_offset 14, -4
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1875              		.loc 1 997 31 view .LVU496
 1876 0002 ADF80400 		strh	r0, [sp, #4]	@ movhi
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 1877              		.loc 1 998 23 view .LVU497
 1878 0006 0198     		ldr	r0, [sp, #4]
 1879 0008 FFF7FEFF 		bl	layer_switch_get_action
 1880              	.LVL176:
 999:tmk_core/common/action.c **** }
 1881              		.loc 1 999 5 is_stmt 1 view .LVU498
1000:tmk_core/common/action.c **** 
 1882              		.loc 1 1000 1 is_stmt 0 view .LVU499
 1883 000c 03B0     		add	sp, sp, #12
 1884              		.cfi_def_cfa_offset 4
 1885              		@ sp needed
 1886 000e 5DF804EB 		ldr	lr, [sp], #4
 1887              		.cfi_restore 14
 1888              		.cfi_def_cfa_offset 0
 999:tmk_core/common/action.c **** }
 1889              		.loc 1 999 12 view .LVU500
 1890 0012 FFF7FEBF 		b	is_tap_action
 1891              	.LVL177:
 1892              		.cfi_endproc
 1893              	.LFE26:
 1895              		.section	.text.debug_event,"ax",%progbits
 1896              		.align	1
 1897              		.global	debug_event
 1898              		.syntax unified
 1899              		.thumb
 1900              		.thumb_func
 1901              		.fpu fpv4-sp-d16
 1903              	debug_event:
 1904              	.LFB28:
1035:tmk_core/common/action.c **** 
1036:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1037:tmk_core/common/action.c ****  *
1038:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1039:tmk_core/common/action.c ****  */
1040:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 1905              		.loc 1 1040 36 is_stmt 1 view -0
 1906              		.cfi_startproc
 1907              		@ args = 0, pretend = 0, frame = 8
 1908              		@ frame_needed = 0, uses_anonymous_args = 0
 1909              		@ link register save eliminated.
 1910              		.loc 1 1040 138 view .LVU502
 1911              		.loc 1 1040 36 is_stmt 0 view .LVU503
 1912 0000 82B0     		sub	sp, sp, #8
 1913              		.cfi_def_cfa_offset 8
 1914              		.loc 1 1040 36 view .LVU504
 1915 0002 02AB     		add	r3, sp, #8
 1916 0004 03E90300 		stmdb	r3, {r0, r1}
 1917              		.loc 1 1040 1 view .LVU505
 1918 0008 02B0     		add	sp, sp, #8
 1919              		.cfi_def_cfa_offset 0
 1920              		@ sp needed
 1921 000a 7047     		bx	lr
 1922              		.cfi_endproc
 1923              	.LFE28:
 1925              		.section	.text.debug_record,"ax",%progbits
 1926              		.align	1
 1927              		.global	debug_record
 1928              		.syntax unified
 1929              		.thumb
 1930              		.thumb_func
 1931              		.fpu fpv4-sp-d16
 1933              	debug_record:
 1934              	.LFB29:
1041:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1042:tmk_core/common/action.c ****  *
1043:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1044:tmk_core/common/action.c ****  */
1045:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 1935              		.loc 1 1045 39 is_stmt 1 view -0
 1936              		.cfi_startproc
 1937              		@ args = 0, pretend = 0, frame = 8
 1938              		@ frame_needed = 0, uses_anonymous_args = 0
 1939              		@ link register save eliminated.
1046:tmk_core/common/action.c ****     debug_event(record.event);
 1940              		.loc 1 1046 5 view .LVU507
1047:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1048:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 1941              		.loc 1 1048 77 view .LVU508
1045:tmk_core/common/action.c ****     debug_event(record.event);
 1942              		.loc 1 1045 39 is_stmt 0 view .LVU509
 1943 0000 82B0     		sub	sp, sp, #8
 1944              		.cfi_def_cfa_offset 8
1045:tmk_core/common/action.c ****     debug_event(record.event);
 1945              		.loc 1 1045 39 view .LVU510
 1946 0002 02AB     		add	r3, sp, #8
 1947 0004 03E90300 		stmdb	r3, {r0, r1}
1049:tmk_core/common/action.c **** #endif
1050:tmk_core/common/action.c **** }
 1948              		.loc 1 1050 1 view .LVU511
 1949 0008 02B0     		add	sp, sp, #8
 1950              		.cfi_def_cfa_offset 0
 1951              		@ sp needed
 1952 000a 7047     		bx	lr
 1953              		.cfi_endproc
 1954              	.LFE29:
 1956              		.section	.text.debug_action,"ax",%progbits
 1957              		.align	1
 1958              		.global	debug_action
 1959              		.syntax unified
 1960              		.thumb
 1961              		.thumb_func
 1962              		.fpu fpv4-sp-d16
 1964              	debug_action:
 1965              	.LVL178:
 1966              	.LFB30:
1051:tmk_core/common/action.c **** 
1052:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1053:tmk_core/common/action.c ****  *
1054:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1055:tmk_core/common/action.c ****  */
1056:tmk_core/common/action.c **** void debug_action(action_t action) {
 1967              		.loc 1 1056 36 is_stmt 1 view -0
 1968              		.cfi_startproc
 1969              		@ args = 0, pretend = 0, frame = 0
 1970              		@ frame_needed = 0, uses_anonymous_args = 0
 1971              		@ link register save eliminated.
1057:tmk_core/common/action.c ****     switch (action.kind.id) {
 1972              		.loc 1 1057 5 view .LVU513
1058:tmk_core/common/action.c ****         case ACT_LMODS:
1059:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_RMODS:
1062:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1065:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1068:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_USAGE:
1071:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1074:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1080:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1083:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1086:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         case ACT_MACRO:
1089:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****         case ACT_FUNCTION:
1092:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1093:tmk_core/common/action.c ****             break;
1094:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1095:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1096:tmk_core/common/action.c ****             break;
1097:tmk_core/common/action.c ****         default:
1098:tmk_core/common/action.c ****             dprint("UNKNOWN");
1099:tmk_core/common/action.c ****             break;
1100:tmk_core/common/action.c ****     }
1101:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 1973              		.loc 1 1101 75 view .LVU514
1102:tmk_core/common/action.c **** }
 1974              		.loc 1 1102 1 is_stmt 0 view .LVU515
 1975 0000 7047     		bx	lr
 1976              		.cfi_endproc
 1977              	.LFE30:
 1979              		.global	disable_action_cache
 1980              		.comm	tp_buttons,4,4
 1981              		.section	.rodata
 1982              		.align	1
 1983              		.set	.LANCHOR0,. + 0
 1986              	CSWTCH.10:
 1987 0000 81       		.byte	-127
 1988 0001 82       		.byte	-126
 1989 0002 83       		.byte	-125
 1990 0003 00       		.space	1
 1993              	CSWTCH.11:
 1994 0004 E200     		.short	226
 1995 0006 E900     		.short	233
 1996 0008 EA00     		.short	234
 1997 000a B500     		.short	181
 1998 000c B600     		.short	182
 1999 000e B700     		.short	183
 2000 0010 CD00     		.short	205
 2001 0012 8301     		.short	387
 2002 0014 CC00     		.short	204
 2003 0016 8A01     		.short	394
 2004 0018 9201     		.short	402
 2005 001a 9401     		.short	404
 2006 001c 2102     		.short	545
 2007 001e 2302     		.short	547
 2008 0020 2402     		.short	548
 2009 0022 2502     		.short	549
 2010 0024 2602     		.short	550
 2011 0026 2702     		.short	551
 2012 0028 2A02     		.short	554
 2013 002a B300     		.short	179
 2014 002c B400     		.short	180
 2015 002e 6F00     		.short	111
 2016 0030 7000     		.short	112
 2017              		.bss
 2018              		.set	.LANCHOR1,. + 0
 2021              	disable_action_cache:
 2022 0000 00       		.space	1
 2023              		.text
 2024              	.Letext0:
 2025              		.file 4 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/machine/_default_t
 2026              		.file 5 "/usr/local/Cellar/arm-gcc-bin@8/8-2019-q3-update/arm-none-eabi/include/sys/_stdint.h"
 2027              		.file 6 "tmk_core/common/keycode.h"
 2028              		.file 7 "tmk_core/common/host.h"
 2029              		.file 8 "tmk_core/common/mousekey.h"
 2030              		.file 9 "tmk_core/common/command.h"
 2031              		.file 10 "tmk_core/common/action_code.h"
 2032              		.file 11 "tmk_core/common/action.h"
 2033              		.file 12 "tmk_core/common/action_layer.h"
 2034              		.file 13 "tmk_core/common/action_util.h"
 2035              		.file 14 "tmk_core/protocol/arm_atsam/clks.h"
 2036              		.file 15 "tmk_core/common/debug.h"
 2037              		.file 16 "tmk_core/common/led.h"
 2038              		.file 17 "tmk_core/common/action_macro.h"
 2039              		.file 18 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:18     .text.action_exec:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:26     .text.action_exec:0000000000000000 action_exec
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:68     .text.process_record_quantum:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:75     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:93     .text.post_process_record_quantum:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:100    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:115    .text.process_record_tap_hint:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:122    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:141    .text.register_code:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:148    .text.register_code:0000000000000000 register_code
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:293    .text.register_code:0000000000000080 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:299    .text.unregister_code:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:306    .text.unregister_code:0000000000000000 unregister_code
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:411    .text.tap_code:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:418    .text.tap_code:0000000000000000 tap_code
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:461    .text.register_mods:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:468    .text.register_mods:0000000000000000 register_mods
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:504    .text.unregister_mods:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:511    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:547    .text.process_action:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:554    .text.process_action:0000000000000000 process_action
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:634    .text.process_action:0000000000000056 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:651    .text.process_action:0000000000000076 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1424   .text.process_record:0000000000000000 process_record
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1196   .text.process_action:00000000000002e2 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1353   .text.process_record_handler:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1360   .text.process_record_handler:0000000000000000 process_record_handler
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1417   .text.process_record:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1512   .text.process_record_nocache:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1519   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1548   .text.process_record_nocache:0000000000000014 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1553   .text.register_weak_mods:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1560   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1596   .text.unregister_weak_mods:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1603   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1639   .text.clear_keyboard_but_mods_and_keys:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1646   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1685   .text.clear_keyboard_but_mods:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1692   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1720   .text.clear_keyboard:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1727   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1755   .text.is_tap_action:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1762   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1857   .text.is_tap_key:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1864   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1896   .text.debug_event:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1903   .text.debug_event:0000000000000000 debug_event
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1926   .text.debug_record:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1933   .text.debug_record:0000000000000000 debug_record
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1957   .text.debug_action:0000000000000000 $t
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1964   .text.debug_action:0000000000000000 debug_action
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:2021   .bss:0000000000000000 disable_action_cache
                            *COM*:0000000000000004 tp_buttons
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1982   .rodata:0000000000000000 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1986   .rodata:0000000000000000 CSWTCH.10
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1993   .rodata:0000000000000004 CSWTCH.11
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:2022   .bss:0000000000000000 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1201   .text.process_action:00000000000002e7 $d
/var/folders/z4/wxlp73js78g02fcv9dbq6g8h0000gn/T//cceZAqU8.s:1201   .text.process_action:00000000000002e8 $t

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
keyboard_report
del_mods
CLK_delay_ms
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
